{
  "val": [
    {
      "name": "epcDbtrAcctId",
      "text": "The requirements are as follows:\n\nIn the package of isoStdIso20022TechXsdPain00800101, there is a context DirectDebitTransactionInformation1, where it is specified that for Debtor Account (direct debit transaction information debtor Account), only IBAN (International Bank Account Number) is allowed. \n\nAs a result, the sizes of all other account identification types, such as BBAN (Basic Bank Account Number), proprietary account, UPIC (Universal Payment Identification Code), account type, currency, and account name, must be zero. This means these fields should not contain any values.\n\nThis requirement is according to the row 14 on page 13 of SEPA (Single Euro Payments Area) B2B (Business to Business) Direct Debit C2B Implementation Guidelines.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* For Debtor Account (drctDbtTxInf DbtrAcct), only IBAN is allowed. \n   See row 14 on page 13 of SEPA B2B Direct Debit C2B Implementation Guidelines. */\n\ncontext DirectDebitTransactionInformation1\ninv EPC_DbtrAcctId:\ndbtrAcct.id.bBAN->size() = 0 and \ndbtrAcct.id.prtryAcct->size() = 0 and \ndbtrAcct.id.uPIC->size() = 0 and\ndbtrAcct.tp->size() = 0 and \ndbtrAcct.ccy->size() = 0 and\ndbtrAcct.nm->size() = 0\n\nendpackage"
    },
    {
      "name": "epcPACS3MappingAmdmntInfDtlsorgnlCdtrSchemeId",
      "text": "The requirements are as follows:\n\nIn the context of AmendmentInformationDetails1, there must exist a business rule which asserts that the original Creditor Scheme Identification (`orgnlCdtrSchmeId`) must only contain a Private Identification Other Identification (`prvtId othrId`), and all other fields in `orgnlCdtrSchmeId.id.orgId` should be empty. Specifically, the size of the following fields should be zero: Organization ID, Issuer, Driver's License Number, Customer Number, Social Security Number, Alien Registration Number, Passport Number, Tax Identification Number, Identity Card Number, Employer Identification Number, and Date and Place of Birth. The rule applies to the field parameters of the Private ID object within the original Creditor Scheme ID. \n\nThis rule is necessary for proper mapping of fields in accordance with the SEPA B2B Direct Debit C2B Implementation Guidelines and the EBA pacs3 schema.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* Warning: For Original Creditor Scheme Id in Mandate Related Information AmendmentInformation Details (drctDbtTx \n   MndtRltfInf amdmntInfDtls orgnlCdtrSchmeId), only Private Identification Other Identification (prvtId othrId) \n   should be included in the Id, if these fields are to be mapped correctly to pacs3 Amendment Information Details.\n   Ref row 13 on pg 10 of SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3, and EBA pacs3 schema. */\n\ncontext AmendmentInformationDetails1\ninv EPC_PACS3Mapping_amdmntInfDtlsorgnlCdtrSchmeId:\norgnlCdtrSchmeId.id.orgId->size() = 0 and\norgnlCdtrSchmeId.id.prvtId.issr->size() = 0 and\norgnlCdtrSchmeId.id.prvtId.drvrsLicNb->size() = 0 and\norgnlCdtrSchmeId.id.prvtId.cstmrNb->size() = 0 and\norgnlCdtrSchmeId.id.prvtId.sclSctyNb->size() = 0 and\norgnlCdtrSchmeId.id.prvtId.alnRegnNb->size() = 0 and\norgnlCdtrSchmeId.id.prvtId.psptNb->size() = 0  and\norgnlCdtrSchmeId.id.prvtId.taxIdNb->size() = 0 and\norgnlCdtrSchmeId.id.prvtId.idntyCardNb->size() = 0  and\norgnlCdtrSchmeId.id.prvtId.mplyrIdNb->size() = 0 and \norgnlCdtrSchmeId.id.prvtId.dtAndPlcOfBirth->size() = 0\n\nendpackage"
    },
    {
      "name": "epcPACS3MappingAmdmntInfDtlsOrgnldbtrAgr",
      "text": "The requirements are as follows: In the context of AmendmentInformationDetails1, within the package isoStdIso20022TechXsdPain00800101, the requirement for Original Debtor Agent in Mandate Related Information Amendment Information Details is that only the Proprietary Identification should be used if these fields are to be mapped correctly to pacs3 Amendment Information Details. These criteria come from the SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3 and the EBA pacs3 schema referenced. Specifically, it ensures that the size of the following lists are all zero: clearance system member identification, name and address, bank identifier code, combined identification, and branch identification in the financial institution identification of the original debtor agent.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* Warning: For Original Debtor Agent in Mandate Related Information AmendmentInformation Details (drctDbtTx\n   MndtRltfInf amdmntInfDtls OrgnldbtrAgt), only Proprietary Identification (finInstnId prtryId) should be used\n   if these fields are to be mapped correctly to pacs3 Amendment Information Details.\n   Ref row 6 on pg 11 of SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3, and EBA pacs3 schema. */\n\ncontext AmendmentInformationDetails1\ninv EPC_PACS3Mapping_amdmntInfDtlsOrgnldbtrAgt:\norgnlDbtrAgt.finInstnId.clrSysMmbId->size() = 0 and \norgnlDbtrAgt.finInstnId.nmAndAdr->size() =0 and \norgnlDbtrAgt.finInstnId.bIC->size() = 0 and \norgnlDbtrAgt.finInstnId.cmbndId->size() = 0 and\norgnlDbtrAgt.brnchId->size() = 0\n\nendpackage"
    },
    {
      "name": "epcPmtInfultmtCtdrIdorgId",
      "text": "The requirement is as follows:\nIn the context of Payment Instruction Information (PaymentInstructionInformation2), there is a constraint (EPC_PmtInfultmtCdtrIdorgId) on the Payment Information Ultimate Creditor Organisation Identification (PmtInf ultmtCdtr Id orgId). This identification can only contain one of the subelements such as BIC, IBEI, BEI, EANGLN, USCHU, DUNS, BkPryId, TaxIdNb, or prtryId. In other words, the sum of the sizes of all these subelements should be less than or equal to one. This requirement is aligned with the rule stated in line 7 on page 9 of the SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* The Payment Information Ultimate Creditor Organisation Identification (PmtInf ultmtCdtr Id orgId) can only \n   contain one of the subelements BIC, IBEI, BEI, EANGLN, USCHU, DUNS, BkPryId, TaxIdNb, or prtryId.\n   See row 7 on pg 9 of SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3. */\n\ncontext PaymentInstructionInformation2\ninv EPC_PmtInfultmtCdtrIdorgId:\nultmtCdtr.id.orgId->size() = 1 implies \n (ultmtCdtr.id.orgId.bIC->size() +\n  ultmtCdtr.id.orgId.iBEI->size() +\n  ultmtCdtr.id.orgId.bEI->size() +\n  ultmtCdtr.id.orgId.eANGLN->size() +\n  ultmtCdtr.id.orgId.uSCHU->size() +\n  ultmtCdtr.id.orgId.dUNS->size() +\n  ultmtCdtr.id.orgId.bkPtyId->size() +\n  ultmtCdtr.id.orgId.taxIdNb->size() +\n  ultmtCdtr.id.orgId.prtryId->size()) <= 1\n\nendpackage"
    },
    {
      "name": "epcSvcLvlCd",
      "text": "The requirement is as follows: In the context of the ServiceLevel3Choice package within the ISO 20022 technical standard pain.008.001.01 model, the value for Service Level Code, denoted by 'cd' within the 'PmtInf pmtTpInf svcLvl Cd' path, must always be set to 'SEPA'. This requirement is derived from the SEPA B2B Direct Debit C2B Implementation Guidelines document, specifically row 7 of section 2.1.3 of the Payment Information on page 7.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* The value for Service Level Code (PmtInf pmtTpInf svcLvl Cd) must be set to 'SEPA'. \n   See row 7 of section 2.1.3 of Payment Information pg 7 of SEPA B2B Direct Debit C2B \n   Implementation Guidelines document. */\n\ncontext ServiceLevel3Choice\ninv EPC_svcLvlCd:\ncd = 'SEPA'\n\nendpackage"
    },
    {
      "name": "epcAosDrctDbtTxInfPurpPrtry",
      "text": "The requirement is as follows:\n\nThere's a package named isoStdIso20022TechXsdPain00800101 in the system related to some Direct Debit Transaction Information. \n\nIt's noted that the 'Prtry' element in 'DrctDbtTxInf Purpose' is used exclusively for Direct Debit Transaction Information of AOS (Automated Operations Services). Non-AOS banks or entities are warned that they may reject messages containing these elements. \n\nTherefore, an invariant is established for the DirectDebitTransactionInformation1 business context where for any such direct debit transaction, the number of 'Prtry' elements contained in the purpose of the transaction (purp.prtry) must be zero. \n\nThis means that no 'Prtry' elements should be included in the purpose of these direct debit transactions as they can cause issues with non-AOS entities.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* Warning: The element Prtry in DrctDbtTxInf Purpose is AOS only. Instructed banks that are not in the\n   AOS community may reject messages containing these elements.\n   Ref section 1.2 if the SEPA B2B Direct Debit C2B Implementation Guidelines. */\n\ncontext DirectDebitTransactionInformation1\ninv EPC_AOS_DrctDbtTxInfPurpPrtry:\npurp.prtry->size() = 0\n\nendpackage"
    },
    {
      "name": "epcRmtInfStrd",
      "text": "The requirement is as follows: In the package of isoStdIso20022TechXsdPain00800101, a certain set of rules is specified for the 'RemittanceInformation1' context, which must satisfy the following conditions. The 'Structured' feature in Remittance Information is permitted to occur only once. This requirement aligns with the guidelines provided in SEPA B2B Direct Debit C2B Implementation, specifically in row 7 on page 14.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* Only one occurrence of 'Structured' in Remittance Information is allowed.\n   See row 7 on pg 14 of SEPA B2B Direct Debit C2B Implementation Guidelines. */\n\ncontext RemittanceInformation1\ninv EPC_RmtInfStrd:\nstrd->size() = 1\n\nendpackage"
    },
    {
      "name": "epcLclInstrmCd",
      "text": "The requirement is as follows: \n\nThe system is designed according to the model defined in the file: pain.008.001.01corrected.xsd. After referring to the SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3, especially section 2.1.3 row 11, a constraint for the Local Instrument Code (PmtInf PmtTpInf Cd) is identified. Only the value 'B2B' is permitted for the Local Instrument code in the package isoStdIso20022TechXsdPain00800101. It is specifically noteworthy that 'B2B' is used to signify a B2B direct debit within the context of LocalInstrument1Choice.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* Only 'B2B' is allowed for Local Instrument Code (PmtInf PmtTpInf Cd). 'B2B' is used to indicate a B2B direct\n   debit. \n   See row 11 of section 2.1.3 on pg 7 of SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3. */\n\ncontext LocalInstrument1Choice\ninv EPC_lclInstrmCd:\ncd = 'B2B'\n\nendpackage"
    },
    {
      "name": "RoyalAndLoyal",
      "text": "The requirements are as follows:\n\nThe ServiceLevel context features a number of invariants or rules that operate on data sets, transforming them, and subsequently confirming the result. For instance, the initial character 'X' must be added to the given sequence, or the absence of partners in the program must be confirmed.\n\nThe Transaction context checks whether certain elements are of a specified type.\n\nIn the LoyaltyAccount context, several conditions are established, such as verifying that the amount of points is greater than zero if there are any transactions, and ensuring that all transactions derive from the same customer.\n\nThe TransactionReport context verifies that the transactions in a report fall within the specified date range, and that these transactions are a subset of those on the card.\n\nCustomerCard must confirm that the owner is over 18 years old and that the card is valid from the date specified and before the expiration date.\n\nLastly, LoyaltyProgram defines requirements such as the inclusion of the account number, the presence of a service level named 'basic', the collection of services by a partner, and the validation of participant ages. It also specifies the creation and enrollment of customers to the program.\n\nPlease note that without the full context, some analysis might be challenging to fully understand. For better clarification, it would be best to refer to the original software requirements and design documents.",
      "label": "--------------------------------------------------------------------------------\n-- Copyright (c) 2007,2008 M.Garcia and others.\n-- All rights reserved. This program and the accompanying materials\n-- are made available under the terms of the Eclipse Public License v1.0\n-- which accompanies this distribution, and is available at\n-- http://www.eclipse.org/legal/epl-v10.html\n--\n-- Contributors:\n--     J.Warmer, A.Kleppe - original example in 'The Object Constraint Language Second Edition'\n--     M.Garcia - realisation of the example for use within Eclipse \n--------------------------------------------------------------------------------\n\nimport 'RoyalAndLoyal.ecore'\n\npackage RandL\n\ncontext ServiceLevel\ninv invariant_ServiceLevel19 :\n\t(Sequence{'a', 'b', 'c', 'c', 'd', 'e'}->prepend('X')) = Sequence{'X', 'a', 'b', 'c', 'c', 'd', 'e'}\ninv invariant_ServiceLevel17 :\n\t(OrderedSet{'a', 'b', 'c', 'd'}->subOrderedSet(2, 3)) = OrderedSet{'b', 'c'}\ninv invariant_ServiceLevel4 :\n\tBag{Set{1, 2}, Set{1, 2}, Set{4, 5, 6}}->isEmpty()\ninv invariant_ServiceLevel12 :\n\t(OrderedSet{'a', 'b', 'c', 'd'}->last()) = 'd'\ninv invariant_ServiceLevel18 :\n\t(Sequence{'a', 'b', 'c', 'c', 'd', 'e'}->append('X')) = Sequence{'a', 'b', 'c', 'c', 'd', 'e', 'X'}\ninv invariant_ServiceLevel1 :\n\tself.program.partners->isEmpty()\ninv invariant_ServiceLevel10 :\n\t(Set{1, 4, 7, 10}->symmetricDifference(Set{4, 5, 7})) = Set{1, 5, 10}\ninv invariant_ServiceLevel7 :\n\tSequence{2, 1, 2, 3, 5, 6, 4}->isEmpty()\ninv invariant_ServiceLevel5 :\n\tBag{1, 1, 2, 2, 4, 5, 6}->isEmpty()\ninv invariant_ServiceLevel16 :\n\t(Sequence{'a', 'b', 'c', 'c', 'd', 'e'}->subSequence(3, 5)) = Sequence{'c', 'c', 'd'}\ninv invariant_ServiceLevel6 :\n\tSequence{Set{1, 2}, Set{2, 3}, Set{4, 5, 6}}->isEmpty()\ninv invariant_ServiceLevel13 :\n\t(Sequence{'a', 'b', 'c', 'c', 'd', 'e'}->at(3)) = 'c'\ninv invariant_ServiceLevel3 :\n\tSet{1, 2, 3, 4, 5, 6}->isEmpty()\ninv invariant_ServiceLevel11 :\n\t(Sequence{'a', 'b', 'c', 'c', 'd', 'e'}->first()) = 'a'\ninv invariant_ServiceLevel8 :\n\t((Set{1, 4, 7, 10}) - Set{4, 7}) = Set{1, 10}\ninv invariant_ServiceLevel2 :\n\tSet{Set{1, 2}, Set{2, 3}, Set{4, 5, 6}}->isEmpty()\ninv invariant_ServiceLevel9 :\n\t((OrderedSet{12, 9, 6, 3}) - Set{1, 3, 2}) = OrderedSet{12, 9, 6}\ninv invariant_ServiceLevel14 :\n\t(Sequence{'a', 'b', 'c', 'c', 'd', 'e'}->indexOf('c')) = 3\ninv invariant_ServiceLevel15 :\n\t(OrderedSet{'a', 'b', 'c', 'd'}->insertAt(3, 'X')) = OrderedSet{'a', 'b', 'X', 'c', 'd'}\n\ncontext Transaction\ninv invariant_Transaction1 :\n\tself.oclIsKindOf(Transaction) = true\ninv invariant_Transaction3 :\n\tself.oclIsTypeOf(Burning) = false\ninv invariant_Transaction2 :\n\tself.oclIsTypeOf(Transaction) = true\ninv invariant_Transaction4 :\n\tself.oclIsKindOf(Burning) = false\n\ncontext Transaction::program() : LoyaltyProgram\npost:\tresult = self.card.Membership.programs\n\ncontext LoyaltyAccount\ninv invariant_points :\n\t(self.points > 0) implies self.transactions->exists( t : Transaction | t.points > 0 )\ninv invariant_transactions :\n\tself.transactions->collect( i_Transaction : Transaction | i_Transaction.points )->exists( p : Integer | p = 500 )\ninv invariant_oneOwner :\n\t(self.transactions->collect( i_Transaction : Transaction | i_Transaction.card )->collect( i_CustomerCard : CustomerCard | i_CustomerCard.owner )->asSet()->size()) = 1\n\ncontext LoyaltyAccount::points : Integer\ninit :\n\t0\n\ncontext LoyaltyAccount::totalPointsEarned : Integer\nderive :\n\tself.transactions->select( i_Transaction : Transaction | i_Transaction.oclIsTypeOf(Earning) )->collect( i_Transaction : Transaction | i_Transaction.points )->sum()\n\ncontext LoyaltyAccount::usedServices : Set(Service)\nderive :\n\tself.transactions->collect( i_Transaction : Transaction | i_Transaction.generatedBy )->asSet()\n\ncontext LoyaltyAccount::transactions : Set(Transaction)\ninit :\n\tSet{}\n\ncontext LoyaltyAccount::getCustomerName() : String\nbody:\tself.Membership.card.owner.name\n\ncontext LoyaltyAccount::isEmpty() : Boolean\npost testPostSuggestedName:\tresult = self.points = 0\npre testPreSuggestedName:\ttrue\n\ncontext ProgramPartner\ninv invariant_totalPointsEarning2 :\n\t(self.deliveredServices->collect( i_Service : Service | i_Service.transactions )->select( i_Transaction : Transaction | i_Transaction.oclIsTypeOf(Earning) )->collect( i_Transaction : Transaction | i_Transaction.points )->sum()) < 10000\ninv invariant_totalPointsEarning :\n\t(self.deliveredServices->collect( i_Service : Service | i_Service.transactions )->select( i_Transaction : Transaction | i_Transaction.oclIsTypeOf(Earning) )->collect( i_Transaction : Transaction | i_Transaction.points )->sum()) < 10000\ninv invariant_nrOfParticipants :\n\tself.numberOfCustomers = self.programs->collect( i_LoyaltyProgram : LoyaltyProgram | i_LoyaltyProgram.participants )->size()\ndef  :\n\tgetBurningTransactions() : Set(Transaction) = self.deliveredServices.transactions->iterate(t : Transaction; resultSet : Set( Transaction) = Set{ } | if t.oclIsTypeOf(Burning) then resultSet->including(t) else resultSet endif)\ninv invariant_totalPoints :\n\t(self.deliveredServices->collect( i_Service : Service | i_Service.transactions )->collect( i_Transaction : Transaction | i_Transaction.points )->sum()) < 10000\ninv invariant_ProgramPartner1 :\n\tself.programs->collect( i_LoyaltyProgram : LoyaltyProgram | i_LoyaltyProgram.partners )->select( p : ProgramPartner | p <> self )->isEmpty()\ninv invariant_nrOfParticipants2 :\n\tself.numberOfCustomers = self.programs->collect( i_LoyaltyProgram : LoyaltyProgram | i_LoyaltyProgram.participants )->asSet()->size()\n\ncontext Burning\ninv invariant_Burning5 :\n\tself.oclIsTypeOf(Earning) = false\ninv invariant_Burning6 :\n\tself.oclIsKindOf(Earning) = false\ninv invariant_Burning4 :\n\tself.oclIsKindOf(Burning) = true\ninv invariant_Burning3 :\n\tself.oclIsTypeOf(Burning) = true\ninv invariant_Burning2 :\n\tself.oclIsTypeOf(Transaction) = false\ninv invariant_Burning1 :\n\tself.oclIsKindOf(Transaction) = true\n\ncontext TransactionReport\ninv invariant_dates :\n\tself.lines->collect( i_TransactionReportLine : TransactionReportLine | i_TransactionReportLine.date )->forAll( d : Date | d.isBefore(self.until) and d.isAfter(self.from) )\ninv invariant_cycle :\n\tself.card.transactions->includesAll(self.lines->collect( i_TransactionReportLine : TransactionReportLine | i_TransactionReportLine.transaction ))\n\ncontext TransactionReport::balance : Integer\nderive :\n\tself.card.Membership.account.points\n\ncontext TransactionReport::totalEarned : Integer\nderive :\n\tself.lines->collect( i_TransactionReportLine : TransactionReportLine | i_TransactionReportLine.transaction )->select( i_Transaction : Transaction | i_Transaction.oclIsTypeOf(Earning) )->collect( i_Transaction : Transaction | i_Transaction.points )->sum()\n\ncontext TransactionReport::totalBurned : Integer\nderive :\n\tself.lines->collect( i_TransactionReportLine : TransactionReportLine | i_TransactionReportLine.transaction )->select( i_Transaction : Transaction | i_Transaction.oclIsTypeOf(Burning) )->collect( i_Transaction : Transaction | i_Transaction.points )->sum()\n\ncontext TransactionReport::number : Integer\nderive :\n\tself.card.Membership.account.number\n\ncontext TransactionReport::name : String\nderive :\n\tself.card.owner.name\n\ncontext CustomerCard\ndef  :\n\tgetTotalPoints(d : Date) : Integer = self.transactions->select( i_Transaction : Transaction | i_Transaction.date.isAfter(d) )->collect( i_Transaction : Transaction | i_Transaction.points )->sum()\ninv invariant_CustomerCard4 :\n\tself.transactions->select( i_Transaction : Transaction | i_Transaction.points > 100 )->notEmpty()\ninv invariant_ofAge :\n\tself.owner.age >= 18\ninv invariant_CustomerCard3 :\n\tself.owner.programs->size() > 0\ninv invariant_checkDates :\n\tself.validFrom.isBefore(self.goodThru)\n--inv invariant_CustomerCard2 :\n--\tself.owner.dateOfBirth.isBefore(Date::now)\n--inv invariant_CustomerCard1 :\n--\tself.goodThru.isAfter(Date::now)\n--inv invariant_THIS :\n--\tlet correctDate : Boolean = self.validFrom.isBefore(Date::now) and self.goodThru.isAfter(Date::now) in if self.valid then\n--correctDate = false\n--else\n--correctDate = true\n--endif\n\ncontext CustomerCard::valid : Boolean\ninit :\n\ttrue\n\ncontext CustomerCard::printedName : String\nderive :\n\tself.owner.title.concat(' ').concat(self.owner.name)\n\ncontext CustomerCard::myLevel : ServiceLevel\nderive :\n\tself.Membership.currentLevel\n\ncontext CustomerCard::transactions : Set(Transaction)\ninit :\n\tSet{}\n\ncontext CustomerCard::getTransactions(until:Date, from:Date) : Set(Transaction)\nbody:\tself.transactions->select( i_Transaction : Transaction | i_Transaction.date.isAfter(from) and i_Transaction.date.isBefore(until) )\n\ncontext Membership\ndef  :\n\tgetCurrentLevelName() : String = self.currentLevel.name\ninv invariant_Membership1 :\n\t(self.account.points >= 0) or self.account->asSet()->isEmpty()\ninv invariant_Membership2 :\n\tself.participants.cards->collect( i_CustomerCard : CustomerCard | i_CustomerCard.Membership )->includes(self)\ninv invariant_noEarnings :\n\tprograms.partners.deliveredServices->forAll(pointsEarned = 0) implies account->isEmpty()\ninv invariant_correctCard :\n\tself.participants.cards->includes(self.card)\ninv invariant_Membership3 :\n\tself.programs.levels->includes(self.currentLevel)\n--inv invariant_noEarnings2 :\n--\tprograms.isSaving implies account->isEmpty()\ninv invariant_Membership4 :\n\tself.account->asSet()->isEmpty()\ninv invariant_levelAndColor :\n\t((self.currentLevel.name = 'Silver') implies (self.card.color = RandLColor::silver) and self.currentLevel.name = 'Gold') implies self.card.color = RandLColor::gold\ninv invariant_Membership5 :\n\tself.programs.levels->includes(self.currentLevel)\n\ncontext Service\ninv invariant_Service5 :\n\t'Anneke'.toUpperCase() = 'ANNEKE'\ninv invariant_Service6 :\n\t'Anneke'.toLowerCase() = 'anneke'\ninv invariant_Service7 :\n\t('Anneke and Jos'.substring(12, 14)) = 'Jos'\ninv invariant_Service4 :\n\t('Anneke '.concat('and Jos')) = 'Anneke and Jos'\ninv invariant_Service1 :\n\t(self.pointsEarned > 0) implies not (self.pointsBurned = 0)\ninv invariant_Service3 :\n\t('Anneke' = 'Jos') = false\ninv invariant_Service2 :\n\t'Anneke'.size() = 6\n\ncontext Service::upgradePointsEarned(amount:Integer) :\npost:\tself.calcPoints() = self.calcPoints() + amount\n\ncontext Customer\ninv invariant_Customer4 :\n\tself.name = 'Edward'\ninv invariant_Customer5 :\n\tself.title = 'Mr.'\ninv invariant_Customer10 :\n\tself.programs->collect( i_LoyaltyProgram : LoyaltyProgram | i_LoyaltyProgram.partners )->collectNested( i_ProgramPartner : ProgramPartner | i_ProgramPartner.deliveredServices )->isEmpty()\ninv invariant_Customer2 :\n\tself.name = 'Edward'\ninv invariant_Customer9 :\n\tself.memberships->collect( i_Membership : Membership | i_Membership.account )->reject( i_LoyaltyAccount : LoyaltyAccount | not (i_LoyaltyAccount.points > 0) )->isEmpty()\ninv invariant_myInvariant23 :\n\tself.name = 'Edward'\ninv invariant_Customer1 :\n\t(self.cards->select( i_CustomerCard : CustomerCard | i_CustomerCard.valid = true )->size()) > 1\ninv invariant_Customer7 :\n\t(self.gender = Gender::male) implies self.title = 'Mr.'\ninv invariant_Customer11 :\n\tSet{1, 2, 3 }->iterate(i : Integer; sum : Integer = 0 | sum + i) = 0\ninv invariant_ANY :\n\tself.memberships->collect( i_Membership : Membership | i_Membership.account )->any( i_LoyaltyAccount : LoyaltyAccount | i_LoyaltyAccount.number < 10000 )->asSet()->isEmpty()\ninv invariant_ofAge :\n\tself.age >= 18\ninv invariant_sizesAgree :\n\tself.programs->size() = self.cards->select( i_CustomerCard : CustomerCard | i_CustomerCard.valid = true )->size()\ninv invariant_Customer8 :\n\tself.memberships->collect( i_Membership : Membership | i_Membership.account )->select( i_LoyaltyAccount : LoyaltyAccount | i_LoyaltyAccount.points > 0 )->isEmpty()\ninv invariant_Customer6 :\n\t(self.name = 'Edward') and self.title = 'Mr.'\ndef  :\n\twellUsedCards : Set(CustomerCard) = self.cards->select( i_CustomerCard : CustomerCard | (i_CustomerCard.transactions->collect( i_Transaction : Transaction | i_Transaction.points )->sum()) > 10000 )\ninv invariant_Customer3 :\n\tself.name = 'Edward'\ndef  :\n\tinitial : String = self.name.substring(1, 1)\ninv invariant_Customer12 :\n\tself.programs->size() = self.cards->select( i_CustomerCard : CustomerCard | i_CustomerCard.valid = true )->size()\ndef  :\n\tcardsForProgram(p : LoyaltyProgram) : Sequence(CustomerCard) = p.memberships->collect( i_Membership : Membership | i_Membership.card )\ndef  :\n\tloyalToCompanies : Bag(ProgramPartner) = self.programs->collect( i_LoyaltyProgram : LoyaltyProgram | i_LoyaltyProgram.partners )\n\ncontext Customer::birthdayHappens() :\npost:\tself.age = self.age + 1\n\ncontext TransactionReportLine::partnerName : String\nderive :\n\tself.transaction.generatedBy.partner.name\n\ncontext TransactionReportLine::serviceDesc : String\nderive :\n\tself.transaction.generatedBy.description\n\ncontext TransactionReportLine::points : Integer\nderive :\n\tself.transaction.points\n\ncontext TransactionReportLine::amount : Real\nderive :\n\tself.transaction.amount\n\ncontext TransactionReportLine::date : Date\nderive :\n\tself.transaction.date\n\ncontext LoyaltyProgram\ninv invariant_LoyaltyProgram18 :\n\tself.participants->forAll( c1 : Customer | self.participants->forAll( c2 : Customer | (c1 <> c2) implies c1.name <> c2.name ) )\ninv invariant_LoyaltyProgram1 :\n\tself.levels->includesAll(self.memberships->collect( i_Membership : Membership | i_Membership.currentLevel ))\ninv invariant_LoyaltyProgram17 :\n\tself.participants->forAll( c1 : Customer, c2 : Customer | (c1 <> c2) implies c1.name <> c2.name )\ninv invariant_LoyaltyProgram14 :\n\tself.memberships->collect( i_Membership : Membership | i_Membership.account )->isUnique( acc : LoyaltyAccount | acc.number )\ndef  :\n\tsortedAccounts : Sequence(LoyaltyAccount) = self.memberships->collect( i_Membership : Membership | i_Membership.account )->sortedBy( i_LoyaltyAccount : LoyaltyAccount | i_LoyaltyAccount.number )\ninv invariant_LoyaltyProgram10 :\n\tSequence{1 .. 10}->isEmpty()\ninv invariant_firstLevel :\n\tself.levels->first().name = 'Silver'\ninv invariant_LoyaltyProgram8 :\n\tBag{1, 3, 4, 3, 5}->isEmpty()\ninv invariant_knownServiceLevel :\n\tself.levels->includesAll(self.memberships->collect( i_Membership : Membership | i_Membership.currentLevel ))\ndef  :\n\tgetServicesByLevel(levelName : String) : Set(Service) = self.levels->select( i_ServiceLevel : ServiceLevel | i_ServiceLevel.name = levelName )->collect( i_ServiceLevel : ServiceLevel | i_ServiceLevel.availableServices )->asSet()\ninv invariant_LoyaltyProgram13 :\n\tself.memberships->collect( i_Membership : Membership | i_Membership.account )->isUnique( acc : LoyaltyAccount | acc.number )\ninv invariant_minServices :\n\t(self.partners->collect( i_ProgramPartner : ProgramPartner | i_ProgramPartner.deliveredServices )->size()) >= 1\ninv invariant_LoyaltyProgram19 :\n\tself.memberships->collect( i_Membership : Membership | i_Membership.account )->one( i_LoyaltyAccount : LoyaltyAccount | i_LoyaltyAccount.number < 10000 )\ninv invariant_LoyaltyProgram12 :\n\tself.participants->size() < 10000\ninv invariant_LoyaltyProgram7 :\n\tSequence{'ape', 'nut'}->isEmpty()\ninv invariant_LoyaltyProgram11 :\n\tSequence{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}->isEmpty()\ndef  :\n\tisSaving : Boolean = self.partners->collect( i_ProgramPartner : ProgramPartner | i_ProgramPartner.deliveredServices )->forAll( i_Service : Service | i_Service.pointsEarned = 0 )\ninv invariant_LoyaltyProgram3 :\n\tSet{1, 2, 5, 88}->isEmpty()\ninv invariant_LoyaltyProgram2 :\n\tself.levels->exists( i_ServiceLevel : ServiceLevel | i_ServiceLevel.name = 'basic' )\ninv invariant_noAccounts :\n\t(self.partners->collect( i_ProgramPartner : ProgramPartner | i_ProgramPartner.deliveredServices )->forAll( i_Service : Service | (i_Service.pointsEarned = 0) and i_Service.pointsBurned = 0 )) implies self.memberships->collect( i_Membership : Membership | i_Membership.account )->isEmpty()\ninv invariant_LoyaltyProgram15 :\n\tself.memberships->collect( i_Membership : Membership | i_Membership.account )->isUnique( i_LoyaltyAccount : LoyaltyAccount | i_LoyaltyAccount.number )\ninv invariant_LoyaltyProgram4 :\n\tSet{'apple', 'orange', 'strawberry'}->isEmpty()\ninv invariant_LoyaltyProgram6 :\n\tSequence{1, 3, 45, 2, 3}->isEmpty()\ninv invariant_LoyaltyProgram9 :\n\tSequence{1 .. 6 + 4}->isEmpty()\ninv invariant_LoyaltyProgram5 :\n\tOrderedSet{'apple', 'orange', 'strawberry', 'pear'}->isEmpty()\ninv invariant_LoyaltyProgram16 :\n\tself.participants->forAll( i_Customer : Customer | i_Customer.age() <= 70 )\n\ncontext LoyaltyProgram::selectPopularPartners(d:Date) : Set(ProgramPartner)\npost:\tlet popularTrans : Set(Transaction) = result->collect( i_ProgramPartner : ProgramPartner | i_ProgramPartner.deliveredServices )->collect( i_Service : Service | i_Service.transactions )->asSet() in (popularTrans->forAll( i_Transaction : Transaction | i_Transaction.date.isAfter(d) )) and (popularTrans->select( i_Transaction : Transaction | i_Transaction.amount > 500.00 )->size()) > 20000\n\ncontext LoyaltyProgram::addService(s:Service, l:ServiceLevel, p:ProgramPartner) :\npre levelsIncludesArgL:\tself.levels->includes(l)\npost servicesIncludesArgS:\tself.levels->collect( i_ServiceLevel : ServiceLevel | i_ServiceLevel.availableServices )->includes(s)\npre partnersIncludesP:\tself.partners->includes(p)\npost servicesIncludesP:\tself.partners->collect( i_ProgramPartner : ProgramPartner | i_ProgramPartner.deliveredServices )->includes(s)\n\ncontext LoyaltyProgram::getServices(pp:ProgramPartner) : Set(Service)\nbody:\tif self.partners->includes(pp) then    \n    pp.deliveredServices    \n    else    \nSet{}    \n    endif\n\ncontext LoyaltyProgram::enrollAndCreateCustomer(n : String, \n  d: Date ) : Customer\npost:\t((result.oclIsNew() and result.name = n) and result.dateOfBirth = d) and self.participants->includes(result)\npre constantlyTrue:\ttrue\n\ncontext LoyaltyProgram::enroll(c:Customer) : OclVoid\n--post:\tself.memberships->select( m : Membership | m.participants = c )->forAll( i_Membership : Membership | i_Membership.account.asSet()->notEmpty() and i_Membership.account.points = 0 )\npost:\tself.participants = self.participants->including(c)\npost:\tself.participants = self.participants->including(c)\npre:\tc.name <> ''\npre:\tc.name <> ''\npre:\tnot self.participants->includes(c)\npost:\tself.participants = self.participants->including(c)\npost:\tself.participants = self.participants->including(c)\npre:\tnot self.participants->includes(c)\n\n--context LoyaltyProgram::addTransaction(accNr: Integer, pName: String, servId: Integer, \n--\t\t\t\t\t\t\t\t\t    amnt: Real, d: Date) : OclVoid\n--post:\tlet acc : LoyaltyAccount = self.memberships->collect( i_Membership : Membership | i_Membership.account )->select( a : LoyaltyAccount | a.number = accNr )->any( i_LoyaltyAccount : LoyaltyAccount | true ) in let newT : Transaction = self.partners->select( p : ProgramPartner | p.name = pName )->collect( i_ProgramPartner : ProgramPartner | i_ProgramPartner.deliveredServices )->select( s : Service | s.serviceNr = servId )->collect( i_Service : Service | i_Service.transactions )->select( i_Transaction : Transaction | (i_Transaction.date = d) and i_Transaction.amount = amnt )->any( i_Transaction : Transaction | true ) in let card : CustomerCard = self.memberships->select( m : Membership | m.account.number = accNr )->collect( i_Membership : Membership | i_Membership.card )->any( i_CustomerCard : CustomerCard | true ) in acc.points = acc.points + newT.points\n\ncontext LoyaltyProgram::getServices() : Set(Service)\nbody:\tself.partners->collect( i_ProgramPartner : ProgramPartner | i_ProgramPartner.deliveredServices )->asSet()\n\n\nendpackage"
    },
    {
      "name": "epcAosDrctDbtTxInfUltmtCdtr",
      "text": "The requirements are as follows: In the context of Direct Debit Transaction Information, there are checks for ultimate creditor's postal address and country of residence. One condition is that the ultimate creditor field itself may not be defined at all. Alternatively, if it is defined, neither the postal address nor the country of residence of the ultimate creditor should be populated. It should be noted that these elements are only for AOS community, and instructed banks that are not part of this community may reject messages containing these elements. This requirement is based on section 1.2 of the SEPA B2B Direct Debit C2B Implementation Guidelines.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* Warning: The elements PstlAdr and CtryOfRes in DrctDbtTxInf UltmtCdtr are AOS only. Instructed banks\n   that are not in the AOS community may reject messages containing these elements.\n   Ref section 1.2 if the SEPA B2B Direct Debit C2B Implementation Guidelines. */\n\ncontext DirectDebitTransactionInformation1\ninv EPC_AOS_DrctDbtTxInfUltmtCdtr:\nultmtCdtr.oclIsUndefined() \nor \n(ultmtCdtr.pstlAdr->size() = 0 \nand\nultmtCdtr.ctryOfRes->size() = 0)\n\nendpackage"
    },
    {
      "name": "Account",
      "text": "The requirements are as follows:\n\nThe \"debit\" operation needs to be performed on an \"Account\". The \"debit\" operation takes in one input, namely the \"amount\", which is a floating point number. There is a constraint on \"amount\", which specifies that \"amount\" has to be greater than 0. After the execution of the \"debit\" operation, the \"balance\" of the account is expected to be equal to the original \"balance\" (before the execution of the \"debit\" operation) subtracted by the \"amount\".",
      "label": "context Account::debit(in amount: float)\npre: amount > 0\npost: balance = balance@pre - amount"
    },
    {
      "name": "Basic-UnSat-OCL-10",
      "text": "The requirements are as follows:\n1. For all instances of A2, the attribute 'at' should always be greater than the 'at' attribute of its associated A1 instance.\n2. For all instances of A3, the attribute 'at' should always be greater than the 'at' attribute of its associated A2 instance.\n3. For all instances of A4, the attribute 'at' should always be greater than the 'at' attribute of its associated A3 instance.\n4. For all instances of A5, the attribute 'at' should always be greater than the 'at' attribute of its associated A4 instance.\n5. For all instances of A6, the attribute 'at' should always be greater than the 'at' attribute of its associated A5 instance.\n6. For all instances of A7, the attribute 'at' should always be greater than the 'at' attribute of its associated A6 instance.\n7. For all instances of A8, the attribute 'at' should always be greater than the 'at' attribute of its associated A7 instance.\n8. For all instances of A9, the attribute 'at' should always be greater than the 'at' attribute of its associated A8 instance.\n9. For all instances of A10, the attribute 'at' should always be greater than the 'at' attribute of its associated A9 instance.\n10. For all instances of A1, the attribute 'at' should always be equal or greater than the 'at' attribute of its associated A10 instance.",
      "label": "package Package_1\ncontext A2 inv: A2::allInstances()->forAll(a|a.at>a.a1.at)\nendpackage\npackage Package_1\ncontext A3 inv: A3::allInstances()->forAll(a|a.at>a.a2.at)\nendpackage\npackage Package_1\ncontext A4 inv: A4::allInstances()->forAll(a|a.at>a.a3.at)\nendpackage\npackage Package_1\ncontext A5 inv: A5::allInstances()->forAll(a|a.at>a.a4.at)\nendpackage\npackage Package_1\ncontext A6 inv: A6::allInstances()->forAll(a|a.at>a.a5.at)\nendpackage\npackage Package_1\ncontext A7 inv: A7::allInstances()->forAll(a|a.at>a.a6.at)\nendpackage\npackage Package_1\ncontext A8 inv: A8::allInstances()->forAll(a|a.at>a.a7.at)\nendpackage\npackage Package_1\ncontext A9 inv: A9::allInstances()->forAll(a|a.at>a.a8.at)\nendpackage\npackage Package_1\ncontext A10 inv: A10::allInstances()->forAll(a|a.at>a.a9.at)\nendpackage\npackage Package_1\ncontext A1 inv: A1::allInstances()->forAll(a|a.at>=a.a10.at)\nendpackage"
    },
    {
      "name": "epcAosChrgsAcctAgt",
      "text": "The requirement is as follows: In the context of PaymentInstructionInformation2 in the package ISOStdIso20022TechXsdPain00800101, there should be no charges account agent (ChrgsAcctAgt) present. This is due to a warning that only those in the AOS community can have ChrgsAcctAgt within their payment information. Instructed banks that are not part of the AOS community might reject messages containing these elements. Please refer to section 1.2 of the SEPA B2B Direct Debit C2B Implementation Guidelines for more information.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* Warning: The element ChrgsAcctAgt in PmtInf is AOS only. Instructed banks that are not in the AOS\n   community may reject messages containing these elements.\n   Ref section 1.2 if the SEPA B2B Direct Debit C2B Implementation Guidelines. */\n\ncontext PaymentInstructionInformation2\ninv EPC_AOS_ChrgsAcctAgt:\nchrgsAcctAgt->size() = 0\n\nendpackage"
    },
    {
      "name": "Basic-Sat-OCL-2",
      "text": "The requirements are as follows:\n\nIn package \"Package_1\", for every instance of \"A2\", the attribute \"at\" of the \"A2\" instance must be greater than or equal to the attribute \"at\" of the associated \"A1\" instance.\n\nIn the same package \"Package_1\", for every instance of \"A1\", the attribute \"at\" of the \"A1\" instance must be greater than or equal to the attribute \"at\" of the associated \"A2\" instance.",
      "label": "package Package_1\ncontext A2 inv: A2::allInstances()->forAll(a|a.at>=a.a1.at)\nendpackage\npackage Package_1\ncontext A1 inv: A1::allInstances()->forAll(a|a.at>=a.a2.at)\nendpackage"
    },
    {
      "name": "epcAosCdtr",
      "text": "The requirements are as follows:\n\nIn the context of PaymentInstructionInformation2 in the isoStdIso20022TechXsdPain00800101 package, there are constraints that need to be validated. The creditor (cdtr) should not contain any address type (adrTp), street name (strtNm), building number (bldgNb), postal code (pstCd), town name (twnNm), country subdivision (ctrySubDvsn), identification (ID) and country of residence (ctryOfRes) which are only applicable for AOS (Account Owner Statement) community. Any instructed banks that are not part of the AOS community may reject messages containing these elements. These constraints are made in reference to section 1.2 of the SEPA B2B Direct Debit C2B Implementation Guidelines.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* Warning: The elements PstlAdr AdrTp, PstlAdr StrtNm, PstlAdr BldgNb, PstlAdr PstCd, PstlAdr \n   TwnNm, PstlAdr CtrySubDvsn, Id and CtryOfRes in PmtInf Cdtr are AOS only. Instructed banks \n   that are not in the AOS community may reject messages containing these elements.\n   Ref section 1.2 if the SEPA B2B Direct Debit C2B Implementation Guidelines. */\n\ncontext PaymentInstructionInformation2\ninv EPC_AOS_Cdtr:\ncdtr.pstlAdr.adrTp->size() = 0 \nand \ncdtr.pstlAdr.strtNm->size() = 0 \nand \ncdtr.pstlAdr.bldgNb->size() = 0 \nand \ncdtr.pstlAdr.pstCd->size() = 0 \nand \ncdtr.pstlAdr.twnNm->size() = 0 \nand \ncdtr.pstlAdr.ctrySubDvsn->size() = 0 \nand \ncdtr.id->size() = 0 \nand \ncdtr.ctryOfRes->size() = 0\n\nendpackage"
    },
    {
      "name": "Papers-Researchers.uml",
      "text": "The requirement is as follows:\n\n1. All the authors of any student paper must have at least one author who is a student.\n\n2. At least one paper out of all papers must be a student paper. And the total number of student papers cannot exceed 4.\n\n3. The word count for all papers must be less than 10,000.\n\n4. No researcher can review their own submission.\n\n5. For all papers, their assigned referees must not include any students.",
      "label": "package model\n\ncontext Paper \ninv AuthorsOfStudentPaper: Paper::allInstances()->forAll(p|p.studentPaper = p.author->exists(x|x.isStudent))\n\ncontext Paper inv LimitsOnStudentPapers: \nPaper::allInstances()->exists(p|p.studentPaper) and Paper::allInstances()->select(p|p.studentPaper)->size() < 5\n\ncontext Paper\ninv PaperLength: Paper::allInstances()->forAll(p|p.wordCount < 10000)\n\ncontext Researcher\ninv NoSelfReviews: Researcher::allInstances()->forAll(r|r.submission->excludes(r.manuscript))\n\ncontext Paper \ninv NoStudentReviewers: Paper::allInstances()->forAll(p| p.referee->forAll(r| not r.isStudent))\n\n\nendpackage"
    },
    {
      "name": "epcDbtradrLine",
      "text": "The requirement is as follows:\n\nWithin the package 'isoStdIso20022TechXsdPain00800101' for the context 'DirectDebitTransactionInformation1', a constraint, 'EPC_DbtradrLine', is defined for 'dbtr.pstlAdr.adrLine', corresponding to debtor's postal address lines in a direct debit transaction. The logic states that if there exists at least one occurrence of the debtor's address line, then the maximum size of debtor's address lines allowed should be limited to two. In other words, the debtor's postal address can have a maximum of two address lines in a direct debit transaction. This is as per the SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3, referenced on row 3, page 13.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* Only two occurrences of adrLine are allowed for a debtor (drctDbtTxInf Dbtr pstlAdr adrLine).\n   See row 3 on pg 13 of SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3. */\n\ncontext DirectDebitTransactionInformation1\ninv EPC_DbtradrLine:\ndbtr.pstlAdr.adrLine->size() >0 implies dbtr.pstlAdr.adrLine->size() <= 2\n\nendpackage"
    },
    {
      "name": "epcUltimateccdtr",
      "text": "The requirements are as follows: In the context of \"PaymentInstructionInformation2\", if the size of \"ultmtCdtr\", namely the ultimate creditor field in the Payment Information, is greater than 0, it means this field is populated, thus it should not be included in the Direct Debit Transaction Information. Consequently, every 'drctDbtTxInf' - which stands for Direct Debit Transaction Information, must have an 'ultmtCdtr', ultimate creditor field, size of 0, meaning it should not be populated.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* The ultimate creditor field is included in the Payment Information, it should not be included \n   in the Direct Debit Transaction Information. \n   See row 3 pg 9 of SEPA B2B Direct Debit C2B Implementation Guidelines. */\n\ncontext PaymentInstructionInformation2\ninv EPC_Ultimatecdtr:\nself.ultmtCdtr->size() > 0 implies self.drctDbtTxInf->forAll(a | a.ultmtCdtr->size() = 0)\n\nendpackage"
    },
    {
      "name": "eShop.uml.SAT",
      "text": "The requirements are as follows:\n\n1. For every Product instance in the system, the stock must be greater than or equal to 5.\n\n2. A customer can be removed from the Gold Category in the Portal only if he is a Gold Customer and he has no sales activities. After the operation, the customer should not be a gold customer anymore.\n\n3. A new customer can be created in the system with a name and portal attribute. The creation operation doesn't have a pre-condition. After the operation, the new customer instance must be new, the name attribute of the new instance is equal to the name input given, and the portal attribute of the new instance is equal to the portal input given.\n\n4. A sale line can be added to a sale given a product and a quantity. Before the operation, the product stock must be greater than 0. After the operation, the new sale line instance must be new, the sale attribute of the new instance is equal to the sale instance where the operation happened, the product attribute of the new instance is equal to the product input given, the quantity attribute of the new instance is equal to the quantity input given, the product's stock must decrease by the quantity, and the total amount of the sale must increase by the quantity times the price of the product.",
      "label": "package eShop\n\ncontext Product inv minStock: Product::allInstances()->forAll(p|p.stock>=5)\n\nendpackage\n\npackage eShop\n\ncontext Portal::removeGoldCategory(c:Customer):\n\tpre: c.oclIsTypeOf(GoldCustomer) and c.sale->isEmpty()\n\tpost: not c.oclIsTypeOf(GoldCustomer)\n\ncontext Customer::newCustomer(name:Integer, p:Portal):Customer\n    pre: true\n    post: result.oclIsNew() and result.name=name and result.portal=p\n\ncontext Sale::addSaleLine(p:Product, quantity:Integer):SaleLine\n   pre: p.stock > 0\n   post: result.oclIsNew() and result.sale=self and result.product=p and result.quantity=quantity and\n\tp.stock=p.stock@pre-quantity and self.amount=self.amount@pre + quantity*p.price\n\nendpackage"
    },
    {
      "name": "epcSvcLvl",
      "text": "The requirement is as follows: In the context of the Payment Type Information in isoStdIso20022TechXsdPain00800101 package, the Service Level (PmtInf SvcLvl) must be present and cannot be empty. This is according to row 6, section 2.1.3, on page 7 of the SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3. Essentially, the size of 'svcLvl' should be more than zero.",
      "label": "-- @model{../../model/pain.008.001.01corrected.xsd}\npackage isoStdIso20022TechXsdPain00800101\n\n/* Service Level (PmtInf SvcLvl) is mandatory. \n   See row 6, section 2.1.3, pg 7 of SEPA B2B Direct Debit C2B Implementation Guidelines Version 1.3. */\n\ncontext PaymentTypeInformation2\ninv EPC_SvcLvl:\nself.svcLvl->size() > 0\n\nendpackage"
    }
  ]
}