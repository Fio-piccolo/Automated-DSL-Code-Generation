{
  "examples": [
    {
      "name": "AnalysisIndividualExample",
      "text": "系统应支持对车辆及其相关组件进行建模，并能够进行燃油经济性分析。首先，系统定义了车辆数量和相关单位，例如每加仑距离单位（mpg）和马力（hp）。这些单位和数量用于描述和量化车辆的功率和燃油效率。\n\n在车辆模型中，车辆和引擎是核心部分，车辆拥有一个功率属性，指向引擎的峰值功率。引擎还包括一个燃油效率属性，以量化燃料的使用效率。\n\n系统提供了一个燃油经济性分析模型，通过定义一个燃油消耗操作来计算车辆在给定功率下的燃油经济性。该操作接收功率值作为输入，并返回一个表示每单位距离消耗的燃料的量度（单位为距离每单位体积）。\n\n燃油经济性分析通过引用车辆和燃油消耗操作来计算一个具体的燃油经济性数值。该分析结果能够反映不同车辆和引擎配置下的燃油效率。\n\n在个体分析模型中，系统支持对单个车辆进行个体化分析，指定特定的车辆和引擎配置。例如，可以为一个特定的车辆配置设置峰值功率和燃油效率，然后通过燃油消耗操作计算该配置下的燃油经济性。分析结果包括每单位燃料消耗的距离（如每加仑多少英里），进一步帮助评估车辆的燃油性能。\n\n总的来说，系统能够灵活地支持车辆、引擎和燃油经济性分析的建模，并允许对个体化车辆进行详细分析，以便评估其燃油效率和性能。",
      "label": "AnalysisIndividualExamplepackage AnalysisIndividualExample {\n    private import ScalarValues::*;\n    private import Quantities::*;\n    private import ISQ::*;\n    private import USCustomaryUnits::*;\n    \n\tpackage VehicleQuantities {\n\t    private import MeasurementReferences::*;\n\t    \n\t    attribute def DistancePerVolumeUnit :> DerivedUnit {\n\t    \tprivate attribute distancePF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = 1; }\n\t        private attribute volumePF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = -3; }\n\t        attribute :>> quantityDimension { :>> quantityPowerFactors = (distancePF, volumePF); }\n\t    }\n\n\t    attribute def DistancePerVolumeValue :> ScalarQuantityValue {\n\t        :>> num : Real;\n\t        :>> mRef : DistancePerVolumeUnit;\n\t    }\n\t    \n\t    attribute gallon : VolumeUnit = 231.0 * 'in' ** 3;\n\t    attribute mpg : DistancePerVolumeUnit = 'mi' / gallon;\n\t    attribute hp : PowerUnit = 745.7[SI::W];\n\t}\n\t\n\tpackage VehicleModel {\n\t    public import VehicleQuantities::*;\n\t    \n\t    part def Vehicle {\n\t    \tattribute power :> ISQ::power;\n\t    }\n\t    \n\t    part def Engine {\n\t    \tattribute peakPower :> ISQ::power;\n\t    \tattribute fuelEfficiency : Real;\n\t    }\n\t    \n\t    part vehicle_c1 : Vehicle {\n\t    \tattribute :>> power = engine.peakPower;\n\t    \tpart engine : Engine[1];\n\t    }\n\t}\n\t\n\tpackage FuelEconomyAnalysisModel {\n\t    private import VehicleModel::*;\n\t    private import SequenceFunctions::size;\n\t    private import SampledFunctions::SampledFunction;\n\t    private import SampledFunctions::SamplePair;\n\t    private import ControlFunctions::forAll;\n\t    \n\t    action def FuelConsumption {\n\t\t\tin power : PowerValue[*];\n\t\t\tout fuelEconomy : DistancePerVolumeValue;\n\t\t}\n\t\t\n\t\tanalysis def FuelEconomyAnalysis {\n\t\t\tsubject vehicle: Vehicle;\n\n\t\t    action fuelConsumption : FuelConsumption {\n\t\t    \tin power = vehicle.power;\n\t\t        out fuelEconomy : DistancePerVolumeValue;\n\t        }\n\t        \n\t\t\treturn calculatedFuelEconomy : DistancePerVolumeValue =\n\t\t\t\tfuelConsumption.fuelEconomy;\t        \n\t    }\n\t}\n\t\n\tpackage IndividualAnalysisModel {\n\t\tprivate import VehicleModel::*;\n\t\tprivate import FuelEconomyAnalysisModel::*;\n\t\t\n\t\tindividual part def Vehicle_1 :> Vehicle;\n\t\tindividual part def Engine_1 :> Engine;\n\t\t\n\t\tindividual analysis def FuelEconomyAnalysis_1 :> FuelEconomyAnalysis;\n\t\tindividual action def FuelConsumption_1 :> FuelConsumption;\n\t\t\n\t\tindividual analysis fuelEconomyAnalysis_1 : FuelEconomyAnalysis_1 {\n\t\t\tsubject vehicle : Vehicle_1 :> vehicle_c1 {\n\t\t\t\tindividual part :>> engine : Engine_1 {\n\t\t\t\t\tattribute :>> peakPower = 200[hp];\n\t\t\t\t\tattribute :>> fuelEfficiency = 0.4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindividual action :>> fuelConsumption : FuelEconomyAnalysis_1 {\n\t\t\t\tsnapshot :>> done :> fuelConsumption {\n\t\t\t\t\tout :>> fuelEconomy = 35[mph];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
    },
    {
      "name": "JohnIndividualExample",
      "text": "系统应支持定义个人和国家之间的关系，特别是管理一个国家的总统以及其任期。模型中定义了`Person`类，表示一个具有年龄属性的个体。每个`Person`可以有一个或多个任期（`timeslice`），这些任期表示其作为总统的时期。\n\n系统定义了`John`作为`Person`的一个具体实例，并且指定了他作为美国总统的时间段。`Country`类定义了国家的基本结构，其中每个国家最多可以有一个总统。具体来说，`UnitedStates`类作为`Country`的实例，表示美国，并且通过约束条件确保美国的总统年龄至少为35岁。\n\n在`UnitedStates`类中，进一步定义了一个`timeslice`，表示美国在特定时间段内由`John`担任总统。通过这种方式，系统能够明确记录并验证每个总统的任期，并确保相关的约束条件（如总统年龄）得到遵守。",
      "label": "package JohnIndividualExample {\n\t\n\titem def Person {\n\t\tdoc\t\n\t\t/*\n\t\t * This is the definition of the class of persons, each of whom has an age.\n\t\t */\n\n\t\tattribute age : ScalarValues::Natural;\t\t\n\t\t\n\t\ttimeslice asPresident : Person [0..*] {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * These are the periods during which a Person is president.\n\t\t\t */\n\t\t}\n\t}\n\t\n\tindividual item def John :> Person {\n\t\tdoc\n\t\t/*\n\t\t * This the definition of the individual Person who is John.\n\t\t * There is at most one such person.\n\t\t */\n\t}\n\t\n\titem def Country {\n\t\tdoc\n\t\t/*\n\t\t * This is the definition of the class of countries, each of which may have \n\t\t * at most one president (at any point in time).\n\t\t */\n\t\tref presidentOfCountry[0..1] : Person :> presidentOfCountry.asPresident;\n\t}\n\t\n\tindividual item def UnitedStates :> Country {\n\t\tdoc\n\t\t/*\n\t\t * This is the definition of the individual country that is the\n\t\t * United States. It contains a single instance. The United States\n\t\t * always has a president who must be at least 35 years old.\n\t\t */\n\t\t \n\t\tref presidentOfUS[1] :>> presidentOfCountry {\n\t   \t\tassert constraint { age >= 35 } \n\t  \t}\n\t}\n\t\n\ttimeslice item UnitedStatesWithJohnAsPresident[*] : UnitedStates {\n\t\tdoc\n\t\t/*\n\t\t * These are the time slices of the United States during\n\t\t * which John is president of the United States.\n\t\t */\n\t\tref :>> presidentOfUS : John;\n\t}\n}"
    },
    {
      "name": "EVSample",
      "text": "系统应能够定义和管理电动汽车的各个部件，并支持基于不同要求进行性能分析。每辆车应具备质量、输入、输出、状态等基本信息。车辆输入应包括外力，输出应涉及加速度、速度和行驶距离等数据，车辆状态应反映当前的速度和距离。\n\n每辆电池应包括基础电压、初始电量、容量和内部电阻等属性，并且定义电池的输入、输出和状态信息。电池的输入应包括电流，输出应涉及电压，电池状态应包含电量的剩余百分比。\n\n电动机应具备转矩与电流的关系、阻抗、电感等参数，并提供电压、摩擦力等输入，输出则包括电流和转矩。电动机的状态应记录电流的变化。\n\n轮胎应包括半径、惯性矩等属性，并支持输入如转矩和加速度，输出包括力和转矩。轮胎的行为与车辆的行为和电动机的转矩密切相关。\n\n系统应支持对车辆的需求进行管理，如电动汽车的续航里程、效率和最大速度要求等。对于每个需求，系统应进行分析并返回模拟结果，以确保车辆满足规定的性能标准。例如，系统应分析车辆是否能够达到所要求的最大续航里程、能效以及最大速度。\n\n此外，系统还应支持针对不同类型电动汽车（如小型电动汽车和大型电动汽车）的定制要求和分析。每种类型的车辆都有特定的质量、轮胎尺寸和性能要求，系统应根据这些要求进行相应的分析，确保车辆满足不同的使用条件和法规要求。\n\n总之，系统应能够提供详细的电动汽车分析功能，包括续航能力、能效和速度等方面的模拟与评估，确保电动汽车能够在符合要求的条件下运行。",
      "label": "// State Space Representation EV example\npackage EVSample {\n    private import SI::*;\n    private import StateSpaceRepresentation::*;\n\n    attribute <'A⋅h'> 'ampere hour'  : ElectricChargeUnit = A*h;\n\n    part def Vehicle {\n        attribute mass :> ISQ::mass;\n\n        attribute def VehicleInput :> Input {\n            attribute force :> ISQ::force;\n        }\n\n        attribute def VehicleOutput :> Output {\n            attribute accel :> ISQ::acceleration;\n            attribute velocity :> ISQ::speed;\n            attribute distance :> ISQ::distance;\n        }\n\n        attribute def VehicleState :> StateSpace {\n            attribute velocity :> ISQ::speed;\n            attribute distance :> ISQ::distance;\n        }\n    }\n\n    part def Battery {\n        attribute baseVoltage :> ISQ::electricPotential;\n        attribute socInit: ScalarValues::Real;\n        attribute capacity :> ISQ::electricCharge;\n        attribute internalResistance :> ISQ::resistance;\n\n        attribute def BatteryInput :> Input {\n            attribute current :> ISQ::electricCurrent;\n        }\n\n        attribute def BatteryOutput :> Output {\n            attribute voltage :> ISQ::electricPotential;\n        }\n\n        attribute def BatteryState :> StateSpace {\n            attribute soc: ScalarValues::Real;\n        }\n\n    }\n\n    part def Motor {\n        torquePerCurrent :> Quantities::scalarQuantities = ISQ::torque / ISQ::electricCurrent;\n\n        attribute motR :> ISQ::resistance;\n        attribute motL :> ISQ::inductance;\n\n        attribute def MotorInput :> Input {\n            attribute voltage :> ISQ::electricPotential;\n            attribute friction :> ISQ::torque;\n        }\n\n        attribute def MotorOutput :> Output {\n            attribute current :> ISQ::electricCurrent;\n            attribute torque :> ISQ::torque;\n        }\n\n        attribute def MotorState :> StateSpace {\n            attribute current :> ISQ::electricCurrent;\n        }\n    }\n\n    part def Tire {\n        attribute radius :> ISQ::length;\n        attribute moment :> ISQ::momentOfInertia;\n\n        attribute def TireInput :> Input {\n            attribute torque :> ISQ::torque;\n            attribute accel :> ISQ::acceleration;\n        }\n\n        attribute def TireOutput :> Output {\n            attribute force :> ISQ::force;\n            attribute outTorque :> ISQ::torque;\n        }\n    }\n\n    requirement def VehicleRequirement {\n        in vehicle : Vehicle;\n    }\n\n    analysis def VehicleAnalysis {\n        subject vehicle : Vehicle;\n        requirement vehicleRequirement : VehicleRequirement;\n    }\n\n\n    requirement def RangeRequirement :> VehicleRequirement {\n        doc /* The range of EV must be longer than the required spec under the flat road. */\n        attribute actualRange : LengthValue;\n        attribute requiredRange : LengthValue;\n\n        require constraint { actualRange >= requiredRange }\n    }\n\n    analysis def RangeAnalysis :> VehicleAnalysis {\n    \treturn simulatedRange : LengthValue;\n    \t\n        requirement rangeRequirement :>> vehicleRequirement : RangeRequirement;\n\n        objective rangeAnalysisObjective {\n            doc /* This analysis is to estimate the range of\n                 * the EV by simulating the vehicle driving under the compact vehicle regulation.\n                 */\n            require rangeRequirement {\n                :>> actualRange = simulatedRange;\n            }\n        }\n    }\n\n    requirement def EfficiencyRequirement :> VehicleRequirement {\n        doc /* The efficiency of EV must be better than the required spec. */\n        attribute actualEfficiency;\n        attribute requiredEfficiency;\n\n        require constraint { actualEfficiency >= requiredEfficiency }\n    }\n\n    analysis def EfficiencyAnalysis :> VehicleAnalysis {\n    \treturn simulatedEfficiency;\n    \t\n        requirement efficiencyRequirement :>> vehicleRequirement : EfficiencyRequirement;\n\n        objective efficiencyAnalysisObjective {\n            require efficiencyRequirement {\n                attribute :>> actualEfficiency = simulatedEfficiency;\n            }\n        }\n    }\n\n    requirement def MaxSpeedRequirement :> VehicleRequirement {\n        doc /* The maximum speed of EV must be larger than the required spec. */\n        attribute actualMaxSpeed :> ISQ::speed;\n        attribute requiredMaxSpeed :> ISQ::speed;\n    }\n\n    analysis def MaxSpeedAnalysis :> VehicleAnalysis {\n    \treturn simulatedMaxSpeed;\n    \t\n        requirement maxSpeedRequirement :>> vehicleRequirement : MaxSpeedRequirement;\n\n        objective maxSpeedAnalysisObjective {\n            require maxSpeedRequirement {\n                attribute :>> actualMaxSpeed = simulatedMaxSpeed;\n            }\n        }\n    }\n\n\n    part vehicle : Vehicle {\n        attribute :>> mass default 1000[kg];\n\n        /* airFrictionCoefficient [kg / m] = 1/2 * rho[kg/m^3] * Cd * S[m^2],\n         * where rho is air density, S is front projected area. */\n        attribute airFrictionCoefficient = 0.2;\n\n        attribute efficiency;\n\n        action vehicleBehavior : ContinuousStateSpaceDynamics {\n            in input : VehicleInput;\n            out output : VehicleOutput;\n            :>> stateSpace : VehicleState;\n        }\n        \n        part battery: Battery {\n            :>> baseVoltage = 300[V];\n            :>> capacity = 50['A⋅h'];\n            :>> socInit = 0.8;\n            :>> internalResistance = 1.8['Ω'];\n            action batteryBehavior : ContinuousStateSpaceDynamics {\n                in input : BatteryInput;\n                out output : BatteryOutput;\n                :>> stateSpace : BatteryState;\n            }\n        }\n\n        flow battery.batteryBehavior.output.voltage to motor.motorBehavior.input.voltage;\n        flow motor.motorBehavior.output.current to battery.batteryBehavior.input.current;\n\n        part motor: Motor {\n            :>> motR = 4['Ω'];\n            :>> motL = 0.2[H];\n\n            action motorBehavior : ContinuousStateSpaceDynamics {\n                in input : MotorInput;\n                out output : MotorOutput;\n                :>> stateSpace : MotorState;\n            }\n        }\n\n        flow motor.motorBehavior.output.torque to tire.tireBehavior.input.torque;\n        flow vehicleBehavior.output.accel to tire.tireBehavior.input.accel;\n\n        part tire: Tire {\n            :>> moment default 300['kg⋅m²'];\n            :>> radius default 0.7[m];\n            action tireBehavior : ContinuousStateSpaceDynamics {\n                in input : TireInput;\n                out output : TireOutput;\n            }\n        }\n\n        flow tire.tireBehavior.output.outTorque to motor.motorBehavior.input.friction;\n        flow tire.tireBehavior.output.force to vehicleBehavior.input.force;\n    }\n\n    part vehicle_compact :> vehicle {\n        attribute :>> mass = 800[kg];\n        part :>> tire {\n            :>> moment = 200['kg⋅m²'];\n            :>> radius = 0.5[m];\n        }\n    }\n\n    part smallEVRangeContext {\n        requirement smallEVRequirement : VehicleRequirement {\n            doc /* The small EVs must be ligher than 900[kg] */\n            in :>> vehicle = vehicle_compact;\n            /*  To comform with the regulation and the battery mass will impact it. */\n            assume constraint { vehicle.mass < 900[kg] }\n        }\n\n        analysis smallEVAnalysis : VehicleAnalysis {\n            subject :>> vehicle :> vehicle_compact;\n            requirement :>> vehicleRequirement = smallEVRequirement;\n        }\n\n        requirement <C1> rangeRequirementSmall :> smallEVRequirement : RangeRequirement {\n            doc /* The small EVs must run longer than 130km */\n            attribute :>> requiredRange = 130[km];\n        }\n\n        analysis rangeAnalysisSmall :> smallEVAnalysis : RangeAnalysis {\n            requirement :>> rangeRequirement = rangeRequirementSmall;\n            return simulatedRange = vehicle.vehicleBehavior.output.distance;\n        }\n\n        requirement <C2> efficiencyRequirementSmall :> smallEVRequirement : EfficiencyRequirement {\n            doc /* The target efficiency of small EVs is 0.9. */\n            attribute :>> requiredEfficiency = 0.9;\n        }\n\n        analysis efficiencyAnalysisSmall :> smallEVAnalysis : EfficiencyAnalysis {\n            requirement :>> efficiencyRequirement = efficiencyRequirementSmall;\n\n            return simulatedEfficiency = vehicle.efficiency;\n        }\n\n        requirement <C3> maxSpeedRequirementSmall :> smallEVRequirement : MaxSpeedRequirement {\n            doc /* The target maximum speed of small EVs is 130 [km/h]. */\n            attribute :>> requiredMaxSpeed = 130 [km/h];\n        }\n\n        analysis maxSpeedAnalysisSmall :> smallEVAnalysis : MaxSpeedAnalysis {\n            requirement :>> maxSpeedRequirement = maxSpeedRequirementSmall;\n            out voltage :> ISQ::electricPotential = vehicle.battery.batteryBehavior.output.voltage;\n            return simulatedMaxSpeed = vehicle.vehicleBehavior.output.velocity;\n        }\n    }\n\n    part vehicle_large :> vehicle {\n        attribute :>> mass = 1100[kg];\n        part :>> tire {\n            :>> moment = 300['kg⋅m²'];\n            :>> radius = 0.7[m];\n        }\n    }\n\n    part largeEVRangeContext {\n        requirement largeEVRequirement : VehicleRequirement {\n            doc /* The large EVs must be ligher than 900[kg] */\n            in :>> vehicle = vehicle_large;\n            /*  To comform with the regulation and the battery mass will impact it. */\n            assume constraint { vehicle.mass < 1200[kg] }\n        }\n\n        analysis largeEVAnalysis : VehicleAnalysis {\n            subject :>> vehicle :> vehicle_large;\n            requirement :>> vehicleRequirement = largeEVRequirement;\n        }\n\n        requirement <L1> rangeRequirementLarge :> largeEVRequirement : RangeRequirement {\n            doc /* The large EVs must run longer than 200km */\n            attribute :>> requiredRange = 200[km];\n        }\n\n        analysis rangeAnalysisLarge :> largeEVAnalysis : RangeAnalysis {\n            requirement :>> rangeRequirement = rangeRequirementLarge;\n            return simulatedRange = vehicle.vehicleBehavior.output.distance;\n        }\n\n        requirement <L2> efficiencyRequirementLarge :> largeEVRequirement : EfficiencyRequirement {\n            doc /* The target efficiency of large EVs is 0.8. */\n            attribute :>> requiredEfficiency = 0.8;\n        }\n\n        analysis efficiencyAnalysisLarge :> largeEVAnalysis : EfficiencyAnalysis {\n            requirement :>> efficiencyRequirement = efficiencyRequirementLarge;\n\n            return simulatedEfficiency = vehicle.efficiency;\n        }\n\n        requirement <L3> maxSpeedRequirementLarge :> largeEVRequirement : MaxSpeedRequirement {\n            doc /* The target maximum speed of large EVs is 140 [km/h]. */\n            attribute :>> requiredMaxSpeed = 140 [km/h];\n        }\n\n        analysis maxSpeedAnalysisLarge :> largeEVAnalysis : MaxSpeedAnalysis {\n            requirement :>> maxSpeedRequirement = maxSpeedRequirementLarge;\n            out voltage = vehicle.battery.batteryBehavior.output.voltage;\n            return simulatedMaxSpeed = vehicle.vehicleBehavior.output.velocity;\n        }\n    }\n}"
    },
    {
      "name": "CartSample",
      "text": "系统需要支持对一个简单的动态模型（如小车与推力器系统）进行状态空间表示，并且能够通过输入、输出和状态推导进行连续状态空间动态计算。\n\n在此系统中，\"小车\"（Cart）作为主要的部件，其质量、输入力和输出速度与系统状态相互关联。每个小车实例应具有以下几个属性：\n- 质量（mass）作为小车的基本物理属性。\n- 输入（CartInput），其中包括施加在小车上的力（force）。\n- 输出（CartOutput），小车的速度（velocity）。\n- 状态（CartState），用来表示小车的状态空间，这里仅考虑速度（velocity）作为状态。\n- 状态导数（CartStateDerivative），用于表示小车状态随时间的变化，计算加速度（accel）并基于输入力与质量之间的关系来推导。\n\n\"推力器\"（Pusher）作为辅助部件，主要作用是为小车提供外力。推力器的输出（PusherOutput）是施加在小车上的力（force）。\n\n系统应能够基于小车的状态空间动态模型来计算状态和输出：\n- 小车的行为（cartBehavior）需要定义输入（CartInput）、输出（CartOutput）以及状态空间（CartState）。根据输入的力和当前状态（速度），系统需要计算小车的状态导数（即加速度），并根据当前状态计算小车的输出（即速度）。\n- 推力器的行为（pusherBehavior）应该输出一个固定的力值（pusherForce），该力值将传递给小车的输入。\n\n系统还需要支持小车和推力器之间的流动关系（flow），即推力器输出的力（pusherForce）将作为输入（force）传递给小车的行为（cartBehavior），进而影响小车的运动状态。\n\n通过这一模型，系统能够对小车和推力器之间的相互作用进行动态仿真，计算出小车的速度变化和加速度，并通过调整输入的外力来控制小车的运动行为。",
      "label": "// State Space Representation cart example\n\npackage CartSample {\n    private import StateSpaceRepresentation::*;\n    part def Cart {\n        attribute mass :> ISQ::mass;\n\n        attribute def CartInput :> Input {\n            attribute force :> ISQ::force;\n        }\n\n        attribute def CartOutput :> Output {\n            attribute velocity :> ISQ::speed;\n        }\n\n        attribute def CartState :> StateSpace {\n            attribute velocity :> ISQ::speed;\n        }\n\n        attribute def CartStateDerivative :> StateDerivative {\n            ref :>> stateSpace : CartState;\n            attribute accel :> ISQ::acceleration;\n        }\n    }\n\n    part def Pusher {\n        attribute def PusherOutput :> Output {\n            attribute force :> ISQ::force;\n        }\n    }\n\n    part context {\n        part cart : Cart {\n            action cartBehavior : ContinuousStateSpaceDynamics {\n                in input : CartInput;\n                out output : CartOutput;\n                :>> stateSpace : CartState;\n\n                calc :>> getDerivative { \n                \tin input: CartInput; \n                \tin stateSpace: CartState;\n                    CartStateDerivative(input.force / mass)\n                }\n                calc :>> getOutput {\n                \tin :>> stateSpace : CartState;\n                    CartOutput(stateSpace.velocity)\n                }\n            }\n        }\n        part pusher : Pusher {\n            attribute pusherForce :> ISQ::force;\n\n            action pusherBehavior : ContinuousStateSpaceDynamics {\n                in input;\n                out output : PusherOutput;\n                calc :>> getOutput {\n                    PusherOutput(pusherForce)\n                }\n            }\n        }\n\n        flow pusher.pusherBehavior.output.force to cart.cartBehavior.input.force;\n    }\n}"
    },
    {
      "name": "CauseAndEffectExample",
      "text": "系统应支持在模型中定义多重因果关系，实现多个原因与多个结果之间的连接。系统中定义了两个触发者和两个被影响者，通过多重因果连接明确指定各个因果端点之间的对应关系。除此之外，系统允许对任意类型的元素（例如事件、项、部件和动作）建立因果连接，并分别标注为原因或结果。单个因果连接还可以附加元数据，用于描述因果关系的必要性以及发生的概率。通过这种方式，系统能够准确表达复杂的因果交互，确保模型中各个因果关系的清晰性与一致性。",
      "label": "package CauseAndEffectExample {\n\tprivate import CauseAndEffect::*;\n\t\n\tpart def Causer1;\n\tpart def Causer2;\n\tpart def Effected1;\n\tpart def Effected2;\n\t\n\t#multicausation connection def MultiCauseEffect {\n\t\tend #cause cause1 : Causer1;\n\t\tend #cause cause2 : Causer2;\n\t\tend #effect effect1 : Effected1;\n\t\tend #effect effect2 : Effected2;\n\t}\n\t\n\tpart causer1 : Causer1;\n\tpart causer2 : Causer2;\n\tpart effected1 : Effected1;\n\tpart effected2 : Effected2;\n\t\n\t#multicausation connection : MultiCauseEffect connect\n\t\t( cause1 ::> causer1, cause2 ::> causer2,\n\t\t  effect1 ::> effected1, effect2 ::> effected2 );\n\t\t  \n\t#multicausation connect\n\t\t( cause1 ::> causer1, cause2 ::> causer2,\n\t\t  effect1 ::> effected1, effect2 ::> effected2 );\n\n    occurrence a;\n    item b;\n    part c;\n    action d;\n    \n\t#multicausation connection {\n\t\tend #cause ::> a;\n\t\tend #cause ::> b;\n\t\tend #effect ::> c;\n\t\tend #effect ::> d;\n\t}\n\t\n\t#cause causeA ::> a;\n\t#cause causeB ::> b;\n\t#effect effectC ::> c;\n\t#effect effectD ::> d;\n\t\n\t#multicausation connect ( causeA, causeB, effectC, effectD );\n\t\n\t#causation connect a to c;\n\t#causation connect b to d {\n\t\t@CausationMetadata {\n\t\t\tisNecessary = true;\n\t\t\tprobability = 0.1;\n\t\t}\n\t}\n}"
    },
    {
      "name": "MedicalDeviceFailure",
      "text": "系统应支持对医疗设备失效场景进行因果关系建模。设备中包含一个电池，该电池可触发“耗尽”和“无法充电”两个事件，这两个事件共同作为原因引发设备失效。设备失效又直接导致患者治疗延迟，通过明确的因果连接将设备失效与患者治疗延迟关联，从而反映出多个原因和结果之间的关系。",
      "label": "package MedicalDeviceFailure {\n\tprivate import CauseAndEffect::*;\n\t\n\tpart medicalDevice {\n\t\tpart battery {\n\t\t\tevent occurrence depleted;\n\t\t\tevent occurrence cannotBeCharged;\n\t\t}\n\t\t\n\t\tevent occurrence deviceFails;\n\t\t\n\t\tref patient {\n\t\t\tevent occurrence therapyDelayed;\n\t\t}\n\t\t\n\t\t#multicausation connection {\n\t\t\tend #cause ::> battery.depleted;\n\t\t\tend #cause ::> battery.cannotBeCharged;\n\t\t\tend #effect ::> deviceFails;\n\t\t}\n\t\t\n\t\t#causation connect deviceFails to patient.therapyDelayed;\n\t}\t\n\t\n}"
    },
    {
      "name": "RoomModel",
      "text": "系统应能够定义一个建筑环境，其中包括多个房间以及它们之间的连接和流动。首先，系统应定义不同类型的房间，包括教室、储藏室和走廊。每个房间应具有与其他房间相连的入口和出口。例如，教室应有一个通向教室的入口，储藏室应有一个通向储藏室的入口，走廊应具有通向教室和储藏室的出口。\n\n系统还应能够定义这些房间之间的流动和交互。每个房间的入口和出口端口应能够传递不同类型的物品，如学生、教师、家具和空气。具体来说，走廊和教室之间应能够流动空气、家具、学生和教师；而走廊和储藏室之间应能够流动空气和家具。这些流动通过定义的端口进行连接，确保各个房间之间能够适当交换物品和资源。\n\n最后，系统应在特定的房间配置上下文中，展示这些房间及其流动的具体实现，包括连接的端口和物品流动的方式。这些流动的定义应确保房间之间的交互关系能够准确地反映实际的空间布局和物品流动需求。",
      "label": "// SysML v2 Interpretation of the SysML v1 Room Connection Example\npackage RoomModel { \n    package RoomDefinitionModelLibrary{\n        private import Port_Definitions::*;\n        private import Flow_Definitions::*;\n        package Part_Definitions{\n            // Rooms\n            part def Classroom {\n                port classEntry: EntryWay_to_Classroom;\n            }\n            part def Storageroom {\n                port storageEntry: EntryWay_to_Storageroom;\n            }\n            part def Hallway {\n                // conjugate ports with ~\n                port hallExit_to_Classroom: ~EntryWay_to_Classroom;\n                port hallExit_to_Storageroom: ~EntryWay_to_Storageroom;\n            }\n        }\n        package Port_Definitions{\n            port def EntryWay_to_Classroom {\n                //flow properties\n                in ref student:Student;\n                in ref teacher:Teacher;\n                in ref furniture:Furniture;\n                in ref air:Air;\n            }\n            port def EntryWay_to_Storageroom {\n                //flow properties\n                in ref furniture:  Furniture;\n                in ref air: Air;\n            }\n        }\n        package Flow_Definitions {\n                // Conveyed items between Hallway, Classroom, and Storageroom\n                part def Air;\n                part def Furniture;\n                part def Student;\n                part def Teacher;\n        }\n    }\n    package Room_Configuration{\n        // defining the parts and their interconnection in context \n        private import RoomDefinitionModelLibrary::*;\n        private import RoomDefinitionModelLibrary::Part_Definitions::*;\n        private import RoomDefinitionModelLibrary::Port_Definitions::*;\n        private import RoomDefinitionModelLibrary::Flow_Definitions::*;\n        part roomContext{\n            part c:Classroom;\n            part s:Storageroom;\n            part h:Hallway;\n            \n    \t\t//  Connectors and item flows between hallway and classroom\n            flow HallToClassroom_Air\n                from h.hallExit_to_Classroom.air\n                to c.classEntry.air;\n            flow HallToClassroom_Furniture\n                from h.hallExit_to_Classroom.furniture\n                to c.classEntry.furniture;\n            flow HallToClassroom_Student\n                from h.hallExit_to_Classroom.student\n                to c.classEntry.student;\n            flow HallToClassroom_Teacher\n                from h.hallExit_to_Classroom.teacher\n                to c.classEntry.teacher;\n            flow HallToStorageroom_Air\n                from h.hallExit_to_Storageroom.air\n                to s.storageEntry.air;\n            flow HallToStorageroom_Furniture\n                from h.hallExit_to_Storageroom.furniture\n                to s.storageEntry.furniture;\n        }\n    }\n}"
    },
    {
      "name": "AliasTest",
      "text": "系统应支持定义和管理别名，以便在模型中引用已有的元素，并提供更具可读性的命名方式。  \n\n系统应允许导入外部命名空间中的别名，并支持将属性与别名关联，以确保模型的灵活性和一致性。  \n\n系统应支持在部件定义中为端口创建别名，使得同一端口可以通过不同的名称被引用。别名应能够在实例化部件时被正确解析，并与原始端口建立关联。  \n\n系统应支持部件之间的连接关系，允许使用原始端口或端口别名进行连接，以确保通信链路的正确性。连接关系应支持通过别名建立端口之间的联系，使得系统能够灵活定义和管理端口交互。",
      "label": "package AliasTest {\n\tprivate import ISQSpaceTime::breadth; // import of an alias\n\tattribute b :> breadth;\n\t\n    part def P1 {\n        port porig1;\n        alias po1 for porig1;\n    }\n\n    part p1 : P1 {\n        port po1 :>> po1;\n    }\n\n    part p2 : P1 {\n        port pdest;\n        alias pd1 for pdest;\n    }\n\n\n    connect p1.po1 to p2.pdest;\n\tconnect p1.po1 to p2.pd1;\n}"
    },
    {
      "name": "OccurrenceTest",
      "text": "系统应支持定义事件或发生的时刻（`occurrence`），使得不同的事件或状态可以在模型中显式描述，并关联相关的属性、项、部分、快照和时间片等元素。  \n\n系统应允许事件或发生的时刻引用其他事件（通过 `ref` 关键字），并支持建立层级结构，其中一个事件可以包含或引用其他事件，从而形成复杂的时序关系。  \n\n系统应支持事件或发生的时刻拥有多个属性，并允许对事件的不同部分进行定义，确保模型能精确地表达事件的特征和行为。  \n\n系统应支持事件与个体（`individual`）的关联，允许个体在事件中使用快照和时间片等属性，以表示事件的特定状态或时间点。  \n\n系统应允许个体与事件组合，使得个体的状态可以在事件中被表达，并能通过快照和时间片来反映个体的状态变化。  \n\n系统应允许在事件中定义多个实例，并在事件之间创建引用和层次关系，以支持复杂的时序和结构建模。",
      "label": "package OccurrenceTest {\n\toccurrence def Occ {\n\t\tattribute a;\n\t\tref occurrence occ1 : Occ;\n\t\toccurrence occ2 : Occ;\n\t\titem x;\n\t\tpart y;\n\t\t\n\t\tindividual snapshot s : Ind;\n\t\ttimeslice t;\n\t}\n\t\n\toccurrence occ : Occ {\n\t\toccurrence o1 : Occ;\n\t\tref occurrence o2 : Occ;\n\t\titem z;\n\t}\n\n\tindividual occurrence def Ind {\n\t\tsnapshot s2;\n\t\ttimeslice t2;\n\t}\n\tindividual occurrence ind : Ind, Occ {\n\t\tsnapshot s3;\n\t\tindividual timeslice t3;\n\t}\n\t\n\tindividual snapshot s4 : Ind;\n\t\n\toccurrence o1 {\n\t  occurrence o2;\n\t}\n}"
    },
    {
      "name": "StateTest",
      "text": "系统应能够定义并管理多个状态和状态之间的转换。首先，系统应能够定义信号（Sig）和退出（Exit）的属性，并允许在各个状态中定义特定的动作。系统应支持在状态内定义多个子状态，并为每个子状态配置相关的接受条件、动作和状态转换。\n\n例如，在状态“S”中，系统应定义多个子状态，如“S1”和“S2”，并在这些状态之间建立转换关系。每个状态应能够接受信号（如Sig）并触发相应的动作。系统应允许在状态之间定义过渡条件，例如从“S1”到“S2”的转换，以及从“S2”到“S3”的转换。每个转换都应能够包含条件和行为，例如发送信号或执行动作。\n\n此外，系统应支持并行状态的定义，例如“s parallel”，其中多个状态可以并行执行，并且在其中定义的动作和条件应能够互相独立。\n\n系统还应支持继承和扩展状态。例如，状态“s5”应能够继承自状态“s4”，并在继承的基础上定义新的行为。通过这种方式，系统可以灵活地管理状态及其转换，确保符合不同的业务逻辑和需求。",
      "label": "package StateTest {\n\tattribute def Sig {\n\t\tx;\n\t}\n\tattribute def Exit;\n\t\n\tpart p;\n\t\n\taction act;\n\t\n\tstate def S {\n\t\tdo action A;\n\t\tentry; then S1;\n\t\t\n\t\tstate S1;\n\t\t\taccept s : Sig\n\t\t\tdo action D\n\t\t\tthen S2;\n\t\t\t\t\n\t\tstate S2 {\n\t\t\tdo send Sig(T.s.x) to p;\n\t\t\tstate S3;\n\t\t}\n\t\taccept Exit then done;\n\t\t\n\t\ttransition\n\t\t\tfirst S1\n\t\t\taccept s : Sig\n\t\t\tdo action D\n\t\t\tthen S2.S3;\n\t\t\n\t\ttransition T\n\t\t\tfirst S2.S3\n\t\t\taccept s : Sig via p\n\t\t\tif true\n\t\t\tdo send s to p\n\t\t\tthen S1;\n\t\t\t\n\t\texit act;\n\t}\n\t\n\tstate s parallel {\n\t\tstate s1;\n\t\tstate s2;\n\t}\n\t\n\tstate s4 {\n\t\tdo action a;\n  \t\taction c;\n\t}\n\t\n\tstate s5 :> s4 {\n  \t\tdo action b :>> c;\n\t}\n\t\n}"
    },
    {
      "name": "CalculationTest",
      "text": "系统应支持定义和管理车辆及其部件的质量属性，以便对车辆的总质量进行计算和分析。  \n\n系统应允许车辆继承通用的车辆部件属性，并支持为车辆定义特定的部件，如发动机和变速器，使其能够组成完整的车辆结构。  \n\n系统应支持定义计算逻辑，以便对多个部件的质量进行求和，并返回总质量，以确保系统能够准确计算整体质量。  \n\n系统应支持实例化多个车辆对象，并允许对这些车辆的质量属性进行批量访问和处理，以支持更大规模的计算和分析需求。",
      "label": "package CalculationExample {\n\tprivate import ISQ::*;\n\tprivate import NumericalFunctions::*;\n\t\n\tpart def VehiclePart {\n\t\tattribute m : MassValue;\n\t}\n\t\n\tpart def Vehicle :> VehiclePart;\n\t\n\tpart vehicle : Vehicle {\t\t\n\t\tpart eng : VehiclePart;\t\t\n\t\tpart trans : VehiclePart;\n\t\tattribute ::> m = ms.totalMass;\n\t}\n\t\n\tcalc def MassSum {\n\t\tin partMasses : MassValue[0..*];\n\t\treturn totalMass : MassValue = sum(partMasses);\n\t}\n\t\n\tcalc ms: MassSum {\n\t\tin partMasses = (vehicle.eng.m, vehicle.trans.m);\n\t\treturn totalMass;\n\t}\n\t\n\tpart vehicles[*] = (vehicle, vehicle);\n\tattribute masses1[*] = (vehicles as VehiclePart).m;\n\tattribute masses2[*] = (vehicles as vehicle).m;\n}"
    },
    {
      "name": "EnumerationTest",
      "text": "系统应支持枚举类型的定义，使其能够继承已有的属性定义，并用于表示离散的、有序或无序的值集合。  \n\n系统应允许枚举类型包含枚举值，并支持为每个枚举值定义特定的属性，使其可以携带额外的信息，例如数值表示。  \n\n系统应支持通过枚举变量引用特定的枚举值，并允许变量在初始化时显式或隐式地绑定到枚举类型，以确保类型一致性。  \n\n系统应支持定义枚举值的简写方式，使其在枚举定义内部可以省略 `enum` 关键字，提高代码可读性和简洁性。  \n\n系统应允许枚举类型对超类型进行约束，使其仅能取特定的数值范围，以确保在应用过程中符合特定的业务逻辑或物理限制。",
      "label": "package EnumerationTest {\n\t\n\tattribute def Color {\n\t\tattribute val : ScalarValues::Natural;\n\t}\n\t\n\tenum def ColorKind :> Color {\n\t\tdoc\n\t\t/*\n\t\t * An EnumerationDefinition can contain only EnumerationUsages. However,\n\t\t * it can specialize an AttributeDefinition in order to inherit\n\t\t * common features for its enumeration values.\n\t\t */\n\t\n\t\tenum red {\n\t\t\t:>> val = 0;\n\t\t}\n\t\tenum blue {\n\t\t\t:>> val = 1;\n\t\t}\n\t\tenum green {\n\t\t\t:>> val = 2;\n\t\t}\n\t}\n\t\n\tenum color : ColorKind;\n\tenum color1 = ColorKind::blue;\t// Implicitly typed by ColorKind.\n\tattribute color2 : ColorKind = color1;\n\t\n\tenum def E1 { a; b; c; \n\t\tdoc\n\t\t/*\n\t\t * The \"enum\" keyword is optional for EnumerationUsages used to define the\n\t\t * enumerated values of an EnumerationDefinition.\n\t\t */\n\t}\n\t\n\tenum def E2;\n\t\n\tattribute def Size :> ScalarValues::Real {\n\t\tdoc\n\t\t/*\n\t\t * An EnumerationDefinition can also be used to restrict a supertype to\n\t\t * specific values.\n\t\t */\n\t}\t\t\n\tenum def SizeChoice :> Size {\n\t\t= 60.0;\n\t\t= 70.0;\n\t\t= 80.0;\n\t}\t\n\tenum size: SizeChoice = 60.0;\n\t\n}"
    },
    {
      "name": "ImportTest",
      "text": "系统应支持包（package）的定义，并允许包内包含子包，以构建分层的命名空间结构。  \n\n系统应支持私有（private）导入机制，允许包导入其他包或子包中的特定元素，以实现模块化的结构，同时避免不必要的命名污染。  \n\n系统应支持通配符（*）导入，使得包可以一次性导入另一个包中的所有元素，提高代码的简洁性和可维护性。  \n\n系统应支持双星通配符（**）导入，以便递归地导入目标包及其所有子包中的元素，从而提供更灵活的命名空间管理。  \n\n系统应允许在包内定义部件（part）及部件类型（part def），并支持部件类型的继承（:>），以实现结构化的模型设计。  \n\n系统应允许包之间的相互导入，并支持跨包引用，以确保不同模块之间的可组合性和互操作性。",
      "label": "package ImportTest {\n    package Pkg1 {\n    \tprivate import Pkg2::Pkg21::Pkg211::P211;\n    \tprivate import Pkg2::Pkg21::*;\n    \tprivate import Pkg211::*::**;\n        part p11 : Pkg211::P211;\n        part def P12;\n    }\n\n    package Pkg2 {\n        private import Pkg1::*;\n        package Pkg21 {\n        \tpackage Pkg211 {\n        \t\tpart def P211 :> P12;\n        \t}\n        }\n    }\n}"
    },
    {
      "name": "MultiplicityTest",
      "text": "系统应支持定义具有多重性的部件和属性，以便表示在不同上下文中不同数量的实例。  \n\n系统应允许在部件定义中使用多重性范围，支持显式指定最小和最大实例数，例如 `[0..2]` 或 `[2..*]`，以灵活地描述部件的数量要求。  \n\n系统应允许为部件定义静态或动态的实例数量，支持通过属性值控制部件的实例化数量，例如 `e[n]` 和 `f[n..*]`，使得系统在运行时能够调整部件实例的数量。  \n\n系统应允许在属性定义中引用其他属性的值，使用类似于 `A[i]` 的方式来表示属性间的依赖关系，以确保数据结构的动态性和层次性。  \n\n系统应支持无限制的多重性表示（如 `[*]`），允许在某些情况下定义无固定数量限制的部件集合，以适应更加灵活和复杂的模型需求。",
      "label": "package MultiplicityTest {\n\t\n\tpart def P;\n\tattribute n : ScalarValues::Integer = 5;\n\t\n\tpart a[1];\n\tpart b[0..2] : P;\n\tpart c : P[2..*];\n\tpart d[*];\n\t\n\tpart e[n];\n\tpart f[n..*];\n\tpart g[1..n];\n\n\tattribute def A {\n\t\tattribute i :ScalarValues::Integer;\n\t\tattribute x : A[i];\n\t}\n}"
    },
    {
      "name": "ConnectionTest",
      "text": "系统应支持部件的层次结构，以允许在部件内部嵌套定义子部件，并提供对子部件的引用。  \n\n系统应允许在部件之间建立连接，使不同的部件能够相互通信或交互，并支持将连接关系继承到派生部件中。  \n\n系统应支持抽象连接的定义，其中应包含多个端点（end），并允许实例化具体的连接，并在其中绑定具体的部件实例。  \n\n系统应支持多个部件通过总线连接的方式进行交互，并允许在实例化连接时，显式指定各端点与部件的对应关系。  \n\n系统应允许在连接结构内定义局部部件，并支持端点的绑定，使得连接结构可以在内部定义更多的交互关系。  \n\n系统应支持抽象的流（flow）定义，并允许在部件之间建立流动关系，使得消息可以在部件之间传输。",
      "label": "package ConnectionTest {\n\t\n\tpart p {\n\t\tpart x {\n\t\t\tpart x1;\n\t\t}\n\t}\n\t\n\tpart def P {\n\t\tpart y;\n\n\t\tconnect p to y;\n\t\t\n\t\tpart p1 :> p;\n\t\n\t\tconnect p1.x to y;\n\t\tconnect p1.x.x1 to y;\n\t}\n\n\tabstract connection def C {\n\t\tpart p;\n\t\tend end1;\n\t\tend end2;\n\t\tend end3;\n\t}\n\t\n\tpart d1;\n\tpart d2;\n\tpart d3;\n\tpart d4;\n\t\n\tconnection bus : C connect (d1, d2, d3, d4);\n\t\n\tconnection : C {\n\t    end :>> end1 ::> d1;\n\t    end end2 ::> d2;\n\t    end end3 ::> d3;\n\t}\n\t\n\tconnection {\n\t\tpart q;\n\t\tend end1 ::> d1 :> q;\n\t\tend end2 ::> d2;\n\t}\n\t\n\tabstract flow def F;\n\t\n\tmessage : F from p to p;\n}"
    },
    {
      "name": "ControlNodeTest",
      "text": "系统应支持控制节点的建模，包括 `join`（汇合）和 `fork`（分叉）机制，以定义复杂的流程控制逻辑。  \n\n系统应允许多个动作（如 `A1` 和 `A2`）在 `join` 处汇合，表示它们都必须完成后才能继续执行后续流程。  \n\n系统应支持 `fork` 机制，在 `F` 处分叉，使得后续的 `B1` 和 `B2` 可以并行执行。  \n\n系统应支持 `then` 关键字，使动作之间能够按顺序连接，并保证流程控制的清晰性和可读性。  \n\n系统应确保 `join` 后的分叉 `fork` 能够正确触发，并保持流程的执行一致性，防止死锁或未定义行为。",
      "label": "action def ControlNodeTest {\n\taction A1;\n\tthen J;\n\t\n\taction A2;\n\tthen J;\n\t\n\tjoin J;\n\tthen fork F;\n\tthen B1;\n\tthen B2;\n\t\t\n\taction B1;\n\taction B2;\n}"
    },
    {
      "name": "ConstraintTest",
      "text": "系统应支持质量分析约束，使得总质量等于所有部件质量的总和，并提供用于定义此约束的数学表达式。  \n\n系统应允许在部件中定义质量属性，并支持继承，使派生部件能够重用质量分析约束。  \n\n系统应支持在部件实例上声明质量分析约束，并允许使用 `assert constraint` 语句进行约束验证。  \n\n系统应允许在质量分析约束中重定义属性，以确保子部件的质量可以正确映射到质量分析公式中。  \n\n系统应支持 `bind` 机制，使部件的属性可以绑定到约束的输入变量，以进行一致性检查。  \n\n系统应支持参数化的约束定义，其中约束的输入变量可以通过实例化时赋值，从而适用于不同的部件结构。  \n\n系统应允许在部件中声明质量约束，并使用数学表达式直接定义质量计算规则，而无需显式声明约束类型。  \n\n系统应支持质量限制约束，使得某一部件的质量不得超过设定的质量上限，并允许在系统范围内进行质量比较。  \n\n系统应支持逻辑约束表达式，例如 `assert not`，以确保特定质量限制约束不会被违反。",
      "label": "package ConstraintTest {\n\tprivate import ISQ::MassValue;\n\tprivate import SI::kg;\n\tprivate import NumericalFunctions::sum;\n\t\n\tconstraint def MassAnalysis {\n\t\tattribute totalMass: MassValue;\n\t\tattribute componentMasses: MassValue[0..*];\t\t\n\n\t\ttotalMass == sum(componentMasses)\n\t}\n\t\n\tpart def Component {\n\t\tattribute mass: MassValue;\n\t}\n\t\n\tpart vehicle : Component {\t\n\t\tpart engine : Component;\n\t\tpart frontAxleAssembly : Component;\n\t\tpart rearAxleAssembly : Component;\t\n\t}\n\t\t\n\tpart vehicle1a :> vehicle {\n\t\tassert constraint massAnalysis : MassAnalysis {\n\t\t\tattribute redefines totalMass;\n\t\t\tattribute redefines componentMasses;\n\t\t}\n\t\t\n\t\tbind massAnalysis.totalMass = mass;\n\t\tbind massAnalysis.componentMasses[1] = engine.mass;\n\t\tbind massAnalysis.componentMasses[1] = frontAxleAssembly.mass;\n\t\tbind massAnalysis.componentMasses[1] = rearAxleAssembly.mass;\n\t}\n\t\n\tpart vehicle1b :> vehicle {\t\t\n\t\tassert constraint massAnalysis : MassAnalysis {\n\t\t\tattribute redefines totalMass = mass;\n\t\t\tattribute redefines componentMasses = (engine.mass, frontAxleAssembly.mass, rearAxleAssembly.mass);\t\t\n\t\t}\t\n\t}\n\t\t\n\tconstraint def MassAnalysis2 { \n\t\tin totalMass : MassValue;\n\t\tin componentMasses: MassValue[0..*];\n\t\t\n\t\ttotalMass == sum(componentMasses)\n\t}\n\t\n\tpart vehicle2a :> vehicle {\n\t\tassert constraint massConstraint : MassAnalysis2;\n\t\t\n\t\tbind massConstraint.totalMass = mass;\n\t\tbind massConstraint.componentMasses[1] = engine.mass;\n\t\tbind massConstraint.componentMasses[1] = frontAxleAssembly.mass;\n\t\tbind massConstraint.componentMasses[1] = rearAxleAssembly.mass;\n\t}\n\t\t\n\tpart vehicle2b :> vehicle {\n\t\tassert constraint massAnalysis2 : MassAnalysis2 {\n\t\t\tin totalMass = mass;\n\t\t\tin componentMasses = (engine.mass, frontAxleAssembly.mass, rearAxleAssembly.mass);\n\t\t}\n\t}\n\t\n\tconstraint def MassAnalysis3 {\n\t\tin totalMass : MassValue;\n\t\tin componentMasses: MassValue[0..*];\n\t}\n\t\n\tconstraint massAnalysis3 : MassAnalysis3 {\n\t\tin totalMass : MassValue;\n\t\tin componentMasses: MassValue[0..*];\n\t\t\n\t\ttotalMass == sum(componentMasses)\n\t}\n\t\n\tpart vehicle3 :> vehicle {\n\t\tassert massAnalysis3 {\n\t\t\tin totalMass = mass;\n\t\t\tin componentMasses = (engine.mass, frontAxleAssembly.mass, rearAxleAssembly.mass);\n\t\t}\n\t}\n\t\n\tpart vehicle4 :> vehicle {\n\t\tassert constraint { mass == engine.mass + frontAxleAssembly.mass + rearAxleAssembly.mass }\n\t}\n\t\n\tconstraint massLimitation { mass : MassValue; massLimit : MassValue; mass < massLimit }\n\tassert not massLimitation { :>> mass = vehicle3.mass; :>> massLimit = vehicle4.mass; }\n}"
    },
    {
      "name": "VariabilityTest",
      "text": "系统应支持可变性管理，允许定义不同版本或变体的部件、操作和用例。每个部件应能够包含多个变体，以便根据不同的需求或条件选择不同的实现。例如，`P`部件可以通过`Q`的变体进行扩展，允许在`Q`中定义不同的属性，从而为部件`P`提供不同的行为。\n\n系统应能够通过变体定义在不同的情境下选择不同的功能或配置。例如，`V`部件应能够根据不同的条件变更为不同的`Q`部件变体，这些变体可能会对部件`P`的属性进行特定的调整。此变体机制能够为系统提供灵活的配置和定制功能。\n\n此外，系统还应能够支持可变性管理在用例、分析、验证和需求中的应用。每个用例、分析或验证都应能够通过变体进行定义，以便在不同的环境或需求下选择合适的操作流程或配置。这样，系统可以根据实际需求灵活调整其行为和结构。",
      "label": "package VariabilityTest {\n\tpart def P {\n\t\tattribute a;\n\t}\n\t\n\tpart def Q :> P;\n\tattribute def B;\n\tvariation part def V :> P {\n\t\tvariant part x : Q {\n\t\t\tattribute b : B :>> a;\n\t\t}\n\t}\n\t\n\tpart q : Q;\n\tvariation part v : P {\n\t\tvariant q {\n\t\t\tattribute b : B :>> a;\n\t\t}\n\t}\n\t\n\tpart y : P = v::q;\n\t\n\tvariation action def A {\n\t\tvariant action a1;\n\t\tvariant action a2;\n\t}\n\t\n\tvariation use case uc1 {\n    \tvariant use case uc11;\n    \tvariant use case uc12;\n    }\n\n    variation analysis a1;\n    \n    variation verification v1;\n    \n    variation requirement r {\n    \tvariant requirement r1;\n    }\n\t\n}"
    },
    {
      "name": "AssignmentTest",
      "text": "系统应支持定义和管理计数器对象，以便跟踪数值的增减变化。  \n\n系统应允许定义计数器的初始值，并提供操作用于对计数值执行增加和减少的赋值操作。  \n\n系统应支持定义独立的属性，以表示增加和减少操作的触发条件，并支持基于这些触发条件进行状态切换。  \n\n系统应支持定义状态模型，使计数器在不同状态下执行相应的赋值操作，并在状态转换过程中更新计数值。  \n\n系统应支持定义计算逻辑，允许对计数器执行特定的计算操作，并返回更新后的计数器状态。  \n\n系统应支持在操作过程中直接修改计数器的值，并支持通过计算逻辑执行赋值操作，以确保系统的灵活性和可扩展性。",
      "label": "package AssignmentTest {\n\t\n\tpart def Counter {\n\t\tattribute count : ScalarValues::Integer := 0;\n\t\t\n\t\taction incr {\n\t\t\tassign count := count + 1;\n\t\t}\n\t\t\n\t\taction decr {\n\t\t\tassign count := count - 1;\n\t\t}\n\t}\n\t\n\tattribute def Incr;\n\tattribute def Decr;\n\t\n\tstate def Counting {\n\t\tpart counter : Counter;\n\t\tentry assign counter.count := 0;\n\t\t\n\t\tthen state wait;\n\t\taccept Incr\n\t\t\tthen increment;\n\t\taccept Decr\n\t\t\tthen decrement;\n\t\t\n\t\tstate increment {\n\t\t\tdo assign counter.count := counter.count + 1;\n\t\t}\n\t\tthen wait;\n\t\t\n\t\tstate decrement {\n\t\t\tdo assign counter.count := counter.count - 1;\n\t\t}\n\t\tthen wait;\n\t}\n\t\n\tcalc def Increment { \n\t\tin c : Counter;\n\t\treturn : Counter;\n\t\t\n\t\tperform c.incr;\n\t\tc\n\t}\n\t\n\taction a {\n\t\tstate counting : Counting;\n\t\tassign counting.counter.count := counting.counter.count + 1;\n\t\tassign counting.counter.count := Increment(counting.counter).count;\n\t}\n}"
    },
    {
      "name": "DependencyTest",
      "text": "系统应支持包（package）的定义，并允许在包内组织不同层次的结构，如“应用层”（Application Layer）、“服务层”（Service Layer）和“数据层”（Data Layer）。  \n\n系统应支持私有导入（private import），使得一个包能够访问另一个包的内容，同时保持封装性。  \n\n系统应支持依赖关系（dependency）的定义，以描述一个层或组件如何依赖于另一个层或组件。例如，“应用层”依赖于“服务层”，“服务层”依赖于“数据层”。  \n\n系统应允许依赖关系不仅适用于层次结构，也适用于属性（attribute）之间。例如，属性 z 依赖于属性 x 和 y。  \n\n系统应确保依赖关系的正确性，避免循环依赖或非法依赖，保证系统的稳定性和可维护性。",
      "label": "package DependencyTest {\n\t\n\tpackage System {\n\t\tpackage 'Application Layer';\n\t\tpackage 'Service Layer';\n\t\tpackage 'Data Layer';\n\t}\n\t\n\tprivate import System::*;\n\t\n\tdependency Use from 'Application Layer' to 'Service Layer';\n\tdependency from 'Service Layer' to 'Data Layer';\n\t\n\tattribute x;\n\tattribute y;\n\tattribute z;\n\t\n\tdependency z to x, y;\n\t\n}"
    },
    {
      "name": "ParameterTest",
      "text": "系统应能够定义并管理一个具有递归属性的类型，该类型应包含一个字符串属性和一个自身类型的引用。这个类型的实例应能够通过引用自身来构建递归结构。系统应允许定义一个属性，该属性是这种类型的实例，并且能够通过某种计算函数与其他参数进行交互，以生成一个整数结果。这个计算函数应接受这种类型的实例以及一个整数作为输入，并返回一个整数作为输出。\n\n系统还应支持根据给定的参数计算属性值，并确保在计算过程中可以灵活地传递参数以产生相应的结果。例如，系统应能够计算一个属性的值，基于传入的参数类型实例和整数值，通过相应的计算函数返回最终结果。同时，系统还应支持通过不同的方式构建该类型的实例，包括通过直接赋值或通过引用已有实例来构建新的实例。",
      "label": "package ParameterTest {\n\tattribute def A {\n\t\tattribute x : ScalarValues::String;\n\t\tattribute y : A;\n\t}\n\t\n\tattribute a : A;\n\t\n\tcalc def F { in p : A; in q : ScalarValues::Integer; return :  ScalarValues::Integer; }\n\t\n\tattribute f = F(a, 2);\n\tattribute g = F(q = 1, p = a);\n\t\n\tattribute b = A(y=a, x=\"\"); \n\tattribute c = A(\"test2\");\n}"
    },
    {
      "name": "RequirementTest",
      "text": "系统应能够定义并管理约束和需求之间的关系。首先，系统应支持定义约束，并能够引用已有的约束。约束“C”应作为一种通用定义进行管理，并且系统应能够使用该约束来创建新的需求。\n\n系统应能够定义需求，其中每个需求可能依赖于一个或多个约束。需求“R”应假设并引用约束“c1”，并且在其定义中要求满足约束“c”。需求“R”还应包括文档注释，以便详细描述需求的目的和内容。在“R”需求中，还应定义一个名为“A”的需求类型，该类型应包含一个主题“s”，并且该需求类型应提供文本描述。\n\n系统应支持需求之间的继承关系，例如需求“R1”应继承并要求满足约束“c1”。每个需求都应能够与部件进行关联。例如，部件“q”应引用需求“R”，并且部件“q”应通过部件“p”来满足该需求。此外，系统还应能够验证需求是否得到了满足，并能够断言某个需求是否满足。\n\n系统还应能够处理需求的不满足情况。例如，需求“r1”应检查是否满足，并且可以断言部件“p”未能满足需求，而部件“q”未能满足需求时也应进行断言。",
      "label": "package RequirementTest {\n\tconstraint def C;\n\tconstraint c : C;\n\tprivate import q::**;\n\trequirement def R {\n\t\tassume constraint c1 : C;\n\t\trequire c;\n\t\tdoc /* */\n    \trequirement;\n    \trequirement def <'1'> A {\n    \t\tdoc /* Text */\n    \t\tsubject s;\n    \t}\n\t}\n\trequirement def R1 {\n\t\trequire constraint c1 :>> c;\n\t}\n\tpart p;\n\tpart q {\n\t\trequirement r : R;\n\t\tsatisfy r by p;\n\t\tassert satisfy r by q;\n\t}\n\t\n\trequirement r1 : R1;\n\tnot satisfy r1 by p;\n\tassert not satisfy r1 by q;\n\t\n}"
    },
    {
      "name": "RootPackageTest",
      "text": "系统应能够定义和管理多个包以及包之间的引用关系。首先，系统应能够定义包“P1”，其中包括一个名为“A”的部件定义。包“P2”应能够引用包“P1”中的部件“A”，并将其作为一个部件“a”进行定义。\n\n系统应允许包之间的层次关系，例如包“P2”引用了包“P1”中的部件，包“P3”则应能够继承包“P2”中的部件，并且通过定义部件“b”来表示其从部件“a”中派生。部件“b”应作为部件“a”的子集，以实现包之间的依赖和扩展。",
      "label": "package P1 {\n\tpart def A;\n}\n\npackage P2 {\n\tprivate import P1::*;\n\tpart a : A;\n}\n\nprivate import P2::*;\n\npackage P3 {\n\tpart b subsets a;\n}"
    },
    {
      "name": "TradeStudyTest",
      "text": "系统应能够定义和执行分析研究，特别是在贸易研究方面。系统应能够定义一个引擎的部件，并支持多个引擎实例（如`engine1`和`engine2`）。系统应支持定义一个贸易研究，专注于对引擎的评估，并能够通过指定目标来进行分析。例如，系统应允许定义一个引擎贸易研究，该研究的目标是最大化某个量。\n\n此外，系统应能够通过定义计算功能来评估引擎的表现，并返回一个实数值来表示该评估结果。该评估功能应接受一个引擎部件作为输入，并输出一个实数值。通过这种方式，系统能够支持复杂的评估和优化过程，帮助用户对不同的引擎进行比较和选择。",
      "label": "package TradeStudyTest {\n\tprivate import ScalarValues::Real;\n\tprivate import TradeStudies::*;\n\t\n\tpart def Engine;\n\tpart engine1: Engine;\n\tpart engine2: Engine;\n\t\n\tanalysis engineTradeStudy : TradeStudy {\n\t\tsubject : Engine[1..*] = (engine1, engine2);\n\t\tobjective : MaximizeObjective;\n\n\t\tcalc :>> evaluationFunction {\n\t\t\tin part : Engine;\n\t\t\treturn : Real;\n\t\t}\n\t\t\n\t\treturn part : Engine;\n\t}\n\t\n}"
    },
    {
      "name": "AnalysisTest",
      "text": "系统应支持定义和管理分析过程，以确保系统能够满足特定的分析目标，并提供结构化的分析方法。  \n\n系统应允许定义待分析的对象，并支持在分析过程中引用其属性和行为，以便进行系统性评估。  \n\n系统应支持定义分析目标，以明确分析的预期结果，并将分析目标与分析结果相关联，以确保分析的可追溯性和一致性。  \n\n系统应支持定义具体的分析案例，描述分析的执行方式，并允许在分析过程中访问分析对象的属性和方法，以实现分析目标。  \n\n系统应支持定义分析计划，将多个分析案例组织在一起，并允许指定分析目标。分析计划应能够返回分析结果，以支持进一步的评估和决策。  \n\n系统应支持定义分析上下文，以实例化分析计划，并将特定的系统实例作为分析的输入，确保分析能够在具体的应用场景下执行，并获得符合需求的分析结果。",
      "label": "package AnalysisTest {\n\n\tpart def V {\n\t\tm;\n\t}\n\t\n\tpart vv : V;\n\t\n\trequirement def AnalysisObjective {\n\t\tdoc /* ... */\n\t}\n\n\tanalysis def AnalysisCase {\n\t\tsubject v : V;\n\t\t\n\t\tobjective obj : AnalysisObjective { \n\t\t\tsubject = result;\n\t\t}\n\t\t\n\t\tv.m\n\t}\n\t\n\tanalysis def AnalysisPlan {\n\t\tsubject v : V;\n\t\t\n\t\tobjective {\n\t\t\tdoc /* ... */\n\t\t}\n\t\t\n\t\tanalysis analysisCase : AnalysisCase { return mass; }\n\t}\n\t\n\tpart analysisContext {\n\t\tanalysis analysisPlan : AnalysisPlan {\n\t\t\tsubject v = vv;\n\t\t}\n\t}\n}"
    },
    {
      "name": "PartTest",
      "text": "系统应能够定义多个不同类型的部件，并支持这些部件之间的关系和交互。首先，系统应包含一个名为“ A”的部件，这个部件包括多个属性和关系。每个A部件应该具有一个引用的属性“z”，该属性是一个整数类型。同时，A部件包含一个列表属性“x”，并且从该属性派生出一个名为“y”的只读属性。此外，A部件还包括一个名为“b”的子部件，该子部件属于B类型，而“c”是一个受保护的端口。\n\nB部件是抽象的，并且需要具备多个抽象的子部件和端口。B部件应包括一个“a”部件，表示一个具有1到2个实例的A类型部件，并且B部件自身也可以作为A部件的子集。此外，B部件应具有一个名为“c”的端口，表示它是A部件的一个子集。B部件中的端口“x”是与C类型相关的，并且包含两个端口“p”和“q”。在B部件中，还应该包含一个动作“a1”和一个执行动作“a2”。此外，B部件应定义多个状态，如“s1”和“s2”。\n\nC部件定义了端口和引用属性。C部件具有一个名为“y”的私有引用属性，指向A和B类型。C部件还具有别名“z1”和“z2”来引用“y”，以及两个与C类型相关的端口“c1”和“c2”。\n\n系统还应支持部件之间的继承关系，例如部件p1继承自p2，p2继承自p3，并且p3继承自p1。系统还允许部件继承自自身，如p4继承自p4。这些继承关系应确保部件的多层次结构和互相之间的功能扩展。",
      "label": "package PartTest {\n\t\n\tpart f: A;\n\n\tpublic part def A {\n\t\tpart <'1'> b: B;\n\t\tprotected port c: C;\n\t\treadonly attribute x[0..2];\n\t\tderived ref attribute y :> x;\n\t\tref z : ScalarValues::Integer;\n\t}\n\t\n\tabstract part def <xx> B {\n\t\tpublic abstract part a: A[1..2];\n\t\tpublic abstract part b subsets a;\n\t\tpublic abstract part c[0..1] subsets a;\n\t\tport x: ~C {\n\t\t    port p;\n\t\t    ref port q;\n\t\t}\n\t\tpackage P { }\n\t\t\n\t\taction a1;\n\t\tperform action a2;\n\t\t\n\t\tstate s1;\n\t\texhibit state s2;\n\t}\n\t\n\tprivate port def C {\n\t\tprivate in ref y: A, B;\n\t\talias z1 for y;\n\t\talias z2 for y;\n\t\tport c1 : C;\n\t\tref port c2 : C;\n\t}\n\t\n    part p1 :> p2;\n    part p2 :> p3; \n    part p3 :> p1;\n    \n    part p4 :> p4;\n\t\n}"
    },
    {
      "name": "UseCaseTest",
      "text": "系统应能够定义和管理用例，以描述系统与用户之间的交互。每个用例应能够指定一个系统作为主题，并定义一个用户作为参与者。系统应支持用例之间的包含关系，即一个用例可以包含其他用例，从而形成更复杂的交互结构。\n\n在这个系统中，一个用例（如`UseSystem`）可以包括其他子用例（如`UC1`和`uc2`），并且每个用例都可以指定与其相关的目标和参与者。参与者（如用户）可以在不同的用例中担任不同角色，并通过包含和扩展关系进行交互。用例之间的嵌套关系允许系统在定义功能和角色时更加灵活和模块化。\n\n此外，系统应能够执行用例，并确保用例的执行顺序和关系能够正确反映实际操作。例如，`system`部件应能够包括其他用例并执行它们，以展示系统在实际应用中的工作流程。",
      "label": "package UseCaseTest {\n\n\tpart def System;\t\n\tpart def User;\n\t\n\tuse case def UseSystem {\n\t\tsubject system : System;\n\t\tactor user : User;\n\t\t\n\t\tobjective  { \n\t\t\t/* Goal */\n\t\t}\n\t\t\n\t\tinclude use case uc1 : UC1;\t\n\t\tinclude use case uc2 {\n\t\t\tsubject = system;\n\t\t\tactor user = UseSystem::user;\n\t\t}\n\t}\n\t\n\tuse case def UC1;\n\t\n\tpart user : User;\n\t\n\tuse case uc2 {\n\t\tactor :>> user;\n\t}\n\t\n\tuse case u : UseSystem;\n\t\n\tpart system : System {\n\t\tinclude uc2;\n\t\tperform u;\n\t}\n\t\n}"
    },
    {
      "name": "DecisionTest",
      "text": "系统应支持动作（action）的定义，并允许在动作内部定义属性，以存储相关数据。  \n\n系统应支持决策（decision）结构，使得可以根据某个条件（如属性值）来执行不同的分支动作。  \n\n系统应允许在决策中定义多个条件分支，并支持 `else` 分支，以处理所有未满足条件的情况。  \n\n系统应支持连续的决策操作，使得在一个决策执行后，可以紧接着执行另一个决策。  \n\n系统应支持动作的定义，并允许在决策结构中引用这些动作，以便在不同条件下执行不同的操作。  \n\n系统应支持顺序关系（succession），使得某个动作可以在满足特定条件时，自动引导到下一个动作。  \n\n系统应允许定义初始动作，并基于条件决定后续执行的流程，以实现灵活的逻辑控制。",
      "label": "action def DecisionTest {\n\tattribute x = 1;\n\t\n\tdecide 'test x';\n\tif x == 1 then A1; \n\tif x > 1 then A2;\n\telse A3; \n\t\n\tthen decide; \n\tif true then A1;\n\tif false then A2;\n\t\n\taction A1;\n\taction A2;\n\taction A3;\n\t\n\tsuccession S first A1 \n\t\tif x == 0 then A2;\n\t\t\n\tfirst A3;\n\t\tif x > 0 then 'test x';\n}"
    },
    {
      "name": "ActionTest",
      "text": "系统应支持定义和管理动作，允许描述操作的执行流程、数据传递和条件控制。  \n\n系统应能够定义具有输入参数的动作，并支持在执行过程中进行数据绑定，以确保参数正确传递。在动作执行过程中，系统应支持顺序执行、条件判断、消息发送和接收、时间触发等多种机制，以确保操作的有序性和灵活性。  \n\n系统应支持定义包含多个步骤的复杂动作，包括起始事件、合并点、属性接收、定时触发、消息交互以及决策流程。系统应能够根据不同的条件，决定后续流程的执行路径，确保动作能够根据实际情况进行动态调整。  \n\n此外，系统应允许定义带有属性的动作，并支持在不同动作之间建立引用关系，以实现动作间的关联和交互，从而支持复杂的行为建模和执行控制。",
      "label": "package ActionTest {\n\taction def A{ in x; }\n\t\n\taction a: A { \n\t\tfirst start;\n\t\t\n\t\taction b { in y = x; }\n\t\t\n\t\tbind x = b.y;\n\t}\n\t\n\tattribute def S;\n\t\n\taction a1 {\n\t\tfirst start;\t\t\n\t\tthen merge m;\n\t\tthen accept S;\n\t\tthen accept sig after 10[SI::s]; \n\t\tthen accept at Time::Iso8601DateTime(\"2022-01-30T01:00:00Z\");\n\t\t\n\t\tthen send S() to b;\n\t\tthen accept when b.f;\n\t\tthen decide;\n\t\t\tif true then m;\n\t\t\telse done;\n\t}\n\t\n\taction b {\n\t\tattribute f : ScalarValues::Boolean;\n\t\tref action a : A;\n\t}\n\t\n}"
    },
    {
      "name": "AllocationTest",
      "text": "系统应支持定义和管理逻辑结构与物理结构之间的分配关系，以确保系统设计中的层次对应和映射。  \n\n系统应允许定义逻辑部分和物理部分，并在各自的结构中包含相应的组成部分。逻辑部分可以包括组件，而物理部分可以包含装配结构及其元素。  \n\n系统应支持定义分配关系，以建立逻辑结构和物理结构之间的关联。分配关系应具有端点，明确指示逻辑部分和物理部分的对应关系。  \n\n系统应支持实例化具体的分配，通过在逻辑实例与物理实例之间建立映射，实现逻辑结构向物理结构的映射。系统应能够在具体元素级别进行分配，使得逻辑组件可以与物理装配中的元素建立对应关系，以保证系统设计的完整性和一致性。",
      "label": "package AllocationTest {\n\tpart def Logical {\n\t\tpart component;\n\t}\n\t\n\tpart def Physical {\n\t\tpart assembly {\n\t\t\tpart element;\n\t\t}\n\t}\n\t\n\tpart l : Logical {\n\t\tpart :>> component;\n\t}\n\tpart p : Physical {\n\t\tpart :>> assembly {\n\t\t\tpart :>> element;\n\t\t}\n\t}\n\t\n\tallocation def A;\n\t\n\tallocation def Logical_to_Physical :> A {\n\t\tend logical : Logical;\n\t\tend physical : Physical;\n\t}\n\t\n\tallocation allocation1 : Logical_to_Physical allocate l to p;\t\n\tallocation allocation2 : Logical_to_Physical allocate (\n\t\tlogical ::> l,\n\t\tphysical ::> p\n\t);\n\n\tallocate l.component to p.assembly.element;\n}"
    },
    {
      "name": "CommentTest",
      "text": "系统应支持在模型中添加不同类型的注释，以提供额外的说明和文档信息。  \n\n系统应允许在包级别、定义级别和元素内部添加注释，并支持多种注释格式，包括单行注释和多行注释，以增强模型的可读性。  \n\n系统应支持定义命名注释，并允许对已有的注释进行额外的注释，以便提供更详细的说明。  \n\n系统应支持文档化注释，并允许关联到特定的语言环境，以确保支持多语言文档和国际化需求。  \n\n系统应允许在模型元素内嵌入注释，以提供详细的上下文说明，并支持对包、部件定义和其他元素的注释管理。",
      "label": "/* AAA */\n  //a lexical comment (\"note\") is not a part of model\npackage CommentTest {\n\t// inside package\n\t/*\n*AAA\n * BBB*/\t\n /*\n    *\n    *\n    * AAA  ***   \n    *BBB\n    \t\t\t\t\t\t\t\t*/\n\n   /*\n *       AAAA\n *       BBBB           */\t\n /* AAAA\n \n \n  * BBBB\n *\n * CCCC\n */\n locale \"en_US\" /*\n * AAAA\n * BBBB\n *    CCC DDD    \n */\n\t\n\t/* comment inside a package */\n\tdoc locale \"en_US\" /* Documentation about Package */\n\tcomment cmt /* Named Comment */\t\n\tcomment cmt_cmt about cmt /* Comment about Comment */\n\t\n\tcomment about C /* Documention Comment about Part Def */\n\tpart def C {\n\t\tdoc /* Documentation in Part Def */\n\t\tcomment /* Comment in Part Def */\n\t\tcomment about CommentTest locale \"en_US\" /* Comment about Package */\n\t}\n\t/* abc */\n\tpart def A;\n}"
    },
    {
      "name": "TextualRepresentationTest",
      "text": "系统应能够定义并管理项和操作，并支持在特定语言中表达约束和动作。首先，系统应支持定义一个项，其中包含一个属性，并能对该属性进行约束。例如，系统应能够定义一个项`C`，其中包含一个属性`x`，并且可以在OCL（对象约束语言）中定义约束条件，确保属性`x`大于0.0。\n\n系统还应支持操作定义，并允许在特定语言中表达操作逻辑。例如，系统应能够定义一个操作`setX`，该操作接收一个项和一个新的实数值作为输入，并能够在`alf`语言中实现操作。此操作会修改项`C`的属性`x`，并可能包含日志或其他输出（如打印设置新值）。通过这些机制，系统可以定义和执行对项的修改和约束检查。",
      "label": "package TextualRepresentationTest {\n\tprivate import ScalarValues::Real;\n\t\n\titem def C {\n\t    attribute x: Real;\n\t    assert constraint x_constraint {\n\t\t    rep inOCL language \"ocl\" \n\t\t        /* self.x > 0.0 */\n\t    }\n\t}\n\t\n\taction def setX {\n\t\tin c : C;\n\t\tin newX : Real;\n\t\t\n\t    language \"alf\" \n\t        /* c.x = newX;\n\t         * WriteLine(\"Set new x\");\n\t         */\n\t}\n\t\n}"
    },
    {
      "name": "ConjugationTest",
      "text": "系统应支持端口的定义和端口的共轭，以确保正确建模端口之间的交互关系。  \n\n系统应允许在部件内定义端口，包括标准端口和共轭端口，以便描述数据或信号的输入输出方向。  \n\n系统应支持连接定义，使端口能够建立明确的连接关系，其中一个端口应与其共轭端口配对，以确保兼容性。  \n\n系统应允许定义接口，以规范端口交互的结构，使端口连接能够符合预定的接口要求。  \n\n系统应支持在部件内部建立嵌套结构，并允许在嵌套部件中定义端口、连接和接口，使其能够正确映射到外部端口，以保证复杂系统的端口一致性和正确性。",
      "label": "package ConjugationTest {\n\tport def P;\n\t\n\tpart def B {\n\t\tport p1: P;\n\t\tport p2: ~P;\n\t}\n\t\n\tconnection def A {\n\t\tend port p1: P;\n\t\tend port p2: ~P;\n\t}\n\t\n\tinterface def I {\n\t\tend p1: P;\n\t\tend p2: ~P;\n\t}\n\t\n\tpart def B1 {\n\t\tpart p {\n\t\t\tport p1: P;\n\t\t\tport p2: ~P;\t\t\n\t\t}\n\t\n\t\tconnection a: A {\n\t\t\tend port p3: P ::> p.p1;\n\t\t\tend port p4: ~P ::> p.p2;\n\t\t}\n\t\tinterface i: I {\n\t\t\tend port p3: P ::> p.p1;\n\t\t\tend port p4: ~P ::> p.p2;\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "StructuredControlTest",
      "text": "系统应能够定义并管理一系列基于条件和循环的控制结构。首先，系统应支持条件判断（if-else）来根据变量的不同值执行不同的操作。例如，系统应能够检查变量`i`的值，如果`i`小于0，则将其设置为0；如果`i`等于0，则将其设置为1；如果`i`大于0，则将`i`增加1。\n\n系统应支持更多的条件判断操作，如在`i`大于0时执行特定的动作。系统还应能够在满足条件时触发循环（while或loop），例如在`i`大于0时，执行递减操作直到条件不再满足。此外，系统应支持基于条件的迭代控制，例如`while`和`for`循环，并支持条件退出机制，如基于布尔值`b`来决定循环是否继续。\n\n例如，系统应能够定义一个`while`循环，递减变量`i`，直到满足退出条件`b`。在`for`循环中，系统应支持对特定范围内的数字进行迭代，并在每次迭代时执行操作。通过这些控制结构，系统可以灵活地执行基于条件和迭代的任务。",
      "label": "package StructuredControlTest {\n\t\n\taction {\n\t\tattribute i : ScalarValues::Integer := 0;\n\t\tattribute b : ScalarValues::Boolean;\n\t\t\n\t\tif i < 0 {\n\t\t\tassign i := 0;\n\t\t} else if i == 0 {\n\t\t\tassign i := 1;\n\t\t} else {\n\t\t\tassign i := i + 1;\n\t\t}\n\t\t\n\t\tif i > 0 {\n\t\t\tassign i := i + 1;\n\t\t}\n\t\t\n\t\tthen action aLoop\n\t\twhile i > 0 {\n\t\t\tassign i := i - 1;\n\t\t} until b;\n\t\t\n\t\tthen while i > 0 {\n\t\t\tassign i := i - 1;\n\t\t}\n\t\t\n\t\tloop {\n\t\t\tassign i := i - 1;\n\t\t} until b;\n\t\t\t\t\n\t\tfor n : ScalarValues::Integer in (1, 2, 3) {\n\t\t\tassign i := i * n;\n\t\t}\n\t}\n}"
    },
    {
      "name": "ItemTest",
      "text": "系统应支持项的定义，允许通过项关联其他项和部件，以便在系统中表示更复杂的结构。  \n\n系统应允许在项内嵌套其他项，并且支持通过引用来表示项之间的关系。  \n\n系统应支持定义抽象项，以便为具体项提供统一的接口或结构，并允许通过继承和实现机制对项进行扩展。  \n\n系统应允许定义部件，并支持私有和受保护的属性，确保对项和部件的访问控制，以提高系统的安全性和模块化设计。  \n\n系统应支持端口的定义，允许项通过端口进行输入输出交互，并且可以通过端口在项之间传递数据或信号。",
      "label": "package ItemTest {\n\t\n\titem f: A;\n\n\tpublic item def A {\n\t\titem b: B;\n\t\tprotected ref part c: C;\n\t}\n\t\n\tabstract item def B {\n\t\tpublic abstract part a: A;\n\t}\n\t\n\tprivate part def C {\n\t\tprivate in ref y: A, B;\n\t}\n\t\n\tport def P {\n\t\tin item a1: A;\n\t\tout item a2: A;\n\t}\n\t\n}"
    },
    {
      "name": "VerificationTest",
      "text": "系统应能够定义和管理验证过程，用于确保某些要求得到满足。每个验证用例应能指定验证的目标，并基于给定的条件进行验证。例如，`VerificationCase`用于验证部件`V`的某些属性（如`m`）是否符合特定条件（例如`m == 0`）。这些验证用例能够为系统提供一种标准的检查机制，确保系统的正确性。\n\n系统应支持将多个验证用例组织成一个验证计划。例如，`VerificationPlan`允许定义一系列验证用例，并在某些上下文中执行这些验证。通过这种方式，系统能够在更高层次上进行组织和管理各类验证任务。\n\n每个验证计划都可以与具体的部件（如`V`）关联，并在验证上下文中执行。例如，`verificationContext`可以指定一个验证计划，并将其应用到特定的部件实例（如`vv`），以验证其是否符合要求。这种结构能够确保验证过程的灵活性和可扩展性，使得系统在不同场景下能够进行一致的验证。",
      "label": "package VerificationTest {\n\n\tpart def V {\n\t\tm : ScalarValues::Integer;\n\t}\n\t\n\tpart vv : V;\n\t\n\trequirement def R {\n\t\tdoc /* ... */\n\t}\n\t\n\trequirement r : R;\n\n\tverification def VerificationCase {\t\t\n\t\tsubject v : V;\t\n\t\tobjective {\n\t\t\tverify requirement : R;\n\t\t}\n\t\t\n\t\tVerificationCases::PassIf(v.m == 0)\n\t}\n\t\n\tverification def VerificationPlan {\n\t\tsubject v : V;\n\t\t\n\t\tobjective {\n\t\t\tverify r;\n\t\t}\n\t\t\n\t\tverification verificationCase : VerificationCase;\n\t}\n\t\n\tpart verificationContext {\n\t\tverification verificationPlan : VerificationPlan {\n\t\t\tsubject v = vv;\n\t\t}\n\t}\n}"
    },
    {
      "name": "DefaultValueTest",
      "text": "系统应支持部件（part）的定义，并允许在部件内部定义属性（attribute）。  \n\n系统应支持为属性提供默认值（default value），以便在未显式赋值时使用默认值。  \n\n系统应允许在实例化部件时，覆盖其属性的默认值，并提供新的值。  \n\n系统应支持继承（inheritance），使得一个部件可以基于另一个部件进行扩展，同时允许修改其属性的默认值。  \n\n系统应允许属性的默认值基于另一个属性的值，使得默认值可以动态适应上下文。  \n\n系统应支持部件的实例化，并保证属性的默认值在继承和实例化过程中得到正确应用。",
      "label": "package DefaultValueTest {\n\t\n\tpart def V {\n\t\tattribute m default = 10;\n\t\tattribute n = 20;\n\t}\n\t\n\tpart v1 : V {\n\t\tattribute :>> m = 20;\n\t}\n\t\n\tpart def W :> V {\n\t\tattribute :>> m default = n;\n\t}\n\t\n\tpart v2 = W();\n\t\n}"
    },
    {
      "name": "MetadataTest",
      "text": "系统应支持元数据定义，用于对模型元素进行附加信息的注解，并能够根据需要为这些注解指定特定的属性。  \n\n系统应允许通过元数据引用来为模型元素赋予分类信息，并能够在元数据中引用已定义的枚举类型，以便提供更多的语义信息，例如安全级别。  \n\n系统应支持库中的元数据定义，使其能够跨多个部分或包进行重用，并且能够在引用中指定详细的分类或安全级别。  \n\n系统应支持在引用或部分中为元数据提供详细的分类级别，如 `conf` 或 `secret`，以便在模型中表达不同的权限或敏感性。  \n\n系统应支持元数据引用的灵活性，使其能够在模型的不同位置使用，确保安全性、分类等信息能够正确地在系统中传递和管理。",
      "label": "package MetadataTest {\n\tprivate import 'User Defined Extensions'::*;\n\t\n\tlibrary package 'User Defined Extensions' {\n\t\t\n\t\t#Security enum def ClassificationLevel :> ScalarValues::Natural {\n\t\t\tuncl : ClassificationLevel = 0;\n\t\t\tconf : ClassificationLevel = 1;\n\t\t\t#Security enum secret : ClassificationLevel = 2;\n\t\t}\n\t\t\n\t\tmetadata def Classified {\n\t\t\tref :>> annotatedElement : SysML::Usage;\n\t\t\tref classificationLevel : ClassificationLevel;\n\t\t}\n\t\t\n\t\tmetadata def Security;\n\t}\n\t\n\tref x {\n\t\tmetadata Classified {\n\t\t\tclassificationLevel = ClassificationLevel::conf;\n\t\t}\n\t}\n\t\n\tref y {\n\t\t@Classified {\n\t\t\tclassificationLevel = ClassificationLevel::conf;\n\t\t}\n\t\t@Security;\n\t}\n\t\n\tprivate ref #Classified #Security z1;\n\tabstract #Classified z2;\n\t\n\tref z {\n\t    #Security #Classified metadata Classified {\n\t        classificationLevel = ClassificationLevel::secret;\n\t    }\n\t}\t\n\t\n}"
    },
    {
      "name": "FeaturePathTest",
      "text": "系统应支持部件（part）的定义，并允许部件内部包含其他子部件，从而建立层次化的结构。  \n\n系统应支持部件的实例化，并允许在不同的上下文中引用已定义的部件，以确保模型的可重用性。  \n\n系统应允许在部件定义中引用外部已存在的部件，使其能够通过关联的方式访问其他部件的属性或行为。  \n\n系统应支持在部件内部进行连接（connect），以建立部件之间的关系，并支持绑定（bind）以确保不同部件或属性的值保持一致。  \n\n系统应允许子部件对父部件的部分结构进行子集化（subsets），以形成更具体的派生结构，并支持在不同层级之间建立流动（flow）关系，以确保数据或信号的正确传递。  \n\n系统应支持枚举类型的定义，并允许枚举值在部件属性的绑定过程中使用，以确保类型一致性。  \n\n系统应允许在表达式中使用嵌套引用，以支持复杂的部件层级访问，例如多层级的部件导航和实例化。",
      "label": "package Q {\n  part def F {\n  \tpart a : A;\n  }\n  \n  part f : F;\n  \n  part def A {\n    part g = f.a;\n  }\n  \n  part def B {\n  \tpart f : F;\n  \tpart a : A;\n  }\n  \n  part def C {\n\tpart b : B {\n\t  connect f.a to a.g;\n\t  bind f.a = a.g;\n\t}\n  \n\tpart c subsets b.f {\n\t  \tpart aa subsets a;\n\t}\n\t\n\tflow b.f.a to c.aa;\n  }\n  \n  part e1 {\n  \tattribute x : E;\n  \t// Ensure that \"e1\" resolves correctly.\n  \tbind e1.x = E::e2;\n  }\n  \n  enum def E {\n  \tenum e1;\n  \tenum e2;\n  }\n  \n  part g = A().g.g.g;\n\t\n}"
    },
    {
      "name": "ViewTest",
      "text": "系统应支持视图的定义和管理，并允许定义不同的视角和关切。每个视角应包含一个框架，其中可以包括多个关切。系统应能够通过不同的渲染方式来展示这些视角和关切内容。\n\n系统还应支持将不同的关切与利益相关者关联，以便在视图中正确反映各方的需求和目标。每个视角应允许多种渲染方式，并能够根据需要进行展示或隐藏。\n\n此外，系统应能够定义多个视图，其中可以通过暴露不同的部件来展示关切和框架。不同的渲染方式可以用于显示这些视图，并且允许为视图中的部件设置别名，以便更方便地进行引用和操作。\n\n这些功能支持用户灵活地创建和管理视图，从而更好地表达和传递系统中的关切和目标。",
      "label": "package ViewTest {\n\tpackage P {\n\t\tpublic part p1;\n\t\tprivate part p2;\n\t}\n\t\n\tpart def S;\n\t\n\tconcern def C {\n\t\tstakeholder s : S;\n\t}\n\t\n\tconcern c : C {\n\t\tstakeholder s1;\n\t}\n\t\n\tviewpoint def VP {\n\t\tframe c;\n\t}\n\t\n\trendering def R;\n\t\n\trendering r : R;\n\t\n\tview def V {\n\t\tviewpoint vp: VP {\n\t\t\tframe concern c1;\n\t\t\tconcern c2;\n\t\t}\n\t\trender rendering r1: R[0..1]; \n\t\t\n\t\tview v: V[0..*] {\n\t\t\texpose P::*;\n\t\t\trender r;\n\t\t\t\n\t\t\trendering r2;\n\t\t\t\n\t\t\talias vp1 for p1;\n\t\t\t// Note: \"expose\" imports all.\n\t\t\talias vp2 for p2;\n\t\t}\n\t}\n\n}"
    },
    {
      "name": "ExternalShapeRefExample",
      "text": "系统应支持通过元数据引用外部定义的形状。在该模型中，电池单元部件的形状定义为一个外壳，并附带元数据说明，用于指明该形状的用途（例如“highLoD”）以及引用的外部形状文件路径。与此同时，电池单元部件还包含一个包络盒形状，用以描述其基本外形尺寸，其长度为140毫米、宽度为148毫米、高度为90毫米。",
      "label": "package ExternalShapeRefExample {\n\tprivate import ScalarValues::String;\n\tprivate import ShapeItems::*;\n\tprivate import ISQ::mass;\n\tprivate import SI::mm;\n\n\tmetadata def ExternalShapeRef {\n\t\tdoc\n\t\t/*\n\t\t * Metadata to reference an externally defined shape.\n\t\t */\n\t\n\t\tattribute purpose : String[1];\n\t\tattribute shapeIri : String[1];\n\t}\n\t\n\tpart myBatteryUnit {\n\t    item :>> shape : Shell {\n\t\t\tmetadata ExternalShapeRef {\n\t\t\t\tpurpose = \"highLoD\";\n\t\t\t\tshapeIri = \"file:/detailed-geometry/LEMS-250W_BatteryHousing_Example.step\";\n\t\t\t}\n\t\t}\t\t\n\n\t\tprivate item envelopingBoxBatteryUnit : Box :> envelopingShapes {\n\t\t\t:>> length = 140[mm];\n\t\t\t:>> width = 148[mm];\n\t\t\t:>> height = 90[mm];\n\t\t}\n\t}\n}"
    },
    {
      "name": "SimpleQuadcopter",
      "text": "系统应支持定义一个简单四旋翼无人机模型，该模型通过组合基本的几何形状和布尔运算构建各个部件，并采用统一的坐标参考框架来进行精确定位和装配。\n\n首先，模型定义了马达的基本形状，使用一个圆柱体表示，其半径为18毫米，高度为30毫米。该马达形状作为后续构建支架和电机组件的基础元素。\n\n支架（Strut）部件基于一个原始的矩形梁构造，该梁由一个长方体表示，尺寸为160毫米长、15毫米宽和8毫米高。为了在支架上为马达预留安装空间，模型在该矩形梁中通过布尔差集运算减去一个与马达形状相同的圆柱体切口，该切口通过平移变换相对于原始梁定位，确保其位置正确。\n\n电机与螺旋桨总成（PropellerMotorAssy）由两个部分构成：螺旋桨和马达。螺旋桨部分以一个圆柱体表示，其半径为80毫米、高度为6毫米，用于定义螺旋桨的外部体积；马达部分则复用了前面定义的马达形状。两者均通过平移变换在总成中定位，螺旋桨位于较高的位置（Z方向偏移31毫米），而马达则保持在较低位置（Z方向偏移为0）。\n\n摄像机（Camera）部件包括一个摄像机外壳和一个视场（Field of View）定义。摄像机外壳以一个圆柱体表示，半径为15毫米、高度为24毫米。视场部分则通过一个圆锥体模拟，其形状由高度（500毫米）和根据20度半顶角计算得到的底部半径确定。该视场经过旋转变换，使得其方向相对于原始坐标系翻转（例如围绕Y轴旋转180度），以确保摄像机视角的正确表达。\n\n无人机的主机身（quadCopter）定义为一个空间项目，其包含一个数据基准（datum），该基准为整个系统提供统一的坐标参照，原点设在主机身底部，+X轴指向前方飞行方向，+Z轴指向上方。主机身内部构造包括一个“原始机身”（rawBody），即一个长方体构造体（160毫米长、15毫米宽、8毫米高），以及一个“切角盒”（cuttingCornersBox），该盒子通过平移和绕Z轴旋转45°进行定位，用以切割机身角部。最终，主机身形状通过原始机身与切角盒的布尔交集运算确定，确保机身具备理想的外形轮廓。\n\n此外，模型定义了四个支架（strut1至strut4）和四个螺旋桨-电机总成（propellerMotorAssy1至propellerMotorAssy4），它们分别通过平移和旋转变换定位于主机身的不同角落，位置参数均以统一的构造参数（如xStrut、yStrut、zStrut和zPMAssy）确定。最后，摄像机部件被放置在主机身的+X面上，并经过绕Y轴50°向下的旋转，以实现预期的安装角度和视角。\n\n总体而言，该DSL通过定义基本几何形状、布尔运算以及精确的坐标变换，构建了一个结构清晰、各部分之间精确定义位置关系的四旋翼无人机模型。",
      "label": "package SimpleQuadcopter {\n    private import ISQ::*;\n    private import SI::*;\n    private import SpatialItems::*;\n    private import ShapeItems::*;\n    private import RealFunctions::sqrt;\n    private import TrigFunctions::pi;\n    private import TrigFunctions::tan;\n    private import MeasurementReferences::CoordinateFrame;\n    private import MeasurementReferences::TranslationRotationSequence;\n    private import MeasurementReferences::Translation;\n    private import MeasurementReferences::Rotation;\n\n    part motorShape : SpatialItem {\n        item :>> shape : Cylinder {\n            :>> radius = 18 [mm];\n            :>> height = 30 [mm];\n        }\n    }\n    \n    part def Strut :> SpatialItem {\n        // By default will get same coordinateFrame.mRefs as owning SpatialItem, i.e.:\n        // attribute :>> coordinateFrame { :>> mRefs = (mm, mm, mm); }\n        \n        /* rawStrut is a construction shape: a rectangular beam */\n        part rawStrut : SpatialItem {\n            item :>> shape : Box {\n                :>> length = 160 [mm];\n                :>> width = 15 [mm];\n                :>> height = 8 [mm];\n            }\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (0, shape.width/2, 0)[source]));\n                }\n            }        \n        }\n\n        /* motorCutout is a construction shape: a cylinder of the same shape as the  */\n        part motorCutout : SpatialItem {\n            item :>> shape = motorShape.shape;\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (175, 0, -1)[source]));\n                }\n            }\n        }\n        \n        /* Strut shape is CSG difference of rawStrut minus motorCutout */\n        attribute :> differencesOf[1] {\n            item :>> elements = (rawStrut, motorCutout);\n        }        \n    }\n    \n    part def PropellerMotorAssy :> SpatialItem {\n        // By default will get same coordinateFrame.mRefs as owning CompoundSpatialItem, i.e.:\n        // attribute :>> coordinateFrame { :>> mRefs = (mm, mm, mm); }\n\n        part propeller : SpatialItem {\n            item :>> shape : Cylinder {\n                doc /* propeller stay-out volume, without propeller shaft */\n                :>> radius = 80 [mm];\n                :>> height = 6 [mm];\n            }\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (175, 0, 31)[source]));\n                }\n            }\n        }\n\n        part motor : SpatialItem {\n            item :>> shape = motorShape.shape;\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (175, 0, 0)[source]));\n                }\n            }\n        }\n        \n        // By default the shape of a PropellerMotorAssy is the union of its owned composite items and parts that are SpatialItems.\n    }\n\n    part def Camera :> SpatialItem {\n        // By default will get same coordinateFrame.mRefs as owning CompoundSpatialItem, i.e.:\n        // attribute :>> coordinateFrame { :>> mRefs = (mm, mm, mm); }\n\n        part cameraHousing : SpatialItem {\n            item :>> shape : Cylinder {\n                :>> radius = 15 [mm];\n                :>> height = 24 [mm];\n            }\n        }\n\n        /* The field of view is modeled as an item, since it is not a part of the quadcopter but rather a stay-out volume \n         * that can for example be used to formulate a constraint.\n         */\n        item fieldOfView : SpatialItem {\n            doc /* Conical field of view with half-top angle 20 degree */\n            item :>> shape : Cone {\n                :>> radius = height * tan(20 * pi/180) [mm];\n                :>> height = 500 [mm];\n            }\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Rotation( (0, 1, 0)[source], 180['°']));\n                }\n            }\n        }\n        \n        // By default the shape of a Camera is the union of its owned composite items and parts that are SpatialItems.\n    }\n\n    part quadCopter : SpatialItem {\n        attribute datum :>> coordinateFrame {\n            doc /* The datum is the top level coordinate frame of the system-of-interest, i.e., the quadcopter.\n                 * By convention its origin is placed at the bottom of the mainBody with the +X axis pointing in the \n                 * forward fligth (velocity) direction and the +Z axis pointing upward. The +Y axis completes the \n                 * right-handed Cartesian coordinate system.\n                 */\n            :>> mRefs = (mm, mm, mm);\n        }\n\n        part mainBody : SpatialItem {\n\n            /* rawBody is a construction shape: the enveloping rectangular box */\n            part rawBody : SpatialItem {\n                item :>> shape : Box {\n                    :>> length = 160 [mm];\n                    :>> width = 15 [mm];\n                    :>> height = 8 [mm];\n                }\n                attribute :>> coordinateFrame {\n                    :>> transformation : TranslationRotationSequence {\n                        :>> elements = (Translation( (0, shape.width/2, 0)[source]));\n                    }\n                }        \n            }\n            \n            /* cuttingBox is a construction shape: the enveloping rectangular box */\n            part cuttingCornersBox : SpatialItem {\n                item :>> shape : Box {\n                    :>> length = 105 [mm];\n                    :>> width = 105 [mm];\n                    :>> height = 60 [mm];\n                }\n                attribute :>> coordinateFrame {\n                    :>> transformation : TranslationRotationSequence {\n                        :>> elements = (Translation( (0, -shape.length/sqrt(2), -10)[source]), \n                                        Rotation((0, 0, 1)[source], 45['°']));\n                    }\n                }        \n            }\n\n            /* Main body shape is the CSG intersection of rawBody and cuttingCornersBox */\n            attribute :> intersectionsOf[1] {\n                item :>> elements = (rawBody, cuttingCornersBox);\n            }\n            // Current syntax is not end-user friendly\n            // It will be possible to specify following simple CSG expression:\n            // item :>> shape = rawBody & cuttingCornersBox;\n        }\n\n        // Helper construction parameters\n        private attribute xStrut : LengthValue = 49.60[mm];\n        private attribute yStrut : LengthValue = 24.65[mm];\n        private attribute zStrut : LengthValue = 25[mm];\n        private attribute zPMAssy : LengthValue = 12[mm];\n\n        part strut1 : Strut {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (xStrut.num, yStrut.num, zStrut.num)[source]), \n                                    Rotation((0, 0, 1)[source], 45['°']));\n                }\n            }        \n        }\n        part strut2 : Strut {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (-xStrut.num, yStrut.num, zStrut.num)[source]), \n                                    Rotation((0, 0, 1)[source], 135['°']));\n                }\n            }        \n        }\n        part strut3 : Strut {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (-xStrut.num, -yStrut.num, zStrut.num)[source]), \n                                    Rotation((0, 0, 1)[source], 225['°']));\n                }\n            }        \n        }\n        part strut4 : Strut {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (xStrut.num, -yStrut.num, zStrut.num)[source]), \n                                    Rotation((0, 0, 1)[source], 315['°']));\n                }\n            }        \n        }\n\n        part propellerMotorAssy1 : PropellerMotorAssy {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (xStrut.num, yStrut.num, zPMAssy.num)[source]), \n                                    Rotation((0, 0, 1)[source], 45['°']));\n                }\n            }        \n        }\n        part propellerMotorAssy2 : PropellerMotorAssy {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (-xStrut.num, yStrut.num, zPMAssy.num)[source]), \n                                    Rotation((0, 0, 1)[source], 135['°']));\n                }\n            }        \n        }\n        part propellerMotorAssy3 : PropellerMotorAssy {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (-xStrut.num, -yStrut.num, zPMAssy.num)[source]), \n                                    Rotation((0, 0, 1)[source], 225['°']));\n                }\n            }        \n        }\n        part propellerMotorAssy4 : PropellerMotorAssy {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (xStrut.num, -yStrut.num, zPMAssy.num)[source]), \n                                    Rotation((0, 0, 1)[source], 315['°']));\n                }\n            }        \n        }\n\n        /* The camera is placed protruding from the +X face of the main body, rotated about the +Y axis over 50° downwards */\n        part camera : Camera {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (59, 0, 2)[source]), \n                                    Rotation((0, 1, 0)[source], 50['°']));\n                }\n            }        \n        }\n        \n    }\n}"
    },
    {
      "name": "CarWithShapeAndCSG",
      "text": "系统应支持定义一个具有空间形状和布尔运算的车辆模型，其中包括车辆和内置发动机的详细描述。\n\n车辆模型扩展自空间项目，其外形由一个长方体构成，尺寸分别为4800毫米长、1840毫米宽和1350毫米高。车辆还定义了一个基准坐标框架，用于统一各部分的测量参考。作为车辆的动力来源，包含一个发动机部件。该发动机通过一个平移旋转序列在车辆中定位，其平移量为在X方向3800毫米、在Y方向居中调整以及在Z方向40毫米。\n\n发动机模型同样扩展自空间项目，用于描述一个简化的两缸发动机。发动机的主要构成部分是一个原始发动机块，其形状为一个长方体，尺寸为300毫米长、190毫米宽、330毫米高。为了模拟两个气缸，模型中添加了两个圆柱体。第一个圆柱体的半径为55毫米、高度为350毫米，并通过相对于发动机坐标框架的平移变换定位，平移量包括90毫米的后缸间距、发动机块宽度的一半以及在Z方向上偏移-10毫米。第二个圆柱体采用与第一个相同的尺寸，其定位通过增加前缸间距（由两个气缸半径加上20毫米间隙确定）实现。最终，使用构造实体几何（CSG）差集操作，将原始发动机块减去这两个圆柱体，从而形成最终的发动机外形。",
      "label": "package CarWithShapeAndCSG {\n\tprivate import SpatialItems::*;\n\tprivate import ShapeItems::*;\n\tprivate import Objects::Point;\n\tprivate import Quantities::VectorQuantityValue;\n\tprivate import MeasurementReferences::CoordinateFrame;\n\tprivate import MeasurementReferences::TranslationRotationSequence;\n\tprivate import MeasurementReferences::Translation;\n\tprivate import MeasurementReferences::Rotation;\n\tprivate import SI::*;\n\n\tpart def Car :> SpatialItem {\n\t\tdoc\n\t\t/*\n\t\t * Car with simple engine\n\t\t */\n\t\n        item :>> shape = Cuboid(4800 [mm], 1840 [mm], 1350 [mm]);\n\n        attribute datum :>> coordinateFrame {\n            :>> mRefs = (mm, mm, mm);\n        }\n\n\t\tpart powerSource : Engine [1] :> componentItems {\n\t\t\t:>> ecf { \n\t\t\t\t:>> mRefs = datum.mRefs;\n\t\t\t\t:>> transformation : TranslationRotationSequence {\n\t\t\t\t\t:>> source = datum;\n\t\t\t\t\t:>> elements = ( Translation((3800, (1840-190)/2, 40)[datum]) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpart def Engine :> SpatialItem {\n\t\tdoc\n\t\t/*\n\t\t * Simple 2-cylinder engine\n\t\t * \n\t\t * Note: The engine shape is modeled as a rectangular box with two cylindrical holes, a gross simplification.\n\t\t */\n\t\n\t\titem :>> shape [1];\n\t\t\n\t\tattribute <ecf> engineCoordinateFrame :>> coordinateFrame;\t\t\n\n\t\tpart rawEngineBlock : SpatialItem [1] {\n\t\t\titem :>> shape : Box [1] {\n\t    \t\t:>> length = 300 [mm];\n\t    \t\t:>> width = 190 [mm];\n\t    \t\t:>> height = 330 [mm];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate attribute rearCylinderSpacing = 90 [mm];\n\t\tprivate item cylinder1 : SpatialItem [1] {\n\t\t\titem :>> shape : Cylinder [1] {\n\t    \t\t:>> radius = 55 [mm];\n\t    \t\t:>> height = 350 [mm];\n\t\t\t}\n\t\t\tattribute :>> coordinateFrame {\n\t\t\t\t:>> transformation : TranslationRotationSequence {\n\t\t\t\t\t:>> source = ecf;\n\t\t\t\t\t:>> elements = (Translation( (rearCylinderSpacing, rawEngineBlock.shape.width/2, -10)[ecf]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate attribute cylinderSpacing = 2*cylinder1.shape.radius + 20 [mm];\n\t\tprivate item cylinder2 : SpatialItem [1] {\n\t\t\titem :>> shape : Cylinder [1] {\n\t    \t\t:>> radius = cylinder1.shape.radius;\n\t    \t\t:>> height = cylinder1.shape.height;\n\t\t\t}\n\t\t\tattribute :>> coordinateFrame {\n\t\t\t\t:>> transformation : TranslationRotationSequence {\n\t\t\t\t\t:>> source = ecf;\n\t\t\t\t\t:>> elements = ( Translation((rearCylinderSpacing + cylinderSpacing, rawEngineBlock.shape.width/2, -10)[ecf]) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* CSG difference of rawEngineBlock minus cylinder1 minus cylinder2 */\n\t\tattribute :> differencesOf[1] {\n\t\t\titem :>> elements = (rawEngineBlock, cylinder1, cylinder2);\n\t\t}\n\t}\n}"
    },
    {
      "name": "CarWithEnvelopingShape",
      "text": "系统应支持定义具有包围形状的车辆实体。此车辆模型采用一个实心盒子作为外形包络，该盒子的长度、宽度和高度分别定义为4800毫米、1840毫米和1350毫米，用以描述车辆的空间边界和基本几何形态。",
      "label": "package CarWithEnvelopingShape {\n\tprivate import ShapeItems::Box;\n\tprivate import SI::mm;\n\n\tpart def Car {\n\t\tdoc\n\t\t/*\n\t\t * Example car with simple enveloping shape that is a solid box\n\t\t */\n\t\n\t\titem boundingBox : Box [1] :> boundingShapes {\n\t\t\t:>> length = 4800 [mm];\n\t\t\t:>> width  = 1840 [mm];\n\t\t\t:>> height = 1350 [mm];\n\t\t}\n\t}\n}"
    },
    {
      "name": "ServerSequenceModel",
      "text": "系统应定义一个服务器序列模型，支持消息传递和事件驱动的交互。\n在该系统中，信号定义包括“订阅”、“发布”和“交付”三种基本操作。每个操作都通过特定的属性（如主题）和引用关联的部分（如订阅者或出版物）来描述。\n\n此外，系统应支持定义一个发布/订阅序列模型，其中包含三个主要角色：生产者、服务器和消费者。生产者通过发布源事件生成消息并向服务器发送。服务器在接收到订阅目标事件后触发发布目标事件和交付源事件。消费者接收订阅源事件并触发交付目标事件。\n\n系统通过消息流的方式，在不同角色之间传递事件和信息，确保各部分之间的协作和信息的正确传递。",
      "label": "package ServerSequenceModel {\n\tprivate import ScalarValues::String;\n\tpublic import SignalDefinitions::*;\n\n\tpackage SignalDefinitions {\n\t    item def Subscribe {\n\t    \tattribute topic : String;\n\t    \tref part subscriber;\n\t    }\n\t    \n\t\titem def Publish {\n\t\t\tattribute topic : String;\n\t\t\tref publication;\n\t\t}\n\t\t\n\t\titem def Deliver {\n\t\t\tref publication;\n\t\t}\n\t}\n\n\tpart def PubSubSequence {\n\t\tpart producer[1] {\n\t\t\tevent occurrence publish_source_event;\n\t\t}\n\t\t\n\t\tmessage publish_message from producer.publish_source_event to server.publish_target_event;\n\t\t\n\t\tpart server[1] {\n\t\t\tevent occurrence subscribe_target_event;\n\t\t\tthen event occurrence publish_target_event;\n\t\t\tthen event occurrence deliver_source_event;\n\t\t}\n\t\t\n\t\tmessage subscribe_message from consumer.subscribe_source_event to server.subscribe_target_event;\n\t\tmessage deliver_message from server.deliver_source_event to consumer.deliver_target_event;\n\t\t\n\t\tpart consumer {\n\t\t\tevent occurrence subscribe_source_event;\n\t\t\tthen event occurrence deliver_target_event;\n\t\t}\n\t}\n}"
    },
    {
      "name": "ServerSequenceRealization-2",
      "text": "系统应实现一个发布/订阅模型的具体化，涵盖了生产者、服务器和消费者之间的消息传递和行为管理。该系统通过端口、接口、状态机和消息绑定来描述消息流和事件顺序。\n\n在该系统中，生产者通过定义一个发布端口向服务器发送发布消息。生产者的行为包括生成并发送带有主题和出版物的发布消息，通过端口与服务器进行交互。\n\n服务器包括两个端口：发布端口和订阅端口。服务器的行为由状态机管理，首先接收订阅请求，并在接收到订阅消息后转入等待发布状态。当服务器接收到发布消息后，它会根据主题判断是否匹配订阅的主题，如果匹配，则发送交付消息给订阅者。服务器的状态和行为确保了按顺序处理订阅和发布操作。\n\n消费者通过订阅端口向服务器发送订阅消息，并接收交付消息。消费者的行为包括发送订阅消息并接收来自服务器的交付消息，确保消费者能够根据其订阅的主题接收到对应的发布消息。\n\n系统通过定义消息流和事件绑定，确保了生产者、服务器和消费者之间的消息按顺序传递并进行处理。每个消息的发送和接收都与特定的事件绑定，以确保系统中各部分的协调性。\n\n该模型通过明确的消息传递和行为定义，确保了发布/订阅机制的正确性和时序一致性，增强了系统中各个组件之间的协作和信息的流动。",
      "label": "package ServerSequenceRealization_2 {\n\tprivate import ScalarValues::String;\n\tprivate import ServerSequenceModel::*;\n\tprivate import Configuration::*;\n\t\n\tpackage Configuration {\n\t\t\n\t\tport def PublicationPort;\n\t\t\n\t\tport def SubscriptionPort;\n\t\t\n\t\tpart producer_2[1] {\n\t\t\tattribute someTopic : String;\n\t\t\tprivate item somePublication;\n\t\t\t\n\t\t\tport publicationPort : ~PublicationPort;\n\t\t\t\n\t\t\tperform action producerBehavior {\t\n\t\t\t\taction publish send Publish(someTopic, somePublication) via publicationPort;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface producer_2.publicationPort to server_2.publicationPort {\n\t\t\tbind source::outgoingTransfersFromSelf = target::incomingTransfersToSelf;\n\t\t}\n\t\t\n\t\tpart server_2[1] {\n\t\t\tport publicationPort : PublicationPort;\n\t\t\tport subscriptionPort : SubscriptionPort;\n\t\t\t\n\t\t\texhibit state serverBehavior {\n\t\t\t\tentry; then waitForSubscription;\n\t\t\t\t\n\t\t\t\tstate waitForSubscription;\n\t\t\t\ttransition subscribing\n\t\t\t\t\tfirst waitForSubscription\n\t\t\t\t\taccept sub : Subscribe via subscriptionPort\n\t\t\t\t\tthen waitForPublication;\n\t\t\t\t\t\n\t\t\t\tstate waitForPublication;\n\t\t\t\ttransition delivering\n\t\t\t\t\tfirst waitForPublication\n\t\t\t\t\taccept pub : Publish via publicationPort\n\t\t\t\t\tif pub.topic == subscribing.sub.topic\n\t\t\t\t\tdo send Deliver(pub.publication) to subscribing.sub.subscriber\n\t\t\t\t\tthen waitForPublication;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface consumer_2.subscriptionPort to server_2.subscriptionPort {\n\t\t\tbind source::outgoingTransfersFromSelf = target::incomingTransfersToSelf;\n\t\t}\n\t\t\n\t\tpart consumer_2[1] {\n\t\t\tattribute myTopic : String;\n\t\t\t\n\t\t\tport subscriptionPort : ~SubscriptionPort;\n\t\t\t\n\t\t\tperform action consumerBehavior {\n\t\t\t\taction subscribe send Subscribe(myTopic, consumer_2) to server_2;\n\t\t\t\tthen action delivery accept Deliver via consumer_2;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpart realization_2 : PubSubSequence {\n\t\tpart :>> producer :> producer_2 {\n\t\t\tevent producerBehavior.publish[1] :>> publish_source_event;\n\t\t}\n\n\t\tpart :>> server :> server_2 {\n\t\t\tevent serverBehavior.subscribing.accepter[1] :>> subscribe_target_event;\n\t\t\tevent serverBehavior.delivering.accepter[1] :>> publish_target_event;\n\t\t\tevent serverBehavior.delivering.effect[1] :>> deliver_source_event;\n\t\t}\n\t\t\n\t\tpart :>> consumer :> consumer_2 {\n\t\t\tevent consumerBehavior.subscribe[1] :>> subscribe_source_event;\n\t\t\tevent consumerBehavior.delivery[1] :>> deliver_target_event;\n\t\t}\n\n\t\tmessage :>> publish_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = producer.publicationPort;\n \t\t\tend :>> target = server.publicationPort;\n \t\t}\n\t\tmessage :>> subscribe_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = consumer.subscriptionPort;\n \t\t\tend :>> target = server.subscriptionPort;\n \t\t}\n\t\tmessage :>> deliver_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = server;\n \t\t\tend :>> target = consumer;\n \t\t}\n \t\t\n \t\t/* Binding sent/accept messages to specification model messages. */\n\t\t  /* Sends */\n \t\tbind producer_2.producerBehavior.publish.sentMessage = publish_message;\n \t\tbind consumer_2.consumerBehavior.subscribe.sentMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.delivering.effect.sentMessage = deliver_message;\n \t\t  /* Accepts */\n \t\tbind consumer_2.consumerBehavior.delivery.acceptedMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.subscribing.accepter.acceptedMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.delivering.accepter.acceptedMessage = publish_message;\n\t}\n}"
    },
    {
      "name": "ServerSequenceRealization-3",
      "text": "系统应实现一个外部发布/订阅机制的详细模型，使用端口、接口、流和行为来精确控制生产者、服务器和消费者之间的消息传递。\n\n在该系统中，生产者通过定义一个发布端口将发布消息发送到服务器。生产者的行为包括生成带有主题和出版物的发布请求，并通过该端口传递消息。发布请求通过流与端口连接，确保消息的顺序和时序一致。\n\n服务器包含两个端口：一个用于接收发布消息，另一个用于接收订阅消息和发送交付消息。服务器的行为包括先接受订阅请求，记录订阅的主题，然后等待发布消息。收到发布消息后，服务器检查消息的主题是否匹配订阅的主题。如果匹配，则生成交付消息并发送给订阅者。服务器的行为确保了按顺序处理订阅、发布和交付操作。\n\n消费者通过订阅端口向服务器发送订阅请求，并接收交付消息。消费者的行为包括发送订阅请求并接收来自服务器的交付消息。消费者会根据其订阅的主题接收相应的发布消息，并进行后续的处理。\n\n系统通过定义流和事件绑定，确保了消息在生产者、服务器和消费者之间的顺畅传递和正确的时序。每个消息的发送和接收都与特定的事件和流绑定，以确保消息的顺序和处理的协调性。\n\n该模型通过精确控制消息传递、事件流和行为定义，确保了发布/订阅机制的有效性和一致性，使系统中各个组件能够高效、可靠地协同工作。",
      "label": "package ServerSequenceRealization_3 {\n\tprivate import ScalarValues::String;\n\tprivate import ServerSequenceModel::*;\n\tprivate import Configuration::*;\n\t\n\tpackage Configuration {\n\t\t\n\t\tport def PublicationPort {\n\t\t\tin ref publish : Publish;\n\t\t}\n\t\t\n\t\tport def SubscriptionPort {\n\t\t\tin ref subscribe : Subscribe;\n\t\t\tout ref deliver : Deliver;\n\t\t}\n\t\t\n\t\tinterface def PublicationInterface {\n\t\t\tend source : ~PublicationPort;\n\t\t\tend target : PublicationPort;\n\t\t}\n\t\t\n\t\tinterface def SubscriptionInterface {\n\t\t\tend source : ~SubscriptionPort;\n\t\t\tend target : SubscriptionPort;\n\t\t}\n\t\t\n\t\tpart producer_3[1] {\n\t\t\tattribute someTopic : String;\n\t\t\tprivate item somePublication;\n\t\t\t\n\t\t\tport publicationPort : ~PublicationPort {\n\t\t\t\tout ref :>> publish;\n\t\t\t}\n\t\t\t\n\t\t\tperform action producerBehavior {\n\t\t\t\taction publish {\n\t\t\t\t\tout ref request : Publish[1] = Publish(someTopic, somePublication);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tflow publish_request from producerBehavior.publish.request to publicationPort.publish;\n\t\t}\n\t\t\n\t\tinterface publication_interface : PublicationInterface connect producer_3.publicationPort to server_3.publicationPort {\n\t\t\tflow publish_request from publication_interface.source.publish to publication_interface.target.publish;\n\t\t}\n\t\t\n\t\tpart server_3[1] {\n\t\t\tport publicationPort : PublicationPort {\n\t\t\t\tin ref :>> publish;\n\t\t\t}\n\t\t\tport subscriptionPort : SubscriptionPort {\n\t\t\t\tin ref :>> subscribe;\n\t\t\t\tout ref :>> deliver;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tflow subscribe_request from subscriptionPort.subscribe to serverBehavior.subscribing.request;\n\t\t\tflow publish_request from publicationPort.publish to serverBehavior.publishing.request;\n\t\t\tflow deliver_response from serverBehavior.delivering.response to subscriptionPort.deliver;\n\t\t\t\n\t\t\tperform action serverBehavior {\n\t\t\t\t\n\t\t\t\taction subscribing {\n\t\t\t\t\tin ref request : Subscribe[1];\n\t\t\t\t\tout attribute topic : String[1] = request.topic;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthen merge continuePublishing;\t\t\t\n\t\t\t\tthen action publishing {\n\t\t\t\t\tin ref request : Publish[1];\n\t\t\t\t\tout attribute topic[1] = request.topic;\n\t\t\t\t\tout ref publication[1] = request.publication;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthen decide;\n\t\t\t\t\tif publishing.topic == subscribing.topic then delivering;\n\t\t\t\t\telse continuePublishing;\n\t\t\t\t\t\n\t\t\t\tthen action delivering {\n\t\t\t\t\tin topic : String[1] = subscribing.topic;\n\t\t\t\t\tin publication[1] = publishing.publication;\n\t\t\t\t\tout ref response : Deliver = Deliver(publication);\n\t\t\t\t}\n\t\t\t\tthen continuePublishing;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface subscription_interface : SubscriptionInterface connect consumer_3.subscriptionPort to server_3.subscriptionPort {\n\t\t\tflow subscribe_request from subscription_interface.source.subscribe to subscription_interface.target.subscribe;\n\t\t\tflow deliver_response from subscription_interface.target.deliver to subscription_interface.source.deliver;\n\t\t}\n\t\t\n\t\tpart consumer_3[1] {\n\t\t\tattribute myTopic : String;\n\t\t\t\n\t\t\tport subscriptionPort : ~SubscriptionPort {\n\t\t\t\tout ref :>> subscribe;\n\t\t\t\tin ref :>> deliver;\n\t\t\t}\n\t\t\t\n\t\t\tflow subscribe_request from consumerBehavior.subscribe.request to subscriptionPort.subscribe;\n\t\t\tflow deliver_response from subscriptionPort.deliver to consumerBehavior.delivery.response;\n\n\t\t\tperform action consumerBehavior {\n\t\t\t\taction subscribe {\n\t\t\t\t\tout ref request : Subscribe = Subscribe(myTopic);\n\t\t\t\t}\n\t\t\t\tthen action delivery {\n\t\t\t\t\tin ref response : Deliver;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpart realization_2 : PubSubSequence {\n\t\tpart :>> producer :> producer_3 {\n\t\t\tevent producerBehavior.publish[1] :>> publish_source_event;\n\t\t}\n\n\t\tpart :>> server :> server_3 {\n\t\t\tevent serverBehavior.subscribing[1] :>> subscribe_target_event;\n\t\t\tevent serverBehavior.publishing[1] :>> publish_target_event;\n\t\t\tevent serverBehavior.delivering[1] :>> deliver_source_event;\n\t\t}\n\t\t\n\t\tpart :>> consumer :> consumer_3 {\n\t\t\tevent consumerBehavior.subscribe[1] :>> subscribe_source_event;\n\t\t\tevent consumerBehavior.delivery[1] :>> deliver_target_event;\n\t\t}\n\t\t\n\t\tflow :>> publish_message from producer.producerBehavior.publish.request to server.serverBehavior.publishing.request {\n\t\t\tevent producer.publish_request[1];\n\t\t\tthen event publication_interface.publish_request[1];\n\t\t\tthen event server.publish_request[1];\n\t\t}\n\t\t\n\t\tflow :>> subscribe_message from consumer.consumerBehavior.subscribe.request to server.serverBehavior.subscribing.request {\n\t\t\tevent consumer.subscribe_request[1];\n\t\t\tthen event subscription_interface.subscribe_request[1];\n\t\t\tthen event server.subscribe_request[1];\n\t\t}\n\t\t\n\t\tflow :>> deliver_message from server.serverBehavior.delivering.response to consumer.consumerBehavior.delivery.response {\n\t\t\tevent server.deliver_response[1];\n\t\t\tthen event subscription_interface.deliver_response[1];\n\t\t\tthen event consumer.deliver_response[1];\n\t\t}\n\t}\n}"
    },
    {
      "name": "ServerSequenceOutsideRealization-3",
      "text": "系统应实现一个外部发布/订阅模型的具体化，结合端口、接口、事件流和行为定义，以更细粒度地控制和描述发布、订阅和交付的过程。\n\n在该系统中，生产者通过定义一个发布端口来发送发布消息，并通过行为定义来执行发布操作。发布请求通过瞬时流传递，以确保消息按指定顺序进行处理。生产者通过端口与服务器进行连接，发送发布请求并触发事件。\n\n服务器包含两个端口：发布端口和订阅端口。服务器行为由状态机管理，首先接收订阅请求并记录订阅的主题，随后等待发布消息。接收到发布消息后，服务器会判断消息的主题是否匹配订阅的主题，如果匹配，则生成交付消息并发送给订阅者。每个操作（订阅、发布、交付）都有明确的事件流和操作顺序，以确保按时序处理消息和请求。\n\n消费者通过订阅端口向服务器发送订阅请求，并接收交付消息。消费者行为定义了订阅操作和交付响应，确保消费者能够及时接收和处理来自服务器的消息。\n\n系统通过事件流连接不同组件，确保生产者、服务器和消费者之间的消息顺畅传递。事件流的定义确保了消息的传递按正确的顺序发生，保持了系统中各个组件之间的同步。\n\n该模型通过精确控制事件流和消息传递的顺序，增强了发布/订阅机制的时序和行为一致性，确保了系统中各个组件的协作和数据一致性。",
      "label": "package ServerSequenceOutsideRealization_3 {\n\tprivate import ScalarValues::String;\n\tprivate import ServerSequenceModelOutside::*;\n\tprivate import Configuration::*;\n\t\n\tpackage Configuration {\n\t\t\n\t\tport def PublicationPort {\n\t\t\tin ref publish : Publish;\n\t\t}\n\t\t\n\t\tport def SubscriptionPort {\n\t\t\tin ref subscribe : Subscribe;\n\t\t\tout ref deliver : Deliver;\n\t\t}\n\t\t\n\t\tinterface def PublicationInterface {\n\t\t\tend source : ~PublicationPort;\n\t\t\tend target : PublicationPort;\n\t\t}\n\t\t\n\t\tinterface def SubscriptionInterface {\n\t\t\tend source : ~SubscriptionPort;\n\t\t\tend target : SubscriptionPort;\n\t\t}\n\t\t\n\t\tpart producer_3[1] {\n\t\t\tattribute someTopic : String;\n\t\t\tprivate item somePublication;\n\t\t\t\n\t\t\tport publicationPort : ~PublicationPort {\n\t\t\t\tout ref :>> publish;\n\t\t\t}\n\t\t\t\n\t\t\tperform action producerBehavior {\n\t\t\t\taction publish {\n\t\t\t\t\tout ref request : Publish[1] = Publish(someTopic, somePublication);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* Internal flows are instantaneous to make arrival/leave ordering in SequenceModelOutside.sysml\n\t\t\t * equivalent to ordering participant internals in ServerSequenceRealization-3.sysml. */\n\t\t\tflow publish_request from producerBehavior.publish.request to publicationPort.publish\n\t\t\t\t{ attribute :>> isInstant = true;}\n\t\t}\n\t\t\n\t\tinterface publication_interface : PublicationInterface connect producer_3.publicationPort to server_3.publicationPort {\n\t\t\tflow publish_request from publication_interface.source.publish to publication_interface.target.publish;\n\t\t}\n\t\t\n\t\tpart server_3[1] {\n\t\t\tport publicationPort : PublicationPort {\n\t\t\t\tin ref :>> publish;\n\t\t\t}\n\t\t\tport subscriptionPort : SubscriptionPort {\n\t\t\t\tin ref :>> subscribe;\n\t\t\t\tout ref :>> deliver;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tflow subscribe_request from subscriptionPort.subscribe to serverBehavior.subscribing.request\n\t\t\t\t{ attribute :>> isInstant = true;}\n\t\t\tflow publish_request from publicationPort.publish to serverBehavior.publishing.request\n\t\t\t\t{ attribute :>> isInstant = true;}\n\t\t\tflow deliver_response from serverBehavior.delivering.response to subscriptionPort.deliver\n\t\t\t\t{ attribute :>> isInstant = true;}\n\t\t\t\n\t\t\tperform action serverBehavior {\n\t\t\t\t\n\t\t\t\taction subscribing {\n\t\t\t\t\tin ref request : Subscribe[1];\n\t\t\t\t\tout attribute topic : String[1] = request.topic;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthen merge continuePublishing;\t\t\t\n\t\t\t\tthen action publishing {\n\t\t\t\t\tin ref request : Publish[1];\n\t\t\t\t\tout attribute topic[1] = request.topic;\n\t\t\t\t\tout ref publication[1] = request.publication;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthen decide;\n\t\t\t\t\tif publishing.topic == subscribing.topic then delivering;\n\t\t\t\t\telse continuePublishing;\n\t\t\t\t\t\n\t\t\t\tthen action delivering {\n\t\t\t\t\tin topic : String[1] = subscribing.topic;\n\t\t\t\t\tin publication[1] = publishing.publication;\n\t\t\t\t\tout ref response : Deliver = Deliver(publication);\n\t\t\t\t}\n\t\t\t\tthen continuePublishing;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface subscription_interface : SubscriptionInterface connect consumer_3.subscriptionPort to server_3.subscriptionPort {\n\t\t\tflow subscribe_request from subscription_interface.source.subscribe to subscription_interface.target.subscribe;\n\t\t\tflow deliver_response from subscription_interface.target.deliver to subscription_interface.source.deliver;\n\t\t}\n\t\t\n\t\tpart consumer_3[1] {\n\t\t\tattribute myTopic : String;\n\t\t\t\n\t\t\tport subscriptionPort : ~SubscriptionPort {\n\t\t\t\tout ref :>> subscribe;\n\t\t\t\tin ref :>> deliver;\n\t\t\t}\n\t\t\t\n\t\t\tflow subscribe_request from consumerBehavior.subscribe.request to subscriptionPort.subscribe\n\t\t\t\t{ attribute :>> isInstant = true;}\n\t\t\tflow deliver_response from subscriptionPort.deliver to consumerBehavior.delivery.response\n\t\t\t\t{ attribute :>> isInstant = true;}\n\n\t\t\tperform action consumerBehavior {\n\t\t\t\taction subscribe {\n\t\t\t\t\tout ref request : Subscribe = Subscribe(myTopic);\n\t\t\t\t}\n\t\t\t\tthen action delivery {\n\t\t\t\t\tin ref response : Deliver;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpart realization_2 : PubSubSequence {\n\t\tpart :>> producer :> producer_3 {\n\t\t\tevent producerBehavior.publish[1] :>> publish_source_event;\n\t\t}\n\n\t\tpart :>> server :> server_3 {\n\t\t\tevent serverBehavior.subscribing[1] :>> subscribe_target_event;\n\t\t\tevent serverBehavior.publishing[1] :>> publish_target_event;\n\t\t\tevent serverBehavior.delivering[1] :>> deliver_source_event;\n\t\t}\n\t\t\n\t\tpart :>> consumer :> consumer_3 {\n\t\t\tevent consumerBehavior.subscribe[1] :>> subscribe_source_event;\n\t\t\tevent consumerBehavior.delivery[1] :>> deliver_target_event;\n\t\t}\n\t\t\n\t\tflow :>> publish_message from producer.producerBehavior.publish.request to server.serverBehavior.publishing.request {\n\t\t\tevent producer.publish_request[1];\n\t\t\tthen event publication_interface.publish_request[1];\n\t\t\tthen event server.publish_request[1];\n\t\t}\n\t\t\n\t\tflow :>> subscribe_message from consumer.consumerBehavior.subscribe.request to server.serverBehavior.subscribing.request {\n\t\t\tevent consumer.subscribe_request[1];\n\t\t\tthen event subscription_interface.subscribe_request[1];\n\t\t\tthen event server.subscribe_request[1];\n\t\t}\n\t\t\n\t\tflow :>> deliver_message from server.serverBehavior.delivering.response to consumer.consumerBehavior.delivery.response {\n\t\t\tevent server.deliver_response[1];\n\t\t\tthen event subscription_interface.deliver_response[1];\n\t\t\tthen event consumer.deliver_response[1];\n\t\t}\n\t}\n}"
    },
    {
      "name": "ServerSequenceOutsideRealization-2",
      "text": "系统应实现一个外部发布/订阅模型的具体化，结合了生产者、服务器和消费者的行为，增强了消息传递和事件处理的细节。该模型通过引入端口、接口、行为和状态机来实现更精确的控制和行为描述。\n\n在该系统中，生产者通过定义一个发布端口来发送发布消息，指定消息的主题和出版物，并通过FIFO顺序确保消息按先后顺序传递。生产者行为通过`producerBehavior`来实现，包括发送发布消息并通过端口发送。\n\n服务器部分定义了两个端口：发布端口和订阅端口。服务器行为由状态机管理，首先等待订阅请求，接收到订阅后转入等待发布状态，并在接收到匹配的发布消息后发送交付消息给订阅者。服务器的状态和行为通过`serverBehavior`定义，确保消息按正确的顺序进行处理。\n\n消费者通过订阅端口向服务器发送订阅消息，并接收交付消息。消费者行为定义在`consumerBehavior`中，确保消费者能够正确地订阅主题并接收相应的交付消息。\n\n此外，系统通过定义消息传输，确保在不同组件之间正确地传递信息。消息绑定确保了生产者、服务器和消费者之间的消息传递行为与指定模型中的事件相匹配。\n\n通过详细的行为定义、消息传递和端口绑定，系统能够确保发布/订阅过程的正确执行，并支持外部系统的集成和控制。",
      "label": "package ServerSequenceOutsideRealization_2 {\n\tprivate import ScalarValues::String;\n\tprivate import ServerSequenceModelOutside::*;\n\tprivate import Configuration::*;\n\t\n\tpackage Configuration {\n\t\t\n\t\tport def PublicationPort;\n\t\t\n\t\tport def SubscriptionPort;\n\t\t\n\t\tpart producer_2[1] {\n\t\t\tattribute someTopic : String;\n\t\t\tprivate item somePublication;\n\t\t\t/* Requiring FIFO sort (as opposed to just default) to make arrival/leave ordering\n\t\t\t * in ServerSequenceModelOutside.sysml equivalent to accept/send ordering in\n\t\t\t * ServerSquenceRealization-2.sysml. */\n\t\t\t:>> incomingTransferSort = Occurrences::earlierFirstIncomingTransferSort;\n\t\t\t\n\t\t\tport publicationPort : ~PublicationPort;\n\t\t\t\n\t\t\tperform action producerBehavior {\n\t\t\t\taction publish send Publish(someTopic, somePublication) via publicationPort;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface producer_2.publicationPort to server_2.publicationPort {\n\t\t\tbind source::outgoingTransfersFromSelf = target::incomingTransfersToSelf;\n\t\t}\n\t\t\n\t\tpart server_2[1] {\n\t\t\tport publicationPort : PublicationPort;\n\t\t\tport subscriptionPort : SubscriptionPort;\n\t\t\t:>> incomingTransferSort = Occurrences::earlierFirstIncomingTransferSort;\n\t\t\t\n\t\t\texhibit state serverBehavior {\n\t\t\t\tentry; then waitForSubscription;\n\t\t\t\t\n\t\t\t\tstate waitForSubscription;\n\t\t\t\ttransition subscribing\n\t\t\t\t\tfirst waitForSubscription\n\t\t\t\t\taccept sub : Subscribe via subscriptionPort\n\t\t\t\t\tthen waitForPublication;\n\t\t\t\t\t\n\t\t\t\tstate waitForPublication;\n\t\t\t\ttransition delivering\n\t\t\t\t\tfirst waitForPublication\n\t\t\t\t\taccept pub : Publish via publicationPort\n\t\t\t\t\tif pub.topic == subscribing.sub.topic\n\t\t\t\t\tdo send Deliver(pub.publication) to subscribing.sub.subscriber\n\t\t\t\t\tthen waitForPublication;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface consumer_2.subscriptionPort to server_2.subscriptionPort {\n\t\t\tbind source::outgoingTransfersFromSelf = target::incomingTransfersToSelf;\n\t\t}\n\t\t\n\t\tpart consumer_2[1] {\n\t\t\tattribute myTopic : String;\n\t\t\t:>> incomingTransferSort = Occurrences::earlierFirstIncomingTransferSort;\n\t\t\t\n\t\t\tport subscriptionPort : ~SubscriptionPort;\n\t\t\t\n\t\t\tperform action consumerBehavior {\n\t\t\t\taction subscribe send Subscribe(myTopic, consumer_2) to server_2;\n\t\t\t\tthen action delivery accept Deliver via consumer_2;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpart realization_2 : PubSubSequence {\n\t\tpart :>> producer :> producer_2;\n\t\tpart :>> server :> server_2;\n\t\tpart :>> consumer :> consumer_2;\n\n\t\tmessage :>> publish_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = producer.publicationPort;\n \t\t\tend :>> target = server.publicationPort;\n \t\t}\n\t\tmessage :>> subscribe_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = consumer.subscriptionPort;\n \t\t\tend :>> target = server.subscriptionPort;\n \t\t}\n\t\tmessage :>> deliver_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = server;\n \t\t\tend :>> target = consumer;\n \t\t}\n \t\t\n \t\t/* Binding sent/accept messages to specification model messages. */\n\t\t  /* Sends */\n \t\tbind producer_2.producerBehavior.publish.sentMessage = publish_message;\n \t\tbind consumer_2.consumerBehavior.subscribe.sentMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.delivering.effect.sentMessage = deliver_message;\n \t\t  /* Accepts */\n \t\tbind consumer_2.consumerBehavior.delivery.acceptedMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.subscribing.accepter.acceptedMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.delivering.accepter.acceptedMessage = publish_message;\n\t}\n}"
    },
    {
      "name": "ServerSequenceModelOutside",
      "text": "系统应扩展并管理一个包含外部序列的发布/订阅模型，该模型基于先前定义的发布/订阅序列模型进行继承和定制。在此扩展版本中，生产者、服务器和消费者的事件发生顺序及其关联的消息传递经过重新定义。\n\n生产者触发发布源事件，并通过发布消息的开始状态与消息流开始交互。服务器则接收到来自消费者的订阅消息，并按照消息的完成状态依次触发订阅目标事件、发布目标事件和交付源事件。消费者接收订阅消息并触发交付目标事件，这些事件的时间顺序与服务器上的操作保持一致，确保了模型中各个角色的协调和信息的顺利传递。\n\n该模型通过显式指定事件顺序和传递状态，进一步增强了系统的时序约束和信息流动的控制。",
      "label": "package ServerSequenceModelOutside {\n\tpublic import ServerSequenceModel::*;\n\n\tpart def PubSubSequenceOutside :> PubSubSequence {\n\t\tpart :>> producer {\n\t\t\tevent publish_source_event = publish_message.start;\n\t\t}\n\t\t\n\t\tpart :>> server {\n\t\t\tevent occurrence :>> subscribe_target_event = subscribe_message.done;\n\t\t\tthen event occurrence :>> publish_target_event = publish_message.done;\n\t\t\tthen event occurrence :>> deliver_source_event = deliver_message.start;\n\t\t}\n\t\t\n\t\tpart :>> consumer {  /* Redundant with timing constraints on server and generic transfers. */\n\t\t\tevent occurrence :>> subscribe_source_event = subscribe_message.start;\n\t\t\tthen event occurrence :>> deliver_target_event = deliver_message.done;\n\t\t}\n\t}\n}"
    },
    {
      "name": "AliasImport",
      "text": "系统应支持通过别名机制简化和重命名模型元素。在该模型中，定义包（Definitions）中定义了一个部件Vehicle，并通过别名将其命名为Car。在使用包（Usages）中，通过导入Definitions包中的Car别名，创建了一个名为vehicle的部件，其实际类型为Vehicle。通过这种方式，系统能够在不同的上下文中使用易于理解的别名，同时保留原始定义的功能和结构。",
      "label": "package AliasImport {\n\tpackage Definitions {\n\t    part def Vehicle;\n\t    \n\t    alias Car for Vehicle;\n\t}\n\t\n\tpackage Usages {\n\t    private import Definitions::Car;\n\t\n\t    part vehicle : Car;\n\t}\n}"
    },
    {
      "name": "CircularImport",
      "text": "系统应支持跨包的循环引用，其中两个包互相导入对方的内容。具体来说，在包P1中导入了包P2，并定义了部件A；而在包P2中导入了包P1，并定义了部件B。接着，在测试包Test1中，通过导入P1可以使用部件A和B，而在Test2中，通过导入P2同样可以访问这两个部件。此外，系统允许在全局范围内直接引用P1中的部件A和部件B，并保证这些引用不会导致循环导入错误，从而确保模型的正确性和稳定性。",
      "label": "package CircularImport {\n\n\tpackage P1 {\n\t\tpublic import P2::*;\n\t\tpart def A;\n\t}\n\tpackage P2 {\n\t\tpublic import P1::*;\n\t\tpart def B;\n\t}\n\tpackage Test1 {\n\t\tpublic import P1::*;\n\t\tpart x: A;\n\t\tpart y: B;\n\t}\n\tpackage Test2 {\n\t\tpublic import P2::*;\n\t\tpart x: A;\n\t\tpart y: B;\n\t}\n\t\n\tpart x: P1::A;\n\t\n\t// The following should not fail.\n\tpart y: P1::B;\n\t\n}"
    },
    {
      "name": "QualifiedNameImportTest",
      "text": "系统应支持通过限定名称导入来管理跨包的部件访问。在该模型中，包P1定义了部件A。包P2包含一个子包P2a，并在P2a中通过公共导入将包P1的所有内容引入。由于P2a导入了P1，部件A成为P2a的一部分，因此可以在包P2中通过限定名称`P2a::A`成功引用部件A。该DSL示例展示了如何使用限定名称导入实现包之间的访问控制，确保导入的部件在子包中可用。",
      "label": "package QualifiedNameImportTest {\n\tpackage P1 {\n\t\tpart def A;\n\t}\n\tpackage P2 {\n\t\tpackage P2a {\n\t\t\tpublic import P1::*;\n\t\t}\n\t\t// The following should not fail.\n\t\t// A is a member of P2a because of the import.\n\t\tpart x: P2a::A;\n\t}\n}"
    },
    {
      "name": "PrivateImportTest",
      "text": "系统应支持在模型中使用私有和公共导入，以控制各个部件和包的可见性。在该模型中，包P1定义了部件A。包P2私有导入P1的所有内容，因此在包P2内部，部件A对其他部件是不可见的。尝试在包外引用P2中的部件A会导致错误，因为P2中的导入是私有的。\n\n此外，包P3定义了部件B，包P2私有导入了包P3的内容，但这种私有导入仅影响包P2之外的可见性。因此，在包P2内部，部件B是可见的，可以成功引用部件B。\n\n在包P4中，通过使用\"public import all\"导入P2中的所有内容，覆盖了P2中私有导入的限制。因此，即使P2中的A在包P2中不可见，在包P4中通过公共导入，部件A变得可见并且可以被引用。\n\n该DSL模型展示了如何通过私有和公共导入机制精确控制不同包之间的可见性和依赖关系。",
      "label": "package PrivateImportTest {\n\tpackage P1 {\n\t\tpart def A;\n\t}\n\tpackage P2 {\n\t\tprivate import P1::*;\n\t}\n\n\tpart x: P1::A;\n\t\n\tpublic import P2::*;\n\t// This should fail.\n\t// A is not visible, because the import in P2 is private.\n\t// part y: A;\n\t// part y1: P2::A;\n\t\n\tpackage P3 {\n\t\tpart def B;\n\t}\n\t\n\tprivate import P3::*;\n\t\n\t// This should not fail.\n\t// Private import only restricts visibility outside the package.\n\tpart z: B;\n\t\n\tpackage P4 {\n\t\tpublic import all P2::*;\n\t\t\n\t\t// This should not fail because \"import all\" overrides private import.\n\t\tpart z1: A;\n\t}\t\n}"
    },
    {
      "name": "Comments",
      "text": "系统应支持在模型中添加多种注释类型，以便对各个模型元素进行详细说明。系统允许在包级别添加文档注释，用于描述整个包的功能和用途；同时，也支持命名注释，以便为特定元素提供标识性说明，并可对这些注释本身进行进一步的说明。在部件定义中，既可以包含文档注释来解释部件的作用，也能嵌入内联注释以及针对其他元素（如所属包）的注释。这种丰富的注释机制提高了模型的可读性和可维护性。",
      "label": "package Comments {\n\tdoc /* Documentation Comment */\n\n\tdoc /* Documentation about Package */\n\n\tcomment cmt /* Named Comment */\t\n\tcomment cmt_cmt about cmt /* Comment about Comment */\n\t\n\tcomment about C /* Documention Comment on Part Def */\n\tpart def C {\n\t\tdoc /* Documentation in Part Def */\n\t\tcomment /* Comment in Part Def */\n\t\tcomment about Comments /* Comment about Package */\n\t}\n}"
    },
    {
      "name": "VehicleVariabilityModel",
      "text": "系统应支持定义不同车辆配置的变异模型，以便灵活定制车辆的部件和功能。具体来说，系统能够根据需求创建不同的车辆部件（如引擎、变速器、天窗等）和部件之间的连接（如引擎与汽缸之间的关系）。对于每个部件，系统应能够定义其属性和变体，例如引擎的气缸数量（4缸或6缸）以及相关的端口和连接接口。\n\n在设计模型中，系统应支持对车辆部件进行树状结构定义。例如，车辆包含引擎、变速器和天窗等部件，并且引擎可以是4缸或6缸引擎，具体配置通过定义不同的变体来实现。变速器也可以是手动或自动变速器，系统能够根据不同的需求选择适合的变速器和引擎组合。\n\n此外，系统应支持定义部件和功能的变异点。例如，在150%模型中，系统应允许对引擎的直径选择进行变异，可以选择小直径或大直径；在引擎为6缸时，还应支持选择不同的端口配置（如autoPort1或autoPort2），并且系统应确保这些变异点之间的约束关系得到满足。类似地，变速器和天窗的选择也可以根据变异模型进行配置。\n\n在动作模型中，系统应能够定义不同的操作（如产生扭矩、放大扭矩、提供动力等）。这些操作可以根据部件配置的变化进行变异。例如，当选择4缸引擎和手动变速器时，系统应执行不同的生成扭矩和放大扭矩的操作，而在选择6缸引擎和自动变速器时，操作应有所不同。通过这些变异模型，系统能够灵活配置车辆的功能，并确保不同配置之间的约束关系得到遵循。\n\n最后，系统应支持根据变异模型创建具体的车辆实例。例如，创建一个4缸手动变速器且没有天窗的车辆配置，并执行相应的操作，如生成和放大扭矩。这样的配置模型能够满足不同用户对车辆配置的个性化需求，同时确保所有部件和操作的兼容性与约束条件。",
      "label": "package VehicleVariabilityModel {\n\n\tpackage DesignModel {\n\t\tpublic import PartDefinitions::*;\n\t\tpublic import PartsTree::*;\n\t\tpublic import ActionDefinitions::*;\n\t\tpublic import ActionTree::*;\n\t\n\t\tpackage PartDefinitions {\n\t\t\tpart def Vehicle;\n\t\t\t\n\t\t    attribute def Diameter;\n\t\t    part def Cylinder {\n\t\t        attribute diameter : Diameter[1];\n\t\t    }\n\t\t\n\t\t    part def Engine;\n\t\t    part def Transmission;\n\t\t    part def Sunroof;\n\t\t\n\t\t    port def AutoPort;\n\t    }\n\t    \n\t    package PartsTree {\n\t    \tpart vehicle : Vehicle {\n\t    \t\tpart engine : Engine[1];\n\t    \t\tpart transmission : Transmission[1];\n\t    \t\tpart sunroof : Sunroof[0..1];\n\t    \t}\n\t    \t\n\t\t    part engine : Engine {\n\t\t        port autoPort : AutoPort;\n\t\t        part cylinder : Cylinder[2..*];\n\t\t    }\n\t\t    \n\t\t    part '4cylEngine' :> engine {\n\t\t    \tpart :>> cylinder[4];\n\t\t    }\n\t\t    \n\t\t    part '6cylEngine' :> engine {\n\t\t    \tpart :>> cylinder[6];\n\t\t    }\n\t\t\n\t\t\tpart transmission : Transmission;\n\t\t    part manualTransmission :> transmission;\n\t\t    part automaticTransmission :> transmission;\n\t    }\n\t\n\t\tpackage ActionDefinitions {   \n\t\t    action def GenerateTorque;\n\t\t    action def AmplifyTorque;\n\t\t    action def ProvidePower;\n\t    }\n\t    \n\t    package ActionTree {    \n\t\t    action generateTorque4Cyl : GenerateTorque;\n\t\t    action generateTorque6Cyl : GenerateTorque;\n\t\t    \n\t\t    action amplifyTorqueManual : AmplifyTorque;\n\t\t    action amplifyTorqueAutomatic : AmplifyTorque;\n\t    }\t\n\t}\n\t\t\n\tpackage '150% Model' {\n\t\tprivate import DesignModel::*;\n\t\n\t\tpackage PartsTree {\n\t\t\n\t\t    // Variation point definitions\n\t\t\n\t\t    variation attribute def DiameterChoices :> Diameter {\n\t\t    \tvariant attribute diameterSmall;\n\t\t    \tvariant attribute diameterLarge;\n\t\t    }\n\t\t\n\t\t    variation part def EngineChoices :> Engine {\n\t\t        variant '4cylEngine';\n\t\t        variant '6cylEngine' {\n\t\t        \tvariation port :>> autoPort {\n\t\t        \t\tvariant port autoPort1;\n\t\t        \t\tvariant port autoPort2;\n\t\t        \t}\n\t\t        \t\n\t\t        \tpart :>> cylinder {\n\t\t        \t\tattribute :>> diameter : DiameterChoices;\n\t\t        \t}\n\t\t        \t\n\t\t          \tassert constraint {\n\t\t            \t(autoPort == autoPort::autoPort1 & cylinder.diameter == cylinder::diameter::diameterSmall) ^\n\t\t             \t(autoPort == autoPort::autoPort2 & cylinder.diameter == cylinder::diameter::diameterLarge)\n\t\t        \t}\n\t\t        }\n\t\t    }\n\t\t\n\t\t    // Part superset model\n\t\t    \n\t\t    abstract part vehicleFamily :> vehicle {\n\t\t    \t// Variation point usage\n\t\t        part :>> engine : EngineChoices[1];\n\t\t        \n\t\t        // Variation point with embedded variant definitions\n\t\t        variation part :>> transmission : Transmission[1] {\n\t\t        \tvariant manualTransmission;\n\t\t        \tvariant automaticTransmission;\n\t\t        }\n\t\t        \n\t\t        assert constraint {\n\t\t            (engine == '4cylEngine' & transmission == transmission::manualTransmission) ^\n\t\t            (engine == '6cylEngine' & transmission == transmission::automaticTransmission)\n\t\t        }\n\t\t        \n\t\t        // Variation point on variant multiplicity (inherited multiplicity is [0..1]) \n\t\t        variation part :>> sunroof {\n\t\t        \tvariant part withSunroof[1];\n\t\t        \tvariant part withoutSunroof[0];\n\t\t        }\n\t\t        \n\t\t        perform ActionTree::providePowerFamily;\n\t\t    }\n\t\t}\n\t\t\n\t\tpackage ActionTree {\n\t\t\n\t\t    // Action superset Model\n\t\t    \n\t\t    action providePowerFamily : ProvidePower {\n\t\t        variation action generateTorque : GenerateTorque {\n\t\t        \tvariant generateTorque4Cyl;\n\t\t        \tvariant generateTorque6Cyl;\n\t\t        }\n\t\t        \n\t\t        variation action amplifyTorque : AmplifyTorque {\n\t\t        \tvariant amplifyTorqueManual;\n\t\t        \tvariant amplifyTorqueAutomatic;\n\t\t        }\n\t\t        \n\t\t\t    assert constraint {\n\t\t\t        (generateTorque == generateTorque::generateTorque4Cyl & \n\t\t\t        \tamplifyTorque == amplifyTorque::amplifyTorqueManual\n\t\t\t        ) xor\n\t\t\t        (generateTorque == generateTorque::generateTorque6Cyl & \n\t\t\t        \tamplifyTorque == amplifyTorque::amplifyTorqueAutomatic\n\t\t\t        )\n\t\t\t    }\t\t   \n\t\t    }\t\t    \n\t\t}\n\t}\n\t\n\tpackage '100% Model' {\n\t\tprivate import '150% Model'::*;\n\t\t\n\t\t// Vehicle instance model\n\t\t\n\t    part vehicle4Cyl :> PartsTree::vehicleFamily {\n\t        part :>> engine = engine::'4cylEngine';\n\t        part :>> transmission = transmission::manualTransmission;\n\t        part :>> sunroof = sunroof::withoutSunroof;\n\t        \n\t        perform action :>> providePowerFamily {\n\t            action :>> generateTorque = generateTorque::generateTorque4Cyl;\n\t            action :>> amplifyTorque = amplifyTorque::amplifyTorqueManual;\n\t        }\n\t    }\n\t}\n}"
    },
    {
      "name": "Dynamics",
      "text": "系统应支持定义多种计算函数（calc）和分析动作（action），以模拟和计算动态过程。每个计算函数可以执行特定的数学操作，例如功率、加速度、速度和位置的计算，并根据输入参数返回相应的结果。这些计算函数帮助建立不同的物理模型，确保系统的动态模拟能够准确反映实际情况。\n\n在系统中，分析动作不仅定义了输入输出参数，还可以使用断言（assert）来确保计算结果符合预期的约束条件。每个分析动作可以根据特定的物理公式进行计算，并通过约束来验证计算的正确性和一致性。通过这种方式，系统能够对复杂的动态过程进行建模，并确保分析过程中的数据和计算结果的正确性。\n\n此外，系统还支持为分析动作创建不同的变体，通过绑定（bind）计算结果到输出参数，进一步提升了系统的灵活性。这些操作可以根据需求动态调整，以适应不同的应用场景和计算需求。",
      "label": "package Dynamics {\n\tprivate import ScalarValues::Real;\n\tprivate import ISQ::*;\n\t\n\t// Function definitions\n\t\n\tcalc def Power {\n\t\tin whlpwr : PowerValue; in Cd : Real; in Cf : Real; in tm : MassValue; in v : SpeedValue;\n\t\treturn tp : PowerValue = whlpwr - Cd * v - Cf * tm * v;\n\t}\n\t\n\tcalc def Acceleration { in dt : TimeValue; in tm : MassValue; in tp: PowerValue; \n\t\treturn a : AccelerationValue = tp * dt * tp;\n\t}\n\t\n\tcalc def Velocity { in dt : TimeValue; in v0 : SpeedValue; in a : AccelerationValue;\n\t\treturn v : SpeedValue = v0 + a * dt;\n\t}\n \t\n\tcalc def Position { in dt : TimeValue; in x0 : LengthValue; in v : SpeedValue; \n\t\treturn x : LengthValue = x0 + v * dt;\n\t}\n\n\t// Analysis action def\n\t\n\taction def StraightLineVehicleDynamics {\n\t\t\n\t\tin attribute dt : TimeValue;\n\t\tin attribute whlpwr : PowerValue;\n\t\tin attribute Cd : Real;\n\t\tin attribute Cf: Real;\n\t\tin attribute tm : MassValue;\n\t\tin attribute v_in : SpeedValue;\n\t\tin attribute x_in : LengthValue;\n\t\t\n\t\tout attribute a_out : AccelerationValue;\n\t\tout attribute v_out : SpeedValue;\n\t\tout attribute x_out : LengthValue;\n\t\t\t\n\t\tassert constraint {\n\t\t\tattribute tp : PowerValue;\n\t\t\t\n\t\t\ttp == Power(whlpwr, Cd, Cf, tm, v_in) &\n\t\t\ta_out == Acceleration(dt, tm, tp) &\n\t\t\tv_out == Velocity(dt, v_in, a_out) &\n\t\t\tx_out == Position(dt, x_in, v_in)\n\t\t}\n\t}\n\t\n\n\t// Analysis actions\n\t\n\taction dyn1 : StraightLineVehicleDynamics {\n        in attribute dt : TimeValue;\n        in attribute whlpwr : PowerValue;\n        in attribute Cd : Real;\n        in attribute Cf: Real;\n        in attribute tm : MassValue;\n        in attribute v_in : SpeedValue;\n        in attribute x_in : LengthValue;\n\n\t\tattribute tp : PowerValue = Power(whlpwr, Cd, Cf, tm, v_in);\n\t\t\n\t\tout attribute :>> a_out : AccelerationValue = Acceleration(dt, tm, tp);\n\t\tout attribute :>> v_out : SpeedValue = Velocity(dt, v_in, a_out);\n\t\tout attribute :>> x_out : LengthValue = Position(dt, x_in, v_in);\n\t}\t\n\t\n\taction dyn2 : StraightLineVehicleDynamics {\n\t\tcalc acc : Acceleration {\n\t\t\tin dt = dyn2::dt;\n\t\t\tin tm = dyn2::tm;\n\t\t\tin tp = Power(whlpwr, Cd, Cf, tm, v_in);\n\t\t}\n\t\tbind a_out = acc.a;\n\t\t\n\t\tcalc vel : Velocity {\n\t\t\tin dt = dyn2::dt;\n\t\t\tin v0 = dyn2::v_in; \n\t\t\tin a = acc.a;\n\t\t}\n\t\tbind v_out = vel.v;\n\t\t\n\t\tcalc pos : Position {\n\t\t\tin dt = dyn2::dt;\n\t\t\tin x0 = dyn2::x_in;\n\t\t\tin v0 = vel.v;\n\t\t}\n\t\tbind x_out = pos.x;\n\t}\n}"
    },
    {
      "name": "Vehicle Analysis Demo",
      "text": "系统应支持对车辆进行详细的燃油经济性分析，并能够模拟和计算不同驾驶条件下的燃油消耗。通过定义多个模块，系统不仅能够描述车辆的物理特性和动态行为，还能够将燃油经济性需求与实际性能相对比，从而判断设计是否满足特定要求。\n\n在该系统中，车辆的各项参数（如质量、轮胎直径、驱动效率等）都可以被精确地建模。燃油箱、轮子等部件也可以通过属性和端口进行定义，并与燃油流动进行交互。车辆的燃油经济性被定义为距离与燃油体积的比率，并通过不同的驾驶场景（如城市驾驶和高速驾驶）来评估。\n\n系统还定义了计算公式和分析模型，例如加速度、速度、位置的计算，通过这些模型能够精确模拟车辆的动态行为。此外，燃油经济性分析通过定义燃油消耗分析和动力学分析相结合，来求解与时间相关的发动机功率，进而估算出实际的燃油经济性。\n\n通过引入需求模型，系统可以明确规定燃油经济性要求，并通过分析结果来验证车辆是否满足这些要求。分析包括根据实际驾驶情景计算车辆的燃油经济性，并与所需的城市和高速公路燃油经济性要求进行比较。这些分析结果为设计优化和决策提供了强有力的支持。",
      "label": "package 'Vehicle Analysis Demo' {\n    private import ScalarValues::*;\n    private import ISQ::*;\n    private import USCustomaryUnits::*;\n\t    \n    private import VehicleQuantities::*;\n    private import VehicleModel::*;\n    private import FuelEconomyRequirementsModel::*;\n    private import DynamicsModel::*;\n    private import FuelEconomyAnalysisModel::*;\t\n\t\n\tpackage VehicleQuantities {\n    \tprivate import Quantities::*;\n    \tprivate import MeasurementReferences::*;\n\n\t    attribute def DistancePerVolumeUnit :> DerivedUnit {\n\t    \tprivate attribute distancePF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = 1; }\n\t        private attribute volumePF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = -3; }\n\t        attribute :>> quantityDimension { :>> quantityPowerFactors = (distancePF, volumePF); }\n\t    }\n\n\t    attribute def DistancePerVolumeValue :> ScalarQuantityValue {\n\t        :>> num : Real;\n\t        :>> mRef : DistancePerVolumeUnit;\n\t    }\n\t    \n\t    attribute gallon : VolumeUnit = 231.0 * 'in' ** 3;\n\t    attribute mpg : DistancePerVolumeUnit = 'mi' / gallon;\n\t}\n\t\n\tpackage VehicleModel {\t    \n\t    item def Fuel;\n\t        \n\t    port def FuelPort {\n\t        out item fuel: Fuel;\n\t    }\n\t    \n\t    part def FuelTank {\n\t        attribute volumeMax : VolumeValue;\n\t        attribute fuelVolume : VolumeValue;\n\t        attribute fuelLevel : Real = fuelVolume / volumeMax;\n\t        \n\t        port fuelInPort : ~FuelPort;\n\t        port fuelOutPort : FuelPort;\n\t    }\n\t    \n\t    part def Wheel {\n\t        attribute diameter : LengthValue;\n\t    }\n\t\n\t    part def Vehicle {\n\t        attribute mass : MassValue;\n\t        attribute cargoMass : MassValue;\n\t        \n\t        attribute wheelDiameter : LengthValue;\n\t        attribute driveTrainEfficiency : Real;\n\t        \n\t        attribute fuelEconomy_city : DistancePerVolumeValue;\n\t        attribute fuelEconomy_highway : DistancePerVolumeValue;\n\t\n\t        port fuelInPort : ~FuelPort;\n\t    }\n\t    \n\t    part vehicle_c1 : Vehicle {\n\t        port :>> fuelInPort {\n\t            in item :>> fuel; \n\t        }\n\t\n\t        part fuelTank : FuelTank {\n\t            port :>> fuelInPort {\n\t                in item :>> fuel;\n\t            }\n\t        }\n\t\n\t        bind fuelInPort.fuel = fuelTank.fuelInPort.fuel;\n\t\n\t        part wheel : Wheel[4] {\n\t            :>> diameter = wheelDiameter;\n\t        }\n\t    }\n\t}\n\t\n\tpackage FuelEconomyRequirementsModel {\n\t    requirement def FuelEconomyRequirement {\n\t        attribute actualFuelEconomy : DistancePerVolumeValue;\n\t        attribute requiredFuelEconomy : DistancePerVolumeValue;\n\t\n\t        require constraint { actualFuelEconomy >= requiredFuelEconomy }\n\t    }\n\t\n\t    requirement cityFuelEconomyRequirement : FuelEconomyRequirement {\n\t        :>> requiredFuelEconomy = 25 [mpg];\n\t    }\n\t\n\t    requirement highwayFuelEconomyRequirement : FuelEconomyRequirement {\n\t        :>> requiredFuelEconomy = 30 [mpg];\n\t    }\n\t}\n\t\n\tpackage DynamicsModel {\n\t    calc def Acceleration { in p : PowerValue; in m : MassValue; in v : SpeedValue;\n\t    \treturn : AccelerationValue = p / (m * v);\n\t    }\n\t    \n\t    calc def Velocity { in v0 : SpeedValue; in a : AccelerationValue; in dt : TimeValue;\n\t    \treturn : SpeedValue = v0 + a * dt;\n\t\t}\n\t\t    \n\t    calc def Position { in x0 : LengthValue; in v : SpeedValue; in dt : TimeValue;\n\t    \treturn : LengthValue = x0 + v * dt;\n\t    }\n\t    \n\t    constraint def StraightLineDynamicsEquations {\n\t        in p : PowerValue;\n\t        in m : MassValue;\n\t        in dt : TimeValue;\n\t        in x_i : LengthValue;\n\t        in v_i : SpeedValue;\n\t        in x_f : LengthValue;\n\t        in v_f : SpeedValue;\n\t        in a : AccelerationValue;\n\t    \n\t        attribute v_avg : SpeedValue = (v_i + v_f)/2;\n\t\n\t        a == Acceleration(p, m, v_avg) &\n\t        v_f == Velocity(v_i, a, dt) &\n\t        x_f == Position(x_i, v_avg, dt)\n\t    }\n\t    \n\t    action def StraightLineDynamics {\n\t        in power : PowerValue;\n\t        in mass : MassValue;\n\t        in delta_t : TimeValue;\n\t        in x_in : LengthValue;\n\t        in v_in : SpeedValue;\n\t        out x_out : LengthValue;\n\t        out v_out : SpeedValue;\n\t        out a_out : AccelerationValue;\n\t    \n\t        assert constraint dynamics : StraightLineDynamicsEquations {\n\t            in p = power;\n\t            in m = mass;\n\t            in dt = delta_t;\n\t            in x_i = x_in;\n\t            in v_i = v_in;\n\t            in x_f = x_out;\n\t            in v_f = v_out;\n\t            in a = a_out;\n\t        }\n\t    }\n\t}\n\t\n\tpackage FuelEconomyAnalysisModel {\n\t    private import SequenceFunctions::size;\n\t    private import SampledFunctions::SampledFunction;\n\t    private import SampledFunctions::SamplePair;\n\t    private import ControlFunctions::forAll;\n\t\n\t\tattribute def ScenarioState {\n\t\t\tposition : LengthValue;\n\t\t\tvelocity : SpeedValue;\n\t\t}\n\t\t\n\t\tattribute def NominalScenario :> SampledFunction {\n\t\t\tattribute def TimeStateRecord :> SamplePair {\n\t\t\t\tt : TimeValue :>> domainValue;\n\t\t\t\ts : ScenarioState :>> rangeValue;\n\t\t\t}\n\t\t\t:>> samples : TimeStateRecord;\n\t\t\tn : Natural = size(samples);\n\t\t}\n\t\t\n\t\tanalysis def FuelEconomyAnalysis { \n\t\t\tsubject vehicle: Vehicle;\n\t\t\tin attribute scenario : NominalScenario;\n\t\t\tin requirement fuelEconomyRequirement : FuelEconomyRequirement;\n\t\t\treturn calculatedFuelEconomy : DistancePerVolumeValue;\n\t\t\t\n\t\t\tobjective fuelEconomyAnalysisObjective {\n\t\t\t\tdoc \n\t\t\t\t/*\n\t\t\t\t * The objective of this analysis is to determine whether the\n\t\t\t\t * current vehicle design configuration can satisfy the fuel\n\t\t\t\t * economy requirement.\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\tassume constraint {\n\t\t\t\t\tvehicle.wheelDiameter == 33 ['in'] &\n\t\t\t\t\tvehicle.driveTrainEfficiency == 0.4\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trequire fuelEconomyRequirement { \n\t\t\t\t\t:>> actualFuelEconomy = calculatedFuelEconomy;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\taction dynamicsAnalysis {\n\t\t\t\tin sc: NominalScenario;\n\t\t\t\tout power : PowerValue[*];\n\t\t\t\tout acceleration : AccelerationValue[*];\n\t\t\t\t/*\n\t\t\t\t * Solve for the required engine power as a function of time\n\t\t\t\t * to support the scenarios.\n\t\t\t\t */\n\t\t\t\tassert constraint straightLineDynamics {\n\t\t\t\t\t(1..sc.n-1)->forAll {in i: Integer;\n\t\t\t\t\t\tprivate thisSample : NominalScenario::TimeStateRecord = \n\t\t\t\t\t\t\tsc.samples#(i);\n\t\t\t\t\t\tprivate nextSample : NominalScenario::TimeStateRecord = \n\t\t\t\t\t\t\tsc.samples#(i+1);\n\t\t\t\t\t\tStraightLineDynamicsEquations (\n\t\t\t\t\t\t\tp = power#(i),\n\t\t\t\t\t\t\tm = vehicle.mass,\n\t\t\t\t\t\t\tdt = nextSample.t - thisSample.t,\n\t\t\t\t\t\t\tx_i = thisSample.s.position,\n\t\t\t\t\t\t\tv_i = thisSample.s.velocity,\n\t\t\t\t\t\t\tx_f = nextSample.s.position,\n\t\t\t\t\t\t\tv_f = nextSample.s.velocity,\n\t\t\t\t\t\t\ta = acceleration#(i)                    \n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t    action fuelConsumptionAnalysis {\n\t\t        in power : PowerValue[*] = dynamicsAnalysis.power;\n\t\t        in acceleration : AccelerationValue[*] = dynamicsAnalysis.acceleration;\n\t\t        out fuelEconomy : DistancePerVolumeValue = calculatedFuelEconomy;\n\t\t        /*\n\t\t         * Solve the engine equations to determine how much fuel is\n\t\t         * consumed. The engine RPM is a function of the speed of the\n\t\t         * vehicle and the gear state.\n\t\t         */\n\t        }\n\t    }\n\t}\n\t\n\tpart vehicleFuelEconomyAnalysisContext {\n\t    requirement vehicleFuelEconomyRequirementsGroup {\n\t        subject vehicle : Vehicle;\n\t\n\t        requirement vehicleFuelEconomyRequirement_city :> cityFuelEconomyRequirement {\n\t            doc /* The vehicle shall provide a fuel economy that is greater than or equal to\n\t             * 25 miles per gallon for the nominal city driving scenarios.\n\t             */\n\t\n\t            :>> actualFuelEconomy = vehicle.fuelEconomy_city;\n\t\n\t            assume constraint { vehicle.cargoMass == 1000 [lb] }\n\t        }\n\t\n\t        requirement vehicleFuelEconomyRequirement_highway :> highwayFuelEconomyRequirement {\n\t            doc /* The vehicle shall provide a fuel economy that is greater than or equal to\n\t             * 30 miles per gallon for the nominal highway driving scenarios.\n\t             */\n\t\n\t            :>> actualFuelEconomy = vehicle.fuelEconomy_highway;\n\t\n\t            assume constraint { vehicle.cargoMass == 1000 [lb] }\n\t        }\n\t\n\t    }\n\t    \n\t    attribute cityScenario : NominalScenario;\n\t    attribute highwayScenario : NominalScenario;\n\t\n\t    analysis cityFuelEconomyAnalysis : FuelEconomyAnalysis {\n\t        subject vehicle = vehicle_c1;\n\t        in attribute scenario = cityScenario;\n\t        in requirement fuelEconomyRequirement = cityFuelEconomyRequirement;\n\t    }\n\t\n\t    analysis highwayFuelEconomyAnalysis : FuelEconomyAnalysis {\n\t        subject vehicle = vehicle_c1;\n\t        in attribute scenario = highwayScenario;\n\t        in requirement fuelEconomyRequirement = highwayFuelEconomyRequirement;\n\t    }\n\t\n\t    part vehicle_c1_analysized :> vehicle_c1 {\n\t        attribute :>> fuelEconomy_city = cityFuelEconomyAnalysis.calculatedFuelEconomy;\n\t        attribute :>> fuelEconomy_highway = highwayFuelEconomyAnalysis.calculatedFuelEconomy;\n\t    }\n\t\n\t    satisfy vehicleFuelEconomyRequirementsGroup by vehicle_c1_analysized;\n\t}\n}"
    },
    {
      "name": "Turbojet Stage Analysis",
      "text": "系统应支持复杂的热力学分析和建模，尤其是在涉及流体动力学和压缩机分析的领域。通过定义热力学函数、理想气体模型以及热力学过程，系统能够模拟和分析气体状态的变化，计算气体的密度、温度、压力、焓等重要参数。\n\n该系统包含多个热力学计算函数，如理想气体定律、可逆绝热压缩等，用于描述气体在不同条件下的行为。同时，系统允许定义气体包裹体（如理想气体包裹体和移动理想气体包裹体），并支持其在不同状态下的属性和过程描述。例如，静压、动压、总压、总温度等参数可以通过计算过程得到，并在分析过程中进行约束和校验。\n\n此外，系统支持复杂的热力学过程建模，包括绝热过程和可逆绝热过程，通过精确的阶段性描述和约束条件管理每个过程的开始和结束状态。\n\n对于低压压缩机分析，系统通过显式绑定和简便的表达式，能够将气体的热力学属性与物理方程结合，从而计算并验证气体在压缩过程中的状态变化。这些计算结果能够作为系统的输入，推动后续的分析与决策，支持不同类型的气动系统建模与仿真。",
      "label": "package 'Turbojet Stage Analysis' {\n\tprivate import Quantities::ScalarQuantityValue;\n\tprivate import MeasurementReferences::DimensionOneValue;\n\tprivate import ISQ::*;\n\t\n\tpackage 'Thermodynamic Functions' {\n\t    calc def 'Ideal Gas Law' { in rho; in R_bar; in T;\n\t    \treturn p = rho * R_bar * T;\n\t    }\n\t    \n\t    calc def 'Reversible Adiabatic Compression Density' { in rho_1; in p_1; in p_2; in gamma;\n\t    \treturn rho_2 = rho_1 * (p_2 / p_1)^(1/gamma);\n\t    }\n\t    \n\t    calc def 'Reversible Adiabatic Compression Temperature' { in T_1; in p_1; in p_2; in gamma;\n\t    \treturn T_2 = T_1 * (p_2 / p_1)**((gamma - 1) / gamma);\n\t    }\n\t    \n\t    calc def 'Total Pressure' { in P_static; in rho; in V;\n\t    \t1/2 * rho * V^2 + P_static\n\t    }\n\t    \n\t    // Showing explicit parameter typing\n\t    calc def 'Total Temperature' { in T_static : TemperatureValue; in Cp : DimensionOneValue; in V : VolumeValue;\n\t    \treturn : TemperatureValue = 1/(2 * Cp) * V^2 + T_static;\n\t    }\n\t    \n\t    calc def 'Total Enthalpy' { in h_total; in h_static; in V;\n\t    \treturn H_total = 1/2 * V^2 + h_static;\n\t    }\n\t}\n\t\n\tpackage 'Thermodynamics Structure' {\n\t    part def 'Ideal Gas Parcel' {\n\t        comment\n\t            /*\n\t            The parcel is an infinitesimal volume used to analyze points in a flow\n\t            */\n\t        attribute 'Molar Mass';\n\t        attribute 'Density';\n\t        attribute 'Pressure';\n\t        attribute 'Temperature';\n\t        attribute 'Enthalpy';\n\t        attribute 'Specific Gas Constant';\n\t    }\n\t    \n\t    part def 'Moving Ideal Gas Parcel' specializes 'Ideal Gas Parcel' {\n\t        comment about 'Stagnation Pressure'\n\t            /*\n\t            Stagnation pressure is the pressure of the parcel if the kinetic energy defined by its\n\t            velocity in a given coordinate frame is converted to gas internal energy through deceleration\n\t            to a velocity that matches the current frame.\n\t            */\n\t        attribute 'Stagnation Pressure';\n\t        attribute 'Stagnation Temperature';\n\t        attribute 'Stagnation Enthalpy';\n\t        \n\t        comment about 'Static Pressure'\n\t            /*\n\t            Static pressure is the pressure of the parcel as it moves\n\t            */\n\t        attribute 'Static Pressure' redefines 'Ideal Gas Parcel'::'Pressure';\n\t        attribute 'Static Temperature' redefines 'Ideal Gas Parcel'::'Temperature';\n\t        attribute 'Static Enthalpy' redefines 'Ideal Gas Parcel'::'Enthalpy';\n\t    }\n\t    \n\t    action def 'Thermodynamic Process'; // need start and end shots to show beginning and end attributes\n\t    \n\t    action def 'Adiabatic Process' specializes 'Thermodynamic Process' {\n\t        /*\n\t        Thermodynamic process typically have their states defined at beginning and end\n\t        of the process (since these starts are path-independent)\n\t        */\n\t        action 'Stage 1' :>> start;\n\t        action 'Stage 2' :>> done;\n\t    }\n\t    \n\t    action def 'Reversible Adiabatic Process' specializes 'Adiabatic Process';\n\t}\n\t\n\tpackage 'Low-Pressure Compressor Analysis' {\n\t    \n\t    part 'Analysis Context' {\n\t        private import 'Thermodynamic Functions'::*;\n\t        \n\t        part 'Inlet Gas' : 'Thermodynamics Structure'::'Moving Ideal Gas Parcel' {\n\t        \t// Explicit binding notation\n\t        \tcalc 'Solve for Pressure1' : 'Ideal Gas Law';\n\t        \tbind 'Density' = 'Solve for Pressure1'.rho;\n\t        \tbind 'Specific Gas Constant' = 'Solve for Pressure1'.R_bar;\n\t        \tbind 'Static Temperature' = 'Solve for Pressure1'.T;\n\t        \tbind 'Static Pressure' = 'Solve for Pressure1'.p;\t        \t\n\t        \t\n\t        \t// Shorthand parameter binding notation\n\t            calc 'Solve for Pressure2' : 'Ideal Gas Law' {\n\t                in rho = 'Density';\n\t                in R_bar = 'Specific Gas Constant';\n\t                in T = 'Static Temperature';\n\t\t\t\t}\t\t\t\t\n\t\t\t\t            \n\t            // Invocation expression notation\n\t            attribute :>> 'Static Pressure' = 'Ideal Gas Law'('Density', 'Specific Gas Constant', 'Static Temperature');\n\n\t            // Equation as a constraint (note \"==\")\n\t            constraint { 'Static Pressure' == 'Ideal Gas Law'('Density', 'Specific Gas Constant', 'Static Temperature') }\n\t        }\n\t    }\n\t}\t\n\t\n}"
    },
    {
      "name": "AnalysisAnnotation",
      "text": "系统应支持定义带有元数据的操作（action），并通过元数据标注工具执行信息，以确保与外部工具的集成和数据交换。每个操作可以定义输入和输出参数，这些参数通过工具变量注释与外部工具中的变量进行关联，从而便于与其他分析工具进行交互。 在该系统中，操作的输入和输出参数不仅具有明确的数据类型，还能够为外部工具提供必要的上下文信息，确保数据在不同工具间传递时的准确性和一致性。通过这种方式，系统能够灵活地与分析工具进行协同工作，实现复杂的计算和数据处理任务。",
      "label": "package AnalysisAnnotation {\n\tprivate import ScalarValues::Real;\n\tprivate import AnalysisTooling::*;\n\tprivate import ISQ::*;\n\taction def ComputeDynamics {\n\t\tmetadata ToolExecution {\n\t\t\ttoolName = \"ModelCenter\";\n\t\t\turi = \"aserv://localhost/Vehicle/Equation1\";\n\t\t}\t\n\t\tin dt : TimeValue             { @ToolVariable { name = \"deltaT\"; } }\n\t\tin whlpwr : PowerValue        { @ToolVariable { name = \"power\"; } }\n\t\tin Cd : Real                  { @ToolVariable { name = \"C_D\"; } }\n\t\tin Cf: Real                   { @ToolVariable { name = \"C_F\"; } }\n\t\tin tm : MassValue             { @ToolVariable { name = \"mass\"; } }\n\t\tin v_in : SpeedValue          { @ToolVariable { name = \"v0\"; } }\n\t\tin x_in : LengthValue         { @ToolVariable { name = \"x0\"; } }\n\t\tout a_out : AccelerationValue { @ToolVariable { name = \"a\"; } }\n\t\tout v_out : SpeedValue        { @ToolVariable { name = \"v\"; } }\n\t\tout x_out : LengthValue       { @ToolVariable { name = \"x\"; } }\t\t\t\n\t}\n}"
    },
    {
      "name": "HSUVDynamics",
      "text": "系统应能够定义和管理与车辆动力学相关的属性和约束。每个车辆应具备以下基本属性：马力、重量、加速度、速度、行驶距离和时间。这些属性将用于计算和模拟车辆的动力学行为。\n\n系统应支持一系列与车辆动力学相关的约束，包括功率方程、位置方程、速度方程和加速度方程。功率方程描述了车辆的马力与空气阻力、滚动阻力和重量之间的关系；位置方程计算了车辆的行驶位置变化，基于时间步长和速度；速度方程则基于加速度计算车辆的速度变化；加速度方程描述了车辆的加速度如何与马力和重量相关联。\n\n系统应能够支持直线行驶的车辆动力学模型，这一模型将包括所有相关的约束，确保在模拟车辆行驶时能够根据给定的参数（如时间步长、马力、空气阻力、滚动阻力和重量）动态计算和更新车辆的速度、位置和加速度。这些约束应互相配合，确保车辆在模拟过程中能够遵循物理定律和动力学规律。",
      "label": "package HSUVDynamics {\n\tprivate import ScalarValues::*;\n\tprivate import SequenceFunctions::size;\n\tprivate import ControlFunctions::*;\n\t\n\tattribute def Horsepwr :> Real;\n\tattribute def Weight :> Real;\n\tattribute def Accel :> Real;\n\tattribute def Vel :> Real;\n\tattribute def Dist :> Real;\n\tattribute def Time :> Real;\n\t\n\tconstraint def PowerEquation {\n\t\tattribute whlpwr : Horsepwr;\n\t\tattribute Cd : Real;\n\t\tattribute Cf : Real;\n\t\tattribute tw : Weight;\n\t\tattribute tp : Horsepwr;\n\t\tattribute v : Vel;\n\t\t\n\t\ttp == whlpwr - Cd * v - Cf * tw * v\n\t}\n\t\n\tconstraint def PositionEquation {\n\t\tattribute dt : Time;\n\t\tattribute v : Vel[0..*] ordered;\n\t\tattribute x : Dist[0..*] ordered;\n\t\t\n\t\t(1..size(x)-1)->forAll {in n : Natural; x#(n + 1) == x#(n) + v#(n) * (5280/3600) * dt}\n\t}\n\t\n\tconstraint def VelocityEquation {\n\t\tattribute dt : Time;\n\t\tattribute v : Vel[0..*] ordered;\n\t\tattribute a : Accel;\n\t\t\n\t\t(1..size(v)-1)->forAll {in n: Natural; v#(n + 1) == v#(n) + a * 32 * (3600/5280) * dt}\n\t}\n\t\n\tconstraint def AccelerationEquation {\n\t\tattribute tw : Weight;\n\t\tattribute dt : Time;\n\t\tattribute tp : Horsepwr;\n\t\tattribute a : Accel;\n\t\t\n\t\ta == (550/32) * tp * dt * tw\n\t}\n\t\n\tconstraint def StraightLineVehicleDynamics {\n\t\tattribute dt : Time;\n\t\tattribute whlpwr : Horsepwr;\n\t\tattribute Cd : Real;\n\t\tattribute Cf: Real;\n\t\tattribute tw : Weight;\n\t\tattribute a : Accel;\n\t\tattribute v : Vel[0..*] ordered;\n\t\tattribute x : Dist[0..*] ordered;\n\t\t\n\t\tconstraint pwr : PowerEquation {\n\t\t\tattribute redefines whlpwr = StraightLineVehicleDynamics::whlpwr;\n\t\t\tattribute redefines Cd = StraightLineVehicleDynamics::Cd;\n\t\t\tattribute redefines Cf = StraightLineVehicleDynamics::Cf;\n\t\t\tattribute redefines tw = StraightLineVehicleDynamics::tw;\n\t\t\tattribute redefines v = vel.v;\n\t\t\tattribute redefines tp;\n\t\t}\n\t\t\n\t\tconstraint acc : AccelerationEquation {\n\t\t\tattribute redefines tp = pwr.tp;\n\t\t\tattribute redefines tw = StraightLineVehicleDynamics::tw;\n\t\t\tattribute redefines dt = StraightLineVehicleDynamics::dt;\n\t\t\tattribute redefines a = StraightLineVehicleDynamics::a;\n\t\t}\n\t\t\n\t\tconstraint vel : VelocityEquation {\n\t\t\tattribute redefines a = acc.a;\n\t\t\tattribute redefines v = StraightLineVehicleDynamics::v;\n\t\t\tattribute redefines dt = StraightLineVehicleDynamics::dt;\n\t\t}\n\t\t\n\t\tconstraint pos : PositionEquation {\n\t\t\tattribute redefines v = vel.v;\n\t\t\tattribute redefines x = StraightLineVehicleDynamics::x;\n\t\t\tattribute redefines dt = StraightLineVehicleDynamics::dt;\n\t\t}\n\t}\n\t\t\n}"
    },
    {
      "name": "Vehicle Decomposition - Updated",
      "text": "系统应能够定义一个完整的车辆结构，并支持多种车辆模型的配置。每辆车应包括车身组件、引擎组件和多个轮子。车身组件应包含车架和轮子，轮子应具有螺栓连接，并且每个车轮的螺栓数量可以在一定范围内调整。车身还应支持不同类型的防滚架，如重型防滚架和轻型防滚架，用户可以根据需求选择适当的防滚架。\n\n引擎组件应包括多个气缸，气缸的数量可以根据不同的车型进行定义。车辆模型应允许对车身和引擎组件进行重新定义，以支持不同的配置要求。例如，在一个特定的车型中，可以选择更少的防滚架、更少的气缸数或更少的螺栓数量，从而确保不同车辆模型之间的灵活性和适应性。\n\n此外，系统应支持对每种车型的具体部件进行约束，例如，确保车轮上有一定数量的螺栓，并且约束总的螺栓数量或每个车轮的螺栓数量。通过这种方式，系统能够管理多种车辆模型，确保不同配置下的部件正确组装和协调运作。",
      "label": "package 'Vehicle Decomposition - Updated' {\n\tdoc\n\t/*\n\t * Example from the SysML 1.6 spec, subclause 8.4.5 Constraining Decomposition,\n\t * updated for usage-focused approach.\n\t */\n\t\n\t// Blocks\n\t\n\tpart def Vehicle;\n\t\n\tpart def 'Chassis Assembly';\n\t\n\tpart def Wheel;\n\t\n\tpart def LugBolt;\n\t\n\tpart def RollBar;\n\tpart def HeavyRollBar :> RollBar;\n\tpart def LightRollBar :> RollBar;\n\t\n\tpart def Engine;\n\t\n\tpart def Cylinder;\n\t\n\t// Parts\n\t\n\tpart vehicle : Vehicle {\n\t\tpart chs : 'Chassis Assembly'[1] {\n\t\t\tpart rb : RollBar[0..1];\n\t\t\tpart w : Wheel[4] {\n\t\t\t\tpart lb : LugBolt[6..10];\n\t\t\t}\n\t\t}\n\t\tpart eng: Engine[1] {\n\t\t\tpart cyl : Cylinder[4..8];\n\t\t}\n\t}\n\t\n\t\n\tpart 'vehicle model 1' :> vehicle {\n\t\tpart redefines chs {\n\t\t\tpart redefines rb : LightRollBar[0..1];\n\t\t\tpart redefines w {\n\t\t\t\tpart redefines lb;\n\t\t\t}\n\t\t}\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[4];\n\t\t}\n\t\t\n\t\t// Constrains total number of lugbolts.\n\t\tref lugBolts[24] = chs.w.lb;\n\t}\n\t\n\tpart 'vehicle model 2' :> vehicle {\n\t\tpart redefines chs {\n\t\t\tpart redefines rb[0];\n\t\t\tpart redefines w {\n\t\t\t\t// Constrains number of lugbolts per wheel.\n\t\t\t\tpart redefines lb[6..7];\n\t\t\t}\n\t\t}\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[6..8];\n\t\t}\n\t}\n}"
    },
    {
      "name": "Vehicle Decomposition",
      "text": "系统应能够定义一个车辆实体，其中包含车架组件、引擎和多个部件。车辆的车架应包括四个轮子和最多一个防滚架，防滚架可以是重型或轻型，用户可以根据需要选择不同的防滚架类型。每个轮子应包含多个螺栓，螺栓数量可以在一定范围内配置。\n\n车辆的引擎组件应包括四到八个气缸，气缸数量可根据不同的车型进行调整。气缸数量的配置应在系统中进行约束，并能根据不同车辆的需求进行灵活调整。\n\n系统应支持不同的车辆模型，每个模型可以重新定义车架组件、引擎组件及其子部件。例如，在一个车辆模型中，气缸数量可以选择为四个，防滚架类型可以为轻型，而螺栓数量则可以设定为24个。另一个车型则可能选择更多的气缸和不同数量的防滚架及螺栓。系统应允许通过灵活的配置选项，实现车辆各部件的组合和配置，确保不同车型能够满足特定的功能和设计要求。",
      "label": "package 'Vehicle Decomposition' {\n\tdoc\n\t/*\n\t * Example from the SysML 1.6 spec, subclause 8.4.5 Constraining Decomposition.\n\t */\n\t\n\tpart def Vehicle {\n\t\tpart chs : 'Chassis Assembly'[1] {\n\t\t\tpart rb redefines 'Chassis Assembly'::rb;\n\t\t\tpart redefines w {\n\t\t\t\tpart redefines lb;\n\t\t\t}\n\t\t}\n\t\tpart eng : Engine[1] {\n\t\t\tpart cyl redefines Engine::cyl;\n\t\t}\n\t\t\n\t\tref cylinderBR[*] = eng.cyl;\n\t\tref rollBarBR[*] = chs.rb;\n\t\tref lugBoltBR[24..32] = chs.w.lb;\n\t}\n\t\n\tpart def 'Chassis Assembly' {\n\t\tpart w : Wheel[4];\n\t\tpart rb : RollBar[0..1];\n\t}\n\t\n\tpart def Wheel {\n\t\tpart lb : LugBolt[6..10];\n\t}\n\t\n\tpart def LugBolt;\n\t\n\tpart def RollBar;\n\tpart def HeavyRollBar :> RollBar;\n\tpart def LightRollBar :> RollBar;\n\t\n\tpart def Engine {\n\t\tpart cyl : Cylinder[4..8];\n\t}\n\t\n\tpart def Cylinder;\n\t\n\tpart def 'Vehicle Model 1' :> Vehicle {\n\t\tref redefines cylinderBR[4];\n\t\tref redefines rollBarBR : LightRollBar[*];\n\t\tref redefines lugBoltBR[24];\n\t}\n\t\n\tpart def 'Vehicle Model 2' :> Vehicle {\n\t\tref redefines cylinderBR[6..8];\n\t\tref redefines rollBarBR[0];\n\t\tref redefines lugBoltBR[24..28]; // 6..7 per wheel\n\t}\n}"
    },
    {
      "name": "Wheel Package",
      "text": "系统应能够定义并管理一个完整的轮毂组件。每个轮毂组件应包含多个部件，包括轮组、轮胎、轮子、螺栓连接、无线气压监控器等。每个轮毂组件应包括一个轮组部件，轮组应能够定义轮胎、轮缘和气压，轮胎部件应能够指定轮胎的规格，并且能够执行装配操作。轮胎珠应与轮缘通过气压座连接。\n\n轮毂组件还应包括多个螺栓连接，这些连接通过螺栓孔与轮毂和轮子进行固定。螺栓连接的部件应包括螺栓安装孔和带螺纹孔，确保能够进行螺栓固定，并且这些连接应具有扭矩和拉力的属性。无线气压监控器应能传输气压信息，确保及时监测轮胎气压的变化。\n\n此外，轮毂组件还应包含平衡重、气门和轮毂。平衡重可以根据需要安装多个，而气门则用于调节和监控气压。整个轮毂组件的结构应确保各个部件正确连接并发挥其作用，保证车辆在运行过程中的稳定性和安全性。",
      "label": "package 'Wheel Package' {\n\tdoc\n\t/*\n\t * Example from the SysML 1.6 spec, subclause 8.4.1 Wheel Hub Assembly.\n\t */\n\n\tprivate import ISQ::*;\n\t\n\tpressure = force / length^2; \n\t\n\tpart def WheelHubAssembly {\n\t\tpart wheel: WheelAssembly[1];\n\t\tpart lugBoltJoints: LugBoltJoint[5] {\n\t\t\tref redefines threadedHole subsets hub.h;\n\t\t\tref redefines mountingHole subsets wheel.w.mountingHoles;\n\t\t}\n\t\tpart hub: Hub[1];\n\t}\n\t\n\tpart def WheelAssembly {\n\t\tinflationPressure :> pressure;\n\t\t\n\t\tpart t: Tire[1] {\n\t\t\tpart bead redefines Tire::bead;\n\t\t}\n\t\tpart w: Wheel[1] {\n\t\t\tpart rim redefines Wheel::rim;\n\t\t}\t\t\n\t\t\t\t\n\t\tconnection : PressureSeat connect t.bead to w.rim;\t\t\n\t}\n\t\n\tpart def Tire {\n\t\ttireSpecification : ScalarValues::String;\n\t\t\n\t\tpart bead : TireBead[2];\n\t\t\n\t\taction mountTire;\n\t}\n\t\n\tpart def TireBead;\n\t\n\tconnection def PressureSeat {\n\t\tend : TireBead[1];\n\t\tend : TireMountingRim[1];\n\t}\n\t\n\tpart def Wheel {\n\t\tdiameter :> length;\n\t\twidth :> length;\n\t\t\n\t\tpart rim : TireMountingRim[2];\n\t\tpart v : InflationValve[1];\n\t\tpart weight : BalanceWeight[0..6];\n\t\tpart mountingHoles : LugBoltMountingHole[5];\n\t}\n\t\n\tconnection def BandMount {\n\t\tend : Wheel[1];\n\t\tend : WirelessTirePressureMonitor[1];\n\t}\n\t\n\tpart def WirelessTirePressureMonitor {\n\t\taction transmitPressure;\n\t}\n\t\n\tpart def TireMountingRim;\n\t\n\tpart def InflationValve;\n\t\n\tpart def BalanceWeight;\n\t\n\tpart def LugBoltMountingHole {\n\t\tlugBoltSize :> length;\n\t}\n\t\n\tpart def LugBoltJoint {\n\t\ttorque :> ISQ::torque;\n\t\tboltTension :> force;\n\t\t\n\t\tref mountingHole: LugBoltMountingHole[1];\n\t\tref threadedHole: LugBoltThreadableHole[1];\n\t}\n\t\n\tpart def Hub {\n\t\tpart h: LugBoltThreadableHole[5];\n\t}\n\t\n\tpart def LugBoltThreadableHole {\n\t\tlugBoltSize :> length;\n\t\tthreadSize :> length;\n\t}\n\t\n}"
    },
    {
      "name": "Wheel Package - Updated",
      "text": "系统应支持轮毂组件的定义及其相关部件的管理。每个轮毂组件应包括多个部件，其中包括轮子、轮胎、轮毂和螺栓等。这些部件应能够通过指定的连接进行关联，确保轮毂系统能够完整地描述各个部件之间的结构和功能。\n\n系统应能够定义不同的部件，例如轮胎、轮子、气压监控器和气门等。轮胎应具备规格信息，并能够执行装配操作，而轮子应具备直径和宽度的属性。气压监控器应能够传输轮胎气压信息，而气门则负责充气操作。轮胎和轮子通过特定的连接（如气压座连接）与轮毂组件关联，从而形成完整的轮毂系统。\n\n此外，系统应支持对轮毂部件进行详细管理。例如，系统能够定义并管理轮毂螺栓的安装孔、螺纹孔以及螺栓的扭矩和拉力等参数，以确保轮毂的安装和使用符合预期的标准。通过对这些部件和连接的定义，系统能够提供准确的轮毂组件装配和操作模型。",
      "label": "package 'Wheel Package - Updated' {\n\tdoc\n\t/*\n\t * Example from the SysML 1.6 spec, subclause 8.4.1 Wheel Hub Assembly.\n\t */\n\n\tprivate import ISQ::*;\n\t\n\t// Quantities\n\t\n\tpressure = force / length^2; \n\t\n\t// Blocks\n\t\n\tpart def WheelHubAssembly;\n\tpart def WheelAssembly {\n\t\tinflationPressure :> pressure;\n\t}\n\t\n\tpart def Tire {\n\t\ttireSpecification : ScalarValues::String;\t\t\n\t\taction mountTire; // Should be operation\n\t}\n\t\n\tpart def TireBead;\n\t\n\tconnection def PressureSeat {\n\t\tend : TireBead[1];\n\t\tend : TireMountingRim[1];\n\t}\n\t\n\tpart def Wheel {\n\t\tdiameter :> length;\n\t\twidth :> length;\t\t\n\t}\n\t\n\tconnection def BandMount {\n\t\tend : Wheel[1];\n\t\tend : WirelessTirePressureMonitor[1];\n\t}\n\t\n\tpart def WirelessTirePressureMonitor {\n\t\taction transmitPressure; // Should be operation\n\t}\n\t\n\tpart def TireMountingRim;\n\t\n\tpart def InflationValve;\n\t\n\tpart def BalanceWeight;\n\t\n\tpart def LugBoltMountingHole {\n\t\tlugBoltSize :> length;\n\t}\n\t\n\tpart def LugBoltJoint {\n\t\ttorque :> ISQ::torque;\n\t\tboltTension :> force;\n\t}\n\t\n\tpart def Hub;\n\t\n\tpart def LugBoltThreadableHole {\n\t\tlugBoltSize :> length;\n\t\tthreadSize :> length;\n\t}\n\t\n\t// Parts\n\t\n\tpart wheelHubAssembly: WheelHubAssembly {\n\t\tpart wheel: WheelAssembly[1] {\n\t\t\tpart t: Tire[1] {\n\t\t\t\tpart bead : TireBead[2];\t\t\t\n\t\t\t}\n\t\t\tpart w: Wheel[1] {\n\t\t\t\tpart rim : TireMountingRim[2];\n\t\t\t\tpart v : InflationValve[1];\n\t\t\t\tpart weight : BalanceWeight[0..6];\n\t\t\t\tpart mountingHoles : LugBoltMountingHole[5];\n\t\t\t}\t\t\t\t\t\t\n\t\t\tconnection : PressureSeat connect t.bead to w.rim;\t\t\n\t\t}\n\t\tpart lugBoltJoints: LugBoltJoint[5] {\t\t\t\t\t\n\t\t\tref mountingHole: LugBoltMountingHole[1] subsets wheel.w.mountingHoles;\n\t\t\tref threadedHole: LugBoltThreadableHole[1] subsets hub.h;\n\t\t}\n\t\tpart hub: Hub[1] {\n\t\t\tpart h: LugBoltThreadableHole[5];\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "AHFProfileLib",
      "text": "系统应支持复杂的系统和服务定义，允许构建基于本地云计算架构的多层次系统模型。每个服务都具有明确的定义，包含服务的名称、URL以及协议类型（例如REST或MQTT）。通过定义系统、局部云设计和服务接口的结构，系统能够支持不同级别的描述和设计。\n\n在系统设计层次上，定义了多个与系统相关的部件和端口，包括局部云的设计、系统定义和服务定义。局部云由多个系统组成，而每个系统都可以包含多个服务接口。服务接口具有详细的设计描述，并可根据不同的协议进行定制。\n\n此外，系统还支持描述和管理系统的元数据，通过使用语义元数据模型，能够标注和定义每个元素的具体语义，确保系统的可互操作性与可扩展性。通过这种方式，系统可以灵活地支持各种服务定义和接口设计，使得复杂的系统和服务能够在同一平台上进行建模、分析和部署。",
      "label": "library package AHFProfileLib {\n\t// Systems and Services and their functionalities\n\tprivate import ScalarValues::*;\n\t\n\t// Design level\n\tport def SD{\n\t\tdoc /* Service definition */\n\t\t\n\t\tattribute serviceDefinition:String;\n\t\tattribute serviceURL:String;\n\t\tattribute intrfce_protocol:String; // which may be \"REST\" or \"MQTT\" etc.\t\t \n\t}\t\n\t\t\n\tpart def SysLocalCloudsDesign {\n\t\tdoc /* System of Systems Definition */\t\n\n\t\t// System of Local Clouds \n\t\tpart locclouds:LocalCloudDesign[1..*];\n\t}\n\t\n\tpart system_of_systems:SysLocalCloudsDD; // defining a top level usage\n\t\n\tpart def LocalCloudDesign {\n\t\tdoc /* Local Cloud definition */\n\n\t\tpart systems:SysD[1..*];\t\n\t}\n\n\tpart def SysD {\n\t\tdoc /* System definitions */\t\n\n\t\tport services: SD[1..*];\n\t\tattribute systemname: String;\n\t\tattribute address: String;\n\t\tattribute portno: Integer;\n\t}\t\n\n\t// Design Description level\n\tport def IDD :> SD{\n\t\tdoc /* Interface Design Description of services */\n\t\t\n\t\tattribute encoding_kind:String;\n\t}\n\t\n\tport def SDDD :> SD{\n\t\tdoc /* Service Definition Design Description */\n\t\t\n\t\tport idds:IDD[*]; // nested protocol-specific services\n\t}\t\n\n\tpart def SysLocalCloudsDD :> SysLocalCloudsDesign {\n\t\tdoc /* System of Systems Detailed Description */\t\n\n\t\tpart :>> locclouds:LocalCloudDD[1..*]; // the descriptions\n\t}\n\n\tpart def LocalCloudDD :> LocalCloudDesign {\n\t\tpart :>> systems:SysDD[1..*];\n\t}\n\n\tpart def SysDD :> SysD{\n\t\tdoc /* System Detailed Description */\n\n\t\tport :>> services:SDDD;\n\t\taction ServiceMethod[1..*]; //means general behaviors\n\t}\n}\n\nlibrary package AHFProfileMetadata{\n\tprivate import Metaobjects::SemanticMetadata;\n\tprivate import AHFProfileLib::*;\n\n\tport global_sd:SD;\n\tmetadata def <service> SDMetadata :> SemanticMetadata{\n\t\t// :>> baseType = system_of_systems.locclouds.systems.services meta SysML::PortUsage;\n\t\t// :>> baseType = SysD::services meta SysML::PortUsage;\n\t\t:>> baseType default global_sd meta SysML::PortUsage;\n\t}\n\t\n\tmetadata def <sos> SysLocalCloudsMetadata :> SemanticMetadata{\n\t\t:>> baseType = system_of_systems meta SysML::PartUsage;\n\t}\n\t\n\tmetadata def <cloud> LocalCloudsMetadata :> SemanticMetadata{\n\t\t:>> baseType default system_of_systems::locclouds meta SysML::PartUsage;\n\t}\n\t\n\tmetadata def <system> SysDMetadata :> SemanticMetadata{\n\t\t:>> baseType default system_of_systems::locclouds::systems meta SysML::PartUsage;\n\t\t// :>> baseType default LocalCloudDesign::systems meta SysML::PartUsage;\n\t}\n\n\tmetadata def <idd> IDDMetadata :> SDMetadata{\n\t\t// :>> baseType = system_of_systems.locclouds.systems.services.idd meta SysML::PortUsage;\n\t\t:>> baseType = SDDD::idds meta SysML::PortUsage;\n\t\t// :>> global_sddd.idd;\n\t}\n\n\tport global_sddd:SDDD;\n\tmetadata def <servicedd> SDDDMetadata :> SDMetadata {\n\t\t// :>> baseType = system_of_systems.locclouds.systems.services meta SysML::PortUsage;\n\t\t:>> baseType = global_sddd meta SysML::PortUsage;\n\t}\n\t\n\tmetadata def <clouddd> LocalCloudsDDMetadata :> LocalCloudsMetadata{\n\t\t:>> baseType = system_of_systems::locclouds meta SysML::PartUsage;\n\t}\n\t\n\tpart global_clouddd:LocalCloudDD;\n\tpart global_systemsdd:SysDD;\n\tmetadata def <systemdd> SysDDMetadata :> SysDMetadata{\n\t\t// :>> baseType = system_of_systems.locclouds.systems meta SysML::PartUsage;\n\t\t//:>> baseType = LocalCloudDD::systems meta SysML::PartUsage;\n\t\t:>> baseType = global_systemsdd meta SysML::PartUsage;\n\t}\t\n\t\n}"
    },
    {
      "name": "AHFSequences",
      "text": "系统应支持在挪威案例中使用Arrowhead框架描述局部云内各个系统和服务之间的消息交互序列。系统定义了不同的参与者，包括TellU消费者、APIS提供者、MQTT服务器和APIS消费者，每个参与者均具有明确的事件发生顺序。系统首先描述了TellU消费者在两个调用和响应阶段内依次触发消息，随后APIS提供者在接收到调用请求后依次执行发布、接收、发送和返回确认的过程。MQTT服务器在此过程中承担消息转发功能，接收来自APIS提供者的发布消息和APIS消费者的订阅请求，并通过两次转发确保消息能够正确传递。APIS消费者在接收到转发后的消息后，执行相应的订阅处理，并完成消息的最终确认。 \n\n此外，系统定义了一个接口，将各参与者的端口进行连接，通过HTTP和MQTT协议实现消息传递。该接口详细描述了各个消息类型的传输方向和调用顺序，明确了从调用开始到响应结束的各个阶段顺序，从而确保整个消息传输过程具有严格的时序要求和正确的消息绑定。",
      "label": "// ** This is the Norwegian use-case for Arrowhead Framework */\npackage AHFNorwaySequences {\n\t// Here we show sequences of the Norwegian use-case\n\tprivate import AHFProfileLib::*;\n\tprivate import AHFCoreLib::*;\n\tprivate import AHFNorway::*;\n\tprivate import ScalarValues::*;\n\t\n\tpart AHFN_LocalCloudDD_Seqs = AHFNorway_LocalCloudDD{\n\t\toccurrence def APIS_transfer_lifetime {\t\t\t\n\t\t\t// lifetime orderings \n\t\t\tref part tlc = AHFNorway_LocalCloudDD.TellUConsumer{\n\t\t\t\tevent occurrence call_getItems1;\n\t\t\t\tthen event occurrence return_getItems1;\n\t\t\t\tevent occurrence call_getItems2;\n\t\t\t\tthen event occurrence return_getItems2;\n\t\t\t}\n\t\t\tref part apsp = AHFNorway_LocalCloudDD.APISProducer{\n\t\t\t\tevent occurrence send_publish_returnallitems;\n\t\t\t\tthen event occurrence receive_call_getItems1;\n\t\t\t\tthen event occurrence send_returnallitems1;\n\t\t\t\tthen event occurrence return_getItems_ack1;\n\t\t\t\tthen event occurrence receive_call_getItems2;\n\t\t\t\tthen event occurrence send_returnallitems2;\n\t\t\t\tthen event occurrence return_getItems_ack2;\n\t\t\t}\n\t\t\tref part mqtts = AHFNorway_LocalCloudDD.MQTTServer{\n\t\t\t\tevent occurrence receive_publish_returnallitems;\n\t\t\t\tthen event occurrence receive_subscribe_returnallitems;\n\t\t\t\tthen event forw1:MQTTforwarding;\n\t\t\t\tthen event forw2:MQTTforwarding;\n\t\t\t}\n\t\t\tref part apsc = AHFNorway_LocalCloudDD.APISConsumer{\n\t\t\t\tevent occurrence send_subscribe_returnallitems;\n\t\t\t\tthen event forw1:MQTTforwarding;\n\t\t\t\tthen event forw2:MQTTforwarding;\n\t\t\t}\n\t\t\toccurrence forw1:MQTTforwarding;\t\n\t\t\toccurrence forw2:MQTTforwarding;\t\n\n\t\t\tmessage publish_returnallitems of Publish\n\t\t\tfrom apsp.send_publish_returnallitems to mqtts.receive_publish_returnallitems;\n\t\t\tmessage subscribe_returnallitems of Subscribe\n\t\t\tfrom apsc.send_subscribe_returnallitems to mqtts.receive_subscribe_returnallitems;\n\t\t\tmessage call_getItems1 of CallGiveItems[1]\n\t\t\tfrom tlc.call_getItems1 to apsp.receive_call_getItems1;\t\n\t\t\tbind apsp.send_returnallitems1 = forw1.mq; // binding the sending to the actual gate\n\t\t\t/* How to express that this event sends a Return_AllItems? */\n\t\t\tmessage returnack1 of ResultGiveItems\n\t\t\tfrom apsp.return_getItems_ack1 to tlc.return_getItems1;\n\t\t\tmessage call_getItems2 of CallGiveItems[1]\n\t\t\tfrom tlc.call_getItems2 to apsp.receive_call_getItems2;\n\t\t\tbind apsp.send_returnallitems2 = forw2.mq; // binding the sending to the actual gate\n\t\t\tmessage returnack2 of ResultGiveItems\n\t\t\tfrom apsp.return_getItems_ack2 to tlc.return_getItems2;\n\t\t}\n\n\t\toccurrence def MQTTforwarding {\n\t\t\tref part mqttsf = AHFNorway_LocalCloudDD.MQTTServer{\n\t\t\t\tevent occurrence receive_returnallitems;\n\t\t\t\tthen event occurrence send_returnallitems;\n\t\t\t}\n\n\t\t\tref part apscf :> AHFNorway_LocalCloudDD.APISConsumer {\n\t\t\t\tevent occurrence receive_returnallitems;\n\t\t\t}\n\n\t\t\tin event occurrence mq; // parameter for gate\n\n\t\t\tmessage sendallitems1 of Return_AllItems\n\t\t\tfrom mq to mqttsf.receive_returnallitems;\n\t\t\tmessage sendallitems2 of Return_AllItems\n\t\t\tfrom mqttsf.send_returnallitems to apscf.receive_returnallitems;\n\t\t}\n\n\t\t\n\t\tinterface APIS_transfer_interface : Interfaces::Interface connect (\n\t\t\ttlu ::> AHFNorway_LocalCloudDD.TellUConsumer.apisp.APIS_HTTP, // port reference\n\t\t    apsph ::> AHFNorway_LocalCloudDD.APISProducer.tellu.APIS_HTTP, \n\t\t\tapspm ::> AHFNorway_LocalCloudDD.APISProducer.apisc.APIS_MQTT,\n\t\t\tapsc ::> AHFNorway_LocalCloudDD.APISConsumer.apisp.APIS_MQTT,\n\t\t\tmqget ::> AHFNorway_LocalCloudDD.MQTTServer.getTopic,\n\t\t\tmqgive ::> AHFNorway_LocalCloudDD.MQTTServer.giveTopic) {\n\t\t\t\n\t\t\tmessage publish_returnallitems of Publish\n\t\t\tfrom apspm to mqget;\n\t\t\tmessage subscribe_returnallitems of Subscribe\n\t\t\tfrom apsc to mqgive;\n\t\t\tmessage call_getItems of CallGiveItems[1]\n\t\t\tfrom tlu to apsph;\n\t\t\tmessage returnallitems of Return_AllItems\n\t\t\tfrom apspm to mqget;\n\t\t\tmessage sendallitems of Return_AllItems\n\t\t\tfrom mqgive to apsc;\n\t\t\tmessage returnack of ResultGiveItems\n\t\t\tfrom apsph to tlu;\n\t\t\t\n\t\t\t// Successions on each lifetime\n\t\t\t// tlu\n\t\t\tsuccession first call_getItems.startShot\n\t\t\tthen returnack.endShot;\t\n\t\t\t// apisp (taking both ports)\n\t\t\tsuccession first publish_returnallitems.startShot\n\t\t\tthen call_getItems.endShot;\n\t\t\tsuccession first call_getItems.endShot\n\t\t\tthen returnallitems.startShot;\n\t\t\tsuccession first returnallitems.startShot\n\t\t\tthen returnack.startShot;\n\t\t\t// MQTTServer\n\t\t\tsuccession first publish_returnallitems.endShot\n\t\t\tthen subscribe_returnallitems.endShot;\n\t\t\tsuccession first subscribe_returnallitems\n\t\t\tthen returnallitems.endShot;\n\t\t\tsuccession first returnallitems.endShot\n\t\t\tthen sendallitems.startShot;\n\t\t\t// apisc\n\t\t\tsuccession first subscribe_returnallitems.startShot\n\t\t\tthen sendallitems.endShot;\n\t\t}\n\t\t\n\t}\n}"
    },
    {
      "name": "AHFNorwayTopics",
      "text": "系统应支持定义和管理化工厂中的监控产品交付流程，特别是在利用Arrowhead框架下的API服务进行实时数据交换时。通过定义不同的服务和服务描述，系统能够处理产品信息的拉取和推送操作，以支持化工厂的产品监控。\n\n系统包括多个服务，如APIS服务，用于提供远程过程调用（RPC）功能，并支持HTTP和MQTT协议。这些服务能够通过不同的端口进行通信，例如APIS_HTTP和APIS_MQTT端口，用于处理不同协议下的异步信号和回调。\n\n通过定义不同的系统，如TellUConsumer、APISProducer和APISConsumer，系统能够模拟不同角色之间的通信。TellUConsumer作为消费者，向APISProducer发送请求，并接收处理结果。APISProducer作为服务提供者，接受请求并通过MQTT发布和返回数据。而APISConsumer订阅并接收通过MQTT发布的消息，从而在不同的系统间实现数据的传输和处理。\n\n系统还通过定义状态机和行为模型来管理系统的操作流程。例如，TellUConsumer的状态机通过发送`CallGiveItems`信号并等待`ResultGiveItems`回调来完成任务。而APISProducer则通过发布`Return_AllItems`信息，并根据接收到的`CallGiveItems`请求执行操作。\n\n此外，系统还通过服务发现（ServiceDiscovery）机制，确保各个系统能够在网络上互相识别并进行连接。这些连接确保了服务的可用性和及时性，增强了系统的动态性和灵活性。\n\n总体而言，系统通过将服务、协议和行为模式结合在一起，实现了产品交付过程的全面监控和管理，支持多种协议和数据交换方式，满足了化工厂应用中的复杂需求。",
      "label": "package AHFNorway {\n\tdoc /* This is the Norwegian use-case for Arrowhead Framework */\n\t// The use-case is for Productive4.0 and Arrowhead Tools\n\t// The system is taken from a chemical factory\n\t// This is focusing on the monitoring of products when delivered\n\tprivate import AHFProfileLib::*;\n\tprivate import AHFProfileMetadata::*;\n\tprivate import AHFCoreLib::**;\n\tprivate import ScalarValues::*;\n\n\t#service def APISService {\n\t\tdoc /* Service design */\t\t\n\n\t\tattribute :>> serviceDefinition = \"APISPullService\";\n\t\tattribute :>> intrfce_protocol = \"{JSON}\";\n\t\tattribute :>> serviceURL = \"pull\";\n\t}\n\n\t#servicedd port def APIS_DD :> APISService {\n\t\tdoc /* Service design description with nested protocol-specific ports */\t\n\n\t\t#idd port APIS_HTTP {\n\t\t\t// the asynch implementation of synchronous remote calls\n\t\t\tout cll:CallGiveItems;\n\t\t\tin retrn:ResultGiveItems;\n\t\t}\n\t\t\n\t\t#idd port APIS_MQTT  {\n\t\t\t// GetAllItems functionality\n\t\t\tout pub:Publish;\n\t\t\tout retall:Return_AllItems;\n\t\t\tin subscr:Subscribe;\n\t\t}\n\t}\n\t\n\t// Asynchronous signals\n\tattribute def Publish {nametopic:String;}\n\tattribute def Subscribe{nametopic:String;}\n\tattribute def Return_AllItems {itms:String;}\n\tattribute def Subscribe_giveItems{itms:String;}\n\tattribute def Return_Ack{ack:Boolean;}\n\t\n\t// Signals for implementing the remote procedure call by asynch signals\n\tattribute def CallGiveItems{itms:String; } \n\tattribute def ResultGiveItems{ack:Boolean;}\n\t\n\t#clouddd AHFNorway_LocalCloudDD :> ArrowheadCore {\t\n\t\t#systemdd TellUConsumer {\n\t\t\t#servicedd serviceDiscovery:~ServiceDiscoveryDD ; // communicating with ServiceRegistry\n\t\t\t#servicedd apisp:APIS_DD ;\n\t\t\t\n\t\t\tattribute :>> systemname = \"UngerApisClient\";\n\t\t\tattribute :>> address = \"Unger_network_ip\";\n\t\t\tattribute :>> portno = 0;\n\t\t\t\t\t\t\n\t\t\t// We want an operation call to GiveItems, and actually sending the payload\n\t\t\t// Call apisp::APIS_HTTP::giveItems(in allitems: String = \"All the items\", out ackback:Boolean);\n\t\t\t\n\t\t\tstate TellUbehavior{\n\t\t\t\tentry send CallGiveItems(\"All the items\") via apisp.APIS_HTTP;\n\t\t\t\tthen Wait;\n\t\t\t\tstate Wait;\n\t\t\t\t\taccept rs:ResultGiveItems\n\t\t\t\t\t// Here do whatever about the result rs.ret \n\t\t\t\tthen Wait;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t}\n\t\t\n\t\t#systemdd APISProducer {\n\t\t\t#servicedd serviceDiscovery:~ServiceDiscoveryDD ; // communicating with ServiceRegistry\n\t\t\t#servicedd tellu:~APIS_DD; // providing the APISService\n\t\t\t#servicedd apisc:APIS_DD ; // talking to APISConsumer\n\t\t\t\n\t\t\t:>> systemname = \"PrediktorApisServer\";\n\t\t\t:>> address = \"Prediktor_network_ip\";\n\t\t\t:>> portno = 6565;\n\t\t\tattribute x:Boolean;\n\t\t\t\n\t\t\taction giveItems :> ServiceMethod\n\t\t\t {  in itms:String; out ack:Boolean;\n\t\t\t \t/* Forward itms and return an ack */\n\t\t\t \tfirst start;\n\t\t\t \tthen send Return_AllItems(itms) via apisc.APIS_MQTT;\n\t\t\t \tsuccess = true;\n\t\t\t \tbind ack = success;\n\t\t\t }\n\t\t\t\n\t\t\tstate APISPbehavior{\n\t\t\t\tentry send Publish(\"Return_AllItems\") via apisc.APIS_MQTT;\n\t\t\t\tthen WaitOnData; \n\t\t\t\t\n\t\t\t\tstate WaitOnData;\n\t\t\t\t\taccept cl:CallGiveItems via tellu.APIS_HTTP\n\t\t\t\t\tdo action {\n\t\t\t\t\t\tfirst start;\n\t\t\t\t\t\tthen action giveItems{ in itms=cl.itms; out ack=x; }\n\t\t\t\t\t\tthen send ResultGiveItems(x) via tellu.APIS_HTTP;\n\t\t\t\t\t}\n\t\t\t\tthen WaitOnData;\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t#systemdd APISConsumer {\n\t\t\t#servicedd serviceDiscovery:~ServiceDiscovery ; // communicating with ServiceRegistry\n\t\t\t#servicedd apisp:~APIS_DD ;\n\t\t\t:>> systemname = \"TellUClient\";\n\t\t\t:>> address = \"Prediktor_network_ip\";\n\t\t\t:>> portno = 1;\n\t\t\t\n\t\t\t// Now sending signal to the remote behavior through the port functionality\n\t\t\tstate MQTT_APISP {\n\t\t\t\tentry send Subscribe(\"Return_AllItems\") via apisp.APIS_MQTT; \n\t\t\t\tthen Idle;\t\t\n\t\t\t\tstate Idle;\n\t\t\t\t\taccept Return_AllItems via apisp.APIS_MQTT\n\t\t\t\t\t// Get the stuff and do something with them\n\t\t\t\t\tthen Idle;\n\t\t\t}\n\t\t}\n \t\t\n \t\tpart MQTTServer {\n \t\t\tport getTopic:~APIS_DD;\n \t\t\tport giveTopic:APIS_DD;\n \t\t\t\n \t\t\tstate Serve{\t\t\t\t\n \t\t\t\tentry;\n \t\t\t\tthen Publ;\n \t\t\t\tstate Publ;\n \t\t\t\t\taccept pub:Publish via getTopic.APIS_MQTT\n \t\t\t\t\t// store information about who will provide \"Publish::nametopic\"\n \t\t\t\tthen Subsr;\n \t\t\t\t\n \t\t\t\tstate Subsr;\n \t\t\t\t\taccept Subscribe via giveTopic.APIS_MQTT\n \t\t\t\t\t// store information about who want to receive \"Subscribe::nametopic\"\n \t\t\t\tthen Idle;\n \t\t\t\t\n \t\t\t\tstate Idle;\n \t\t\t\t\taccept retrnall:Return_AllItems via getTopic.APIS_MQTT\n \t\t\t\t\tdo send retrnall via giveTopic.APIS_MQTT\n \t\t\t\tthen Idle;\n \t\t\t} \t\t\t\n \t\t}\n \t\t\t\t\n \t\tconnect APISProducer.apisc to MQTTServer.getTopic; \n \t\tconnect MQTTServer.giveTopic to APISConsumer.apisp; \n\t\t\n \t\tconnect TellUConsumer.apisp to APISProducer.tellu; \n \t\t\n \t\t// Then we need to connect the application systems to the mandatory systems\n \t\tconnect APISProducer.serviceDiscovery to service_registry.serviceDiscovery;\n \t\tconnect TellUConsumer.serviceDiscovery to service_registry.serviceDiscovery;\n \t\tconnect APISConsumer.serviceDiscovery to service_registry.serviceDiscovery;\n \t\t\n \t\t// Same procedure for the other mandatory services\n\t\t\n\t}\n\t\n}"
    },
    {
      "name": "AHFCoreLib",
      "text": "系统应支持定义和管理核心服务，如服务发现和授权服务，并能够通过不同的协议进行交互。通过设计核心系统和描述其服务，系统能够为不同的功能模块提供高效的服务注册、授权管理和服务调用。\n\n在该系统中，服务发现（ServiceDiscovery）作为核心服务之一，能够帮助系统动态发现和访问其他服务。授权服务（Authorisation）则用于验证用户或系统的身份，确保系统的安全性。\n\n系统采用了多种协议进行服务的交互，如HTTP和MQTT，并通过服务定义和描述（ServiceDefinition and ServiceDescription）来指定各个服务的细节。服务的描述层（Design Description Level）包括了对每个服务和其端口的详细说明，能够明确服务的行为和支持的协议。通过这种方式，系统能够在不同的通信协议下灵活地管理服务，并确保服务的高效发现和调用。\n\n此外，系统还支持定义行为（如Echo行为），以实现服务的方法交互，增强了系统的灵活性和可扩展性。",
      "label": "// /** Mandatory Services and Systems */\nlibrary package AHFCoreLib {\n\tprivate import AHFProfileLib::*;\n\tprivate import ScalarValues::*;\n\tprivate import AHFProfileMetadata::*;\n\n\t#service port def ServiceDiscovery {\n\t\t// The functionalities as Requests (Operations) cannot be defined yet\n\t\t// We could consider using flows to designate the functionalities\n\t}\n\t\n\t#service port def ServiceDiscoveryDD :> ServiceDiscovery{\n\t}\n\t\t\n\t#service port def Authorisation {\n\t\tattribute publickey:String; // just as examples\n\t}\n\n\t#service port def AuthorisationDD :> Authorisation{\n\t}\n\n\t\n\t#clouddd ArrowheadCore{\n\t\t// /** Design Level */\n\t\t// First the system definitions (SysD) of core systems\n\t\t\n\t\t#system service_registry {\n\t\t\t#service serviceDiscovery : ServiceDiscovery ;\n\t\t}\n\t\t\n\t\t#system authorization{\n\t\t\t#service authorisation : Authorisation;\n\t\t\tattribute protocol:String = \"HTTP\";\n\t\t}\n\t\t\n\t\t#system orchestrationDesign; // just indicated for now\n\t\t\n\t\t// /** Design Description level */\t\t\n\t\t#systemdd service_registry_DD :> service_registry{\n\t\t\t#servicedd :>> serviceDiscovery:ServiceDiscoveryDD {\n\t\t\t\t#idd serviceDiscovery_HTTP ;// nested port for HTTP protocol\n\t\t\t\t// here we refer the functionalities like operation Register etc.\n\t\t\t\t#idd serviceDiscovery_MQTT ; // nested port for MQTT protocol\n\t\t\t}\n\t\t}\n\t\t\n\t\t#systemdd authorization_DD :> authorization{\n\t\t\t#servicedd :>> authorisation {\n\t\t\t\t#idd authorisation_HTTP ; // nested port for HTTP protocol\n\t\t\t\t#idd authorisation_MQTT ; // nested port for MQTT protocol\n\t\t\t}\n\t\t\taction Echo_behavior :> ServiceMethod;\n\t\t}\n\t}\n}"
    },
    {
      "name": "VehicleIndividuals",
      "text": "系统应支持定义和管理不同类型的车辆实例。每辆车应具备独特的质量属性，并且能够为不同车辆定义不同的质量值。例如，系统应能够定义一辆质量为1800千克的车辆，以及另一辆质量为1700千克的车辆。每个车辆实例应能够明确其质量属性，并确保该属性符合预设值。\n\n系统还应支持定义和管理车辆的时间快照。车辆的时间快照用于记录特定时间点的状态，并可以用于后续的时间切片分析。系统应能够根据不同的时间点生成车辆的快照，并记录车辆在不同时间的状态。例如，系统可以生成一个车辆快照，在时间点t0记录车辆的状态，并允许通过时间切片来查看车辆从时间点t0到t1的状态变化。\n\n此外，系统应支持定义车辆的配置，并能够为特定时间段内的车辆生成配置快照。例如，系统可以定义一个车辆配置，并确保某辆车在其生命周期的一部分时间内符合该配置。车辆配置应包括不同的部件和特征，确保每个配置的完整性和一致性。每个配置快照应能够记录车辆特定时间点的状态，并描述其部件和特征。例如，系统应允许记录车辆在时间点t0和t1时的配置，并确保这些快照能够正确地反映车辆配置的变化。",
      "label": "package VehicleIndividuals {\n\tprivate import VehicleUsages::*;\n\tprivate import Time::DateTime;\n\tprivate import SI::kg;\n\t\n\tpackage IndividualDefinitions {\n\n\t\tindividual part def Vehicle1 :> Vehicle {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is an individual Vehicle with a mass of 1800 kg.\n\t\t\t */\n\t\t\t\n\t\t\tattribute redefines mass = 1800 [kg];\n\t\t}\n\t\t\n\t\tindividual part def Vehicle2 :> Vehicle {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is an individual Vehicle with a mass of 1700 kg.\n\t\t\t */\n\t\t\n\t\t\tattribute redefines mass = 1700 [kg];\n\t\t}\n\t\t\n\t\tindividual part def AxleAssembly1 :> AxleAssembly;\n\t\t\n\t\tindividual part def Wheel1 :> Wheel;\n\t\tindividual part def Wheel2 :> Wheel;\n\t}\n\t\n\tpackage IndividualSnapshots {\n\t\tpublic import IndividualDefinitions::*;\n\t\n\t\tattribute t0: DateTime;\n\t\tattribute t1: DateTime;\n\t\t\n\t\tsnapshot part vehicle1_t0: Vehicle1 {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is a snapshot of Vehicle1 at time t0;\n\t\t\t */\n\t\t\n\t\t\t// Note: Timestamping of snapshots is not yet formalized.\n\t\t\tattribute t = t0;\n\t\t}\n\t\t\n\t\ttimeslice part vehicle1_t0_t1: Vehicle1 {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is a time slice of Vehicle1 starting at snapshot vehicle1_t0 \n\t\t\t * (time t0) and ending at time t1.\n\t\t\t */\n\t\t\n\t\t\tsnapshot :>> start = vehicle1_t0;\n\t\t\tsnapshot :>> done {\n\t\t\t\tattribute t = t1;\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\tpackage IndividualConfigurations {\n\t\tpublic import IndividualSnapshots::*;\n\t\n\t\tindividual part vehicle1_C2: Vehicle1 :> vehicle_C2 {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This asserts that for some portion of its lifetime, Vehicle1 conforms\n\t\t\t * to the configuration vehicle_C2;\n\t\t\t */\n\t\t}\t\n\t\t\t\n\t\tsnapshot part vehicle1_C2_t0 : Vehicle1 :> vehicle1_C2, vehicle1_t0 {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is a snapshot of Vehicle1 in configuration vehicle1_C2 at time t0.\n\t\t\t */\n\t\t\n\t\t\tsnapshot axleAssembly1_t0: AxleAssembly1 :>> frontAxleAssembly {\n\t\t\t\tdoc\n\t\t\t\t/*\n\t\t\t\t * frontAxleAssembly is a feature of vehicle1_C2.\n\t\t\t\t */\n\t\t\t\n\t\t\t\tsnapshot leftFrontWheel_t0: Wheel1 :>> leftFrontWheel {\n\t\t\t\t\tdoc\n\t\t\t\t\t/*\n\t\t\t\t\t * This asserts that Wheel1 is the leftFrontWheel of vehicle_C2_t0\n\t\t\t\t\t * (leftFrontWheel is a feature of vehicle_C2::frontAxleAssembly).\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsnapshot part vehicle1_C2_t1 : Vehicle1 :> vehicle1_C2, vehicle1_t0_t1.done {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is a snapshot of Vehicle1 in configuration vehicle_C2 at time t1.\n\t\t\t */\n\t\t\n\t\t\tsnapshot axleAssembly1_t1: AxleAssembly1 :>> frontAxleAssembly {\n\t\t\t\tsnapshot rightFrontWheel_t1: Wheel1 :>> rightFrontWheel {\n\t\t\t\t\tdoc\n\t\t\t\t\t/*\n\t\t\t\t\t * This asserts that Wheel1 is the rightFrontWheel of vehicle_C2_t1.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}"
    },
    {
      "name": "SysML v2 Spec Annex A SimpleVehicleModel",
      "text": "系统应定义并管理车辆模型，涵盖车辆的基本属性与动态行为。车辆需具备质量、位置、速度、加速度等物理量属性，并支持点火控制、电源指令、车辆与道路交互等端口的通信功能。车辆需执行提供动力、制动、方向控制、自检等核心动作，同时通过状态机管理运行状态（如关闭、启动、运行）和健康状态（如正常、维护、降级），确保状态转换逻辑符合实际操作条件，例如在点火信号满足条件时启动车辆。\n\n系统需包含动力系统的详细定义，如引擎的扭矩生成、传动系统的扭矩放大与传递、驱动轴与车轮的扭矩分配等动作流程。引擎需支持多缸配置（如4缸或6缸），并满足功率输出、燃油效率等性能指标。变速箱应支持自动与手动类型的选择，并与引擎动力输出端通过标准化接口连接。\n\n车辆软件部分需实现控制器功能，包括车辆主控制器和巡航控制器。主控制器需管理引擎控制端口，接收并处理启动、关闭信号，巡航控制器需集成速度传感器与设定速度接口，实现动力输出的自动调节。软件状态需与车辆物理状态同步，例如在车辆启动时激活控制器。\n\n燃料系统需定义燃料箱的容量限制、燃料类型，并确保燃料质量不超过最大限制。系统需通过接口实现燃料从油箱到引擎的流动，并在设计上满足燃油经济性需求，例如在城市和高速公路场景下达到指定的平均油耗标准。\n\n车辆配置需支持前后轴组件的定义，包括车轮与轮毂的连接接口、传动轴与差速器的扭矩分配。车轮需通过标准化接口与轮毂固定，确保螺纹参数匹配且最大扭矩符合安全要求。车辆结构需包含车身、保险杠、安全带等安全部件，并标记强制性与可选安全特性，如安全带为强制安全部件，安全气囊为可选。\n\n系统需支持质量、燃油经济性、可靠性等需求的验证。例如，通过称重测试验证车辆总质量是否符合上限，通过燃油消耗分析验证经济性指标。验证过程需支持测试、分析等多种方法，并生成通过/失败的评估结果。\n\n系统需定义运输乘客的任务场景，包括乘客上下车、车辆启动、行驶至目的地等步骤，并支持并发动作管理（如乘客与驾驶员同时上下车）。任务场景需与车辆状态、道路条件绑定，确保逻辑符合真实操作流程。\n\n系统需提供权衡分析功能，支持不同引擎配置（如4缸与6缸）在质量、功率、成本等维度的评估，并通过目标函数选择最优方案。分析过程需考虑技术风险，例如燃油效率不足的可能性及其影响。\n\n系统需支持通过视图展示部件结构、安全相关组件等信息，例如以树形图展示车辆部件层次，或通过表格筛选安全与安全相关的部件。视图需满足不同利益相关者的关注点，如安全工程师可查看强制安全部件清单。\n\n最后，系统需管理车辆个体在不同时间点的状态快照，例如记录车辆在启动、加速等阶段的位移、速度、加速度数据，并与道路条件（如坡度、摩擦系数）关联，支持动态行为的情景分析。",
      "label": "package SimpleVehicleModel{\n    // 2023-02 release\n    public import Definitions::*;  \n    public import ISQ::*;\n    package Definitions{\n        public import PartDefinitions::*;\n        public import PortDefinitions::*;\n        public import ItemDefinitions::*;\n        public import SignalDefinitions::*;\n        public import InterfaceDefinitions::*;\n        public import AllocationDefinitions::*;\n        public import ActionDefinitions::*;\n        public import StateDefinitions::*;\n        public import RequirementDefinitions::*;\n        public import AttributeDefinitions::*;\n        public import IndividualDefinitions::*;\n        public import MetadataDefinitions::**;\n        public import KeyWord_MetadataDefinitions::*;\n        package PartDefinitions{\n            part def Vehicle {\n                attribute mass :> ISQ::mass;\n                attribute dryMass:>ISQ::mass;\n                attribute cargoMass:>ISQ::mass;\n                attribute position:>ISQ::length;\n                attribute velocity:>ISQ::speed;\n                attribute acceleration:>ISQ::acceleration;\n                attribute electricalPower:>ISQ::power;\n                attribute Tmax:>ISQ::temperature;\n                attribute maintenanceTime: Time::DateTime; \n                attribute brakePedalDepressed: Boolean;\n                port ignitionCmdPort:IgnitionCmdPort;\n                port pwrCmdPort:PwrCmdPort;\n                port vehicleToRoadPort:VehicleToRoadPort;\n                port statusPort:StatusPort;\n                perform action providePower;\n                perform action provideBraking;\n                perform action controlDirection;\n                perform action performSelfTest;\n                perform action applyParkingBrake;\n                perform action senseTemperature;\n                exhibit state vehicleStates parallel {\n                    ref controller : VehicleController;\n                    state operatingStates {\n                        entry action initial;\n                        state off;                    \n                        state starting;                    \n                        state on {\n                            entry performSelfTest;\n                            do providePower;\n                            exit applyParkingBrake;\n                            constraint {electricalPower<=500[W]}\n                        }\n\n                        transition initial then off;\n\n                        transition off_To_starting\n                            first off\n                            accept ignitionCmd:IgnitionCmd via ignitionCmdPort\n                                if ignitionCmd.ignitionOnOff==IgnitionOnOff::on and brakePedalDepressed\n                            do send StartSignal() to controller\n                            then starting;\n                        \n                        transition starting_To_on\n                            first starting\n                            accept VehicleOnSignal\n                            then on;\n                        \n                        transition on_To_off\n                            first on\n                            accept VehicleOffSignal\n                            do send OffSignal() to controller\n                            then off;\n                    }\n\n                    state healthStates {\n                        entry action initial;\n                        do senseTemperature{\n                            out temp;\n                        }\n\n                        state normal;\n                        state maintenance;\n                        state degraded;                    \n\n                        transition initial then normal;\n\n                        transition normal_To_maintenance\n                            first normal\n                            accept at maintenanceTime\n                            then maintenance;\n\n                        transition normal_To_degraded\n                            first normal\n                            accept when senseTemperature.temp > Tmax \n                            do send OverTemp() to controller\n                            then degraded;\n\n                        transition maintenance_To_normal\n                            first maintenance\n                            accept ReturnToNormal\n                            then normal;\n\n                        transition degraded_To_normal\n                            first degraded\n                            accept ReturnToNormal\n                            then normal;\n                    }\n                }\n            }\n            part def Engine{\n                attribute mass :> ISQ::mass;\n                attribute peakHorsePower:>ISQ::power;\n                attribute fuelEfficiency:Real;\n                attribute cost:Real;\n                attribute displacement :> ISQ::volume;\n                port engineControlPort: ~ControlPort;\n                port fuelInPort: ~ FuelPort;\n                port fuelCmdPort:FuelCmdPort;\n                port drivePwrPort:DrivePwrPort;\n                port ignitionCmdPort:IgnitionCmdPort;\n                port flyWheelPort;\n                perform action generateTorque;\n                exhibit state engineStates{\n                    state off;\n                    state starting;\n                    state on{\n                        do generateTorque;\n                    }\n                }\n            }\n            part def StarterMotor{\n                port gearPort:GearPort;\n            }\n            part def Cylinder;\n            part def Transmission{\n                attribute gearRatio:Real;\n                port clutchPort:~DrivePwrPort;\n                exhibit state transmissionStates;\n            }\n            part def Driveshaft;\n            part def AxleAssembly;\n            part def Axle{\n                attribute mass:>ISQ::mass;\n            }\n            part def FrontAxle:>Axle{\n                attribute steeringAngle:>ISQ::angularMeasure;\n            }\n            part def HalfAxle{\n                port shankCompositePort:ShankCompositePort{\n                }\n            }\n            part def Differential;\n            part def Wheel{\n                attribute diameter:LengthValue;\n                port lugNutCompositePort:LugNutCompositePort;\n            }\n            part def Hub{\n                port shankCompositePort:ShankCompositePort;\n            }\n            abstract part def Software;\n            part def VehicleSoftware:>Software;\n            part def VehicleController:>Software {\n                port controlPort:ControlPort;\n                exhibit state controllerStates parallel {\n                    state operatingStates {\n                        entry action initial; \n                        state off;\n                        state on;    \n                        transition initial then off;\n                        transition 'off-on'\n                            first off\n                            accept StartSignal\n                            then on;\n                        transition 'on-off'\n                            first on\n                            accept OffSignal\n                            then off;\n                    }\n                }  \n            }\n            part def CruiseController:>Software {\n                port setSpeedPort:~SetSpeedPort;\n                port speedSensorPort:~SpeedSensorPort;\n                port cruiseControlPort:CruiseControlPort;\n                exhibit state cruiseControllerStates;\n            }\n            part def SpeedSensor{\n                port speedSensorPort:SpeedSensorPort;\n            }\n            part def FuelTank{\n                attribute mass :> ISQ::mass;\n                ref item fuel:Fuel{\n                    attribute :>> fuelMass;\n                }\n                attribute fuelKind:FuelKind;\n                attribute fuelMassMax:>ISQ::mass;\n                assert constraint fuelConstraint {fuel.fuelMass<=fuelMassMax}\n                port fuelOutPort:FuelPort;\n                port fuelInPort:~FuelPort;\n            }\n            part def BodyAssy;\n            part def Body{\n                attribute color:Colors;\n            }\n            part def Thermostat;\n            part def WaterHose;\n            part def Road{\n                attribute incline:Real;\n                attribute friction:Real;\n            }\n            part def Engine4Cyl;\n            part def Engine6Cyl;\n            part def TransmissionChoices;\n            part def TransmissionAutomatic;\n            part def TransmissionManual;\n            part def Sunroof;\n            \n            //logical Components\n            part def ElectricalGenerator;\n            part def TorqueGenerator;\n            part def SteeringSubsystem;\n            part def BrakingSubsystem;\n        }\n        package PortDefinitions{\n            port def IgnitionCmdPort{\n                in item ignitionCmd:IgnitionCmd;\n            }\n            port def StatusPort;\n            port def GearPort;\n            port def PwrCmdPort{\n                in item pwrCmd:PwrCmd;\n            }\n            port def FuelCmdPort:>PwrCmdPort{\n                in item fuelCmd:FuelCmd redefines pwrCmd;\n            }\n            port def FuelPort{\n                out item fuel:Fuel;\n            }\n            port def DrivePwrPort{\n                out torque:Torque;\n            }\n            port def ShaftPort_a;\n            port def ShaftPort_b;\n            port def ShaftPort_c;\n            port def ShaftPort_d;\n            port def DiffPort;\n            port def AxlePort;\n            port def AxleToWheelPort;\n            port def WheelToAxlePort;\n            port def WheelToRoadPort;\n\n            port def LugNutCompositePort{\n                port lugNutPort:LugNutPort [*];\n            }\n            port def ShankCompositePort{\n                port shankPort:ShankPort [*];\n            }\n            port def LugNutPort{\n                attribute threadDia;\n                attribute threadPitch;\n            }\n            port def ShankPort{\n                attribute threadDia;\n                attribute threadPitch;   \n                attribute shaftLength;\n            }\n            \n            port def VehicleToRoadPort;\n            port def ControlPort;\n            port def CruiseControlPort:>ControlPort;\n            port def SpeedSensorPort;\n            port def SetSpeedPort;\n\n            port def DriverCmdPort{\n                out item driverCmd[*]:DriverCmd;\n            }\n            port def HandPort :> DriverCmdPort {\n                out item ignitionCmd:IgnitionCmd subsets driverCmd;\n                out item pwrCmd:PwrCmd subsets driverCmd;\n            }  \n        }\n        package ItemDefinitions{\n            item def PwrCmd{\n                attribute throttleLevel:Real;\n            }\n            item def FuelCmd:>PwrCmd;\n            item def Fuel{\n                attribute fuelMass:>ISQ::mass;\n            }\n            item def SensedSpeed{\n                attribute speed:>ISQ::speed;\n            }\n        }\n        package SignalDefinitions{\n            item def Cmd{\n            }\n            item def DriverCmd;\n            item def IgnitionCmd:>DriverCmd{\n                attribute ignitionOnOff:IgnitionOnOff;\n            }\n            item def EngineStatus;\n            \n            attribute def VehicleStartSignal;\n            attribute def VehicleOnSignal;\n            attribute def VehicleOffSignal;\n            attribute def StartSignal;\n            attribute def OffSignal;\n            attribute def OverTemp;\n            attribute def ReturnToNormal;\n            attribute def SetSpeed:>Real;\n        }\n        package InterfaceDefinitions{\n            interface def EngineToTransmissionInterface{\n                end p1:DrivePwrPort;\n                end p2:~DrivePwrPort;\n                flow p1.torque to p2.torque;\n            }\n            interface def FuelInterface {\n                end fuelOutPort:FuelPort;\n                end fuelInPort:~FuelPort;\n                flow of Fuel from fuelOutPort.fuel to fuelInPort.fuel;\n            }\n            \n            interface def WheelFastenerInterface{\n                end lugNutPort:LugNutPort;\n                end shankPort:ShankPort;\n                attribute maxTorque : Torque;\n                constraint {lugNutPort.threadDia == shankPort.threadDia}\n            }\n            interface def WheelHubInterface{\n                end lugNutCompositePort:LugNutCompositePort;\n                end shankCompositePort:ShankCompositePort;\n                interface wheelFastenerInterface:WheelFastenerInterface [5]\n                    connect lugNutCompositePort.lugNutPort to shankCompositePort.shankPort;\n            }\n        }\n        package AllocationDefinitions{\n            allocation def LogicalToPhysical{\n                end #logical logicalEnd;\n                end #physical physicalEnd;\n            }\n        }\n        package ActionDefinitions{\n            action def ProvidePower {\n                in item pwrCmd:PwrCmd;\n                out wheelToRoadTorque:Torque[2];\n            }\n            action def GenerateTorque {\n                in item fuelCmd:FuelCmd;\n                out engineTorque:Torque;\n            }\n            action def AmplifyTorque {\n                in engineTorque:Torque;\n                out transmissionTorque:Torque;\n            }\n            action def TransferTorque {\n                in transmissionTorque:Torque;\n                out driveshaftTorque:Torque;\n            }\n            action def DistributeTorque {\n                in driveshaftTorque:Torque;\n                out wheelToRoadTorque:Torque[2];\n            }\n            action def PerformSelfTest;\n            action def ApplyParkingBrake;\n            action def SenseTemperature{\n                out temp: ISQ::TemperatureValue;\n            }\n        }    \n        package StateDefinitions {\n            state def VehicleStates;\n            state def ControllerStates;  \n            state def CruiseControllerStates;\n        }\n        package RequirementDefinitions{\n            requirement def MassRequirement{\n                doc /*The actual mass shall be less than the required mass*/\n                attribute massRequired:>ISQ::mass;\n                attribute massActual:>ISQ::mass;\n                require constraint {massActual<=massRequired}\n            }\n            requirement def ReliabilityRequirement{\n                doc /*The actual reliability shall be greater than the required reliability*/\n                attribute reliabilityRequired:Real;\n                attribute reliabilityActual:Real;\n                require constraint {reliabilityActual>=reliabilityRequired}\n            }\n            requirement def TorqueGenerationRequirement {\n                doc /* The engine shall generate torque as a function of RPM as shown in Table 1. */\n                subject generateTorque:ActionDefinitions::GenerateTorque;\n            }\n            requirement def DrivePowerOutputRequirement { \n                doc /* The engine shall provide a connection point to transfer torque to the transmission.*/\n            }\n            requirement def FuelEconomyRequirement {\n                doc /* The vehicle shall maintain an average fuel economomy of at least x miles per gallon for the nominal \n                driving scenario */\n                attribute actualFuelEconomy :> distancePerVolume;\n                attribute requiredFuelEconomy :> distancePerVolume;\n                require constraint {actualFuelEconomy >= requiredFuelEconomy}\n            }\n        }\n        package AttributeDefinitions{\n            public import ScalarValues::*;\n            public import Quantities::*;\n            public import MeasurementReferences::DerivedUnit;\n            public import SIPrefixes::kilo;\n            // Numerical Functions provides basic operators such as Sum expression\n            public import NumericalFunctions::*;\n            public import SI::*;\n            public import USCustomaryUnits::*;\n            alias Torque for ISQ::TorqueValue;\n            \n            enum def Colors {black;grey;red;}\n            enum def DiameterChoices:>ISQ::LengthValue{\n                enum = 60 [mm];\n                enum = 80 [mm];\n                enum = 100 [mm];\n            }\n            attribute cylinderDiameter: DiameterChoices = 80 [mm]; \n            enum def IgnitionOnOff {on;off;}\n            enum def FuelKind {gas;diesel;}\n\n            distancePerVolume :> scalarQuantities = distance / volume;\n            timePerDistance :> scalarQuantities = time / distance;\n            volumePerDistance :> scalarQuantities = volume / distance;\n            volumePerTime :> scalarQuantities = volume / time;\n            \n            // kpl is approx .425 * mpg\n            kpl : DerivedUnit = km / L;\n            rpm : DerivedUnit = 1 / SI::min;\n            kW : DerivedUnit = kilo * W;\n            \n        }\n        package IndividualDefinitions{\n            individual def VehicleRoadContext_1:>GenericContext::Context;\n            individual def Vehicle_1:>Vehicle;\n            individual def FrontAxleAssembly_1:>AxleAssembly;\n            individual def FrontAxle_1:>FrontAxle;\n            individual def Wheel_1:>Wheel;\n            individual def Wheel_2:>Wheel;\n            individual def RearAxleAssembly_1:>AxleAssembly;\n            individual def Road_1:>Road;\n        }\n        package MetadataDefinitions { \n            public import AnalysisTooling::*;   \n            metadata def Safety {\n                attribute isMandatory : Boolean;\n            }\n            metadata def Security;\n        }\n        package KeyWord_MetadataDefinitions{\n            public import Metaobjects::SemanticMetadata;\n            \n            // the following is used to define the key word failureMode\n            state failureModes[*] nonunique;\n            \n            // with alias <fm>\n            metadata def <fm> failureMode :> SemanticMetadata {\n                :>> baseType = failureModes meta SysML::StateUsage;\n            }\n            \n            occurrence logicalOccurrences [*] nonunique;\n            \n            metadata def <l> logical :> SemanticMetadata {\n                :>> baseType = logicalOccurrences meta SysML::Usage;\n            }\n            \n            occurrence physicalOccurrences [*] nonunique;\n            \n            metadata def <p> physical :> SemanticMetadata {\n                :>> baseType = physicalOccurrences meta SysML::Usage;\n            }  \n        }\n        package GenericContext {\n\n            part def Context {\n                attribute time:TimeValue;\n                attribute spatialCF: CartesianSpatial3dCoordinateFrame[1] { :>> mRefs = (m, m, m); }\n                attribute velocityCF: CartesianVelocity3dCoordinateFrame[1] = spatialCF/s;\n                attribute accelarationCF: CartesianAcceleration3dCoordinateFrame[1] = velocityCF/s;\n            }\n        }\n    }\n\n    package VehicleLogicalConfiguration{\n        package PartsTree{\n            #logical part vehicleLogical:Vehicle{\n                part torqueGenerator:TorqueGenerator{\n                    action generateTorque;\n                }\n                part electricalGenerator:ElectricalGenerator{\n                    action generateElectricity;\n                }\n                part steeringSystem:SteeringSubsystem;\n                part brakingSubsystem:BrakingSubsystem;\n            }\n        }\n    }\n    package VehicleLogicalToPhysicalAllocation{\n        public import VehicleConfigurations::VehicleConfiguration_b::PartsTree::**;\n        public import VehicleLogicalConfiguration::PartsTree::*;\n\n        allocation vehicleLogicalToPhysicalAllocation:LogicalToPhysical\n            allocate vehicleLogical to vehicle_b{\n                allocate vehicleLogical.torqueGenerator to vehicle_b.engine{\n                    allocate vehicleLogical.torqueGenerator.generateTorque to vehicle_b.engine.generateTorque;\n                }\n                allocate vehicleLogical.electricalGenerator to vehicle_b.engine{\n                    allocate vehicleLogical.electricalGenerator.generateElectricity to vehicle_b.engine.alternator.generateElectricity;\n                }\n            }\n    } \n    package VehicleConfigurations{\n        package VehicleConfiguration_a{\n            package PartsTree{\n                part vehicle_a:Vehicle{\n                    attribute mass redefines Vehicle::mass=dryMass+cargoMass+fuelTank.fuel.fuelMass;\n                    attribute dryMass redefines Vehicle::dryMass=sum(partMasses);\n                    attribute redefines Vehicle::cargoMass=0 [kg];\n                    attribute partMasses [*] nonunique :>ISQ::mass;\n                    part fuelTank:FuelTank{\n                        attribute redefines mass=75[kg];\n                        ref item redefines fuel{\n                            attribute redefines fuelMass=50[kg];\n                        }   \n                    }\n                    part frontAxleAssembly:AxleAssembly{\n                        attribute mass :> ISQ::mass=800[kg];\n                        part frontAxle:Axle;\n                        part frontWheels:Wheel[2];\n                    }\n                    part rearAxleAssembly:AxleAssembly{\n                        attribute mass :> ISQ::mass=875[kg];\n                        attribute driveTrainEfficiency:Real = 0.6;\n                        part rearAxle:Axle;\n                        part rearWheels:Wheel[2]{\n                            attribute redefines diameter;\n                        }\n                    }\n                }\n            }\n            package ActionTree{  \n            }\n            package Requirements{\n            }\n        }\n        package VehicleConfiguration_b{\n            //Shapes library for simple geometry\n            public import ShapeItems::Box;\n            public import ParametersOfInterestMetadata::mop;\n            public import ModelingMetadata::*; // incudes status info\n            \n            package PartsTree{\n                part vehicle_b : Vehicle{\n                    #mop attribute mass redefines mass=dryMass+cargoMass+fuelTank.fuel.fuelMass;\n                    attribute dryMass redefines dryMass=sum(partMasses);\n                    attribute redefines cargoMass default 0 [kg];\n                    attribute partMasses=(fuelTank.mass,frontAxleAssembly.mass,rearAxleAssembly.mass,engine.mass,transmission.mass,driveshaft.mass);\n                    attribute avgFuelEconomy :> distancePerVolume;\n                    port fuelCmdPort: FuelCmdPort redefines pwrCmdPort {\n                        in item fuelCmd redefines pwrCmd;\n                    }\n                    port setSpeedPort:~SetSpeedPort;\n                    port vehicleToRoadPort redefines vehicleToRoadPort{\n                        port wheelToRoadPort1:WheelToRoadPort;\n                        port wheelToRoadPort2:WheelToRoadPort;\n                    }\n                    perform ActionTree::providePower redefines providePower;\n                    perform ActionTree::performSelfTest redefines performSelfTest;\n                    perform ActionTree::applyParkingBrake redefines applyParkingBrake;\n                    perform ActionTree::senseTemperature redefines senseTemperature;\n                    exhibit state vehicleStates redefines vehicleStates;\n                    \n                    // Example vehicle with simple enveloping shape that is a solid \n                    item :> envelopingShapes : Box[1] {\n                        length1:>> length = 4800 [mm];\n                        width1:>> width = 1840 [mm];\n                        height1:>> height = 1350 [mm];\n                    }\n                    \n                    part fuelTank:FuelTank{\n                        attribute redefines mass=75[kg];\n                        ref item redefines fuel{\n                            attribute redefines fuelMass=60[kg];\n                        }\n                        attribute redefines fuelMassMax=60 [kg];\n                    }\n                    part frontAxleAssembly:AxleAssembly{\n                        attribute mass :> ISQ::mass=800[kg];\n                        port shaftPort_d:ShaftPort_d;\n                        part frontAxle:FrontAxle;\n                        part frontWheels:Wheel[2];\n                    }\n                    \n                    part rearAxleAssembly:AxleAssembly{\n                        attribute mass :> ISQ::mass=875[kg];\n                        attribute driveTrainEfficiency:Real = 0.6;\n                        port shaftPort_d:ShaftPort_d;\n                        perform providePower.distributeTorque;\n                        part rearWheel1:Wheel{\n                            attribute redefines diameter;\n                            port wheelToRoadPort:WheelToRoadPort;\n                            port lugNutCompositePort :>> lugNutCompositePort{\n                                port lugNutPort :>> lugNutPort [5];\n                            }\n                        }\n                        part rearWheel2:Wheel{\n                            attribute redefines diameter;\n                            port wheelToRoadPort:WheelToRoadPort;\n                            port lugNutCompositePort :>> lugNutCompositePort{\n                                port lugNutPort :>> lugNutPort [5];\n                            }\n                        }\n                        part differential:Differential{\n                            port shaftPort_d:ShaftPort_d;\n                            port leftDiffPort:DiffPort;\n                            port rightDiffPort:DiffPort;\n                        }\n                        part rearAxle{\n                            part leftHalfAxle:HalfAxle{\n                                port leftAxleToDiffPort:AxlePort;\n                                port shankCompositePort :>> shankCompositePort{\n                                    port shankPort :>> shankPort [5];\n                                }\n                            }\n                            part rightHalfAxle:HalfAxle{\n                                port rightAxleToDiffPort:AxlePort;\n                                port shankCompositePort :>> shankCompositePort {\n                                    port shankPort :>> shankPort [5];\n                                }\n                            }\n                        }\n                        \n                        bind shaftPort_d=differential.shaftPort_d;\n                        connect differential.leftDiffPort to rearAxle.leftHalfAxle.leftAxleToDiffPort;\n                        connect differential.rightDiffPort to rearAxle.rightHalfAxle.rightAxleToDiffPort;\n                        \n                        interface wheelToleftHalAxleInterface:WheelHubInterface \n                            connect rearWheel1.lugNutCompositePort [1] to rearAxle.leftHalfAxle.shankCompositePort [1];\n                        interface wheelTorightHalAxleInterface:WheelHubInterface\n                            connect rearWheel2.lugNutCompositePort [1] to rearAxle.rightHalfAxle.shankCompositePort [1];\n                        \n                    }\n                    part starterMotor:StarterMotor;\n                    part engine:Engine{\n                        perform providePower.generateTorque redefines generateTorque;            \n                        part cylinders:Cylinder[4..6];\n                        part alternator{\n                            action generateElectricity;\n                        }\n                        satisfy Requirements::engineSpecification by vehicle_b.engine{\n                            requirement torqueGenerationRequirement :>> torqueGenerationRequirement{\n                                subject generateTorque redefines generateTorque = vehicle_b.engine.generateTorque;\n                            }\n                            requirement drivePowerOuputRequirement :>> drivePowerOutputRequirement{\n                                port torqueOutPort redefines torqueOutPort=vehicle_b.engine.drivePwrPort;\n                            }\n                        } \n                    }\n                    part transmission:Transmission{\n                        attribute mass :> ISQ::mass=100[kg];\n                        port shaftPort_a:ShaftPort_a;\n                        perform providePower.amplifyTorque;\n                    }\n                    part driveshaft:Driveshaft{\n                        attribute mass :> ISQ::mass=100[kg];\n                        port shaftPort_b:ShaftPort_b;\n                        port shaftPort_c:ShaftPort_c;\n                        perform providePower.transferTorque;\n                    }\n                    part vehicleSoftware:VehicleSoftware{\n                        part vehicleController: VehicleController {\n                            exhibit state controllerStates redefines controllerStates;\n                            part cruiseController:CruiseController;\n                        }\n                    }\n                    part speedSensor:SpeedSensor;\n                    \n                    // parts in bodyAssy and interioer are marked as safety or security features\n                    part bodyAssy:BodyAssy{\n                        part body:Body{\n                            attribute :>> color = Colors::red;  \n                        }\n                        part bumper {@Safety{isMandatory = true;}}\n                        part keylessEntry {@Security;}\n                    }\n                    part interior {\n                        part alarm {@Security;}\n                        part seatBelt[2] {@Safety{isMandatory = true;}}\n                        part frontSeat[2];\n                        part driverAirBag {@Safety{isMandatory = false;}}\n                    }\n                    \n                    //connections\n                    bind engine.fuelCmdPort=fuelCmdPort;\n\n                    interface engineToTransmissionInterface:EngineToTransmissionInterface\n                        connect engine.drivePwrPort to transmission.clutchPort;\n                \n                    interface fuelInterface:FuelInterface\n                        connect fuelTank.fuelOutPort to engine.fuelInPort;\n\n                    allocate ActionTree::providePower.generateToAmplify to engineToTransmissionInterface;\n                    \n                    bind engine.ignitionCmdPort=ignitionCmdPort;\n                    connect starterMotor.gearPort to engine.flyWheelPort;\n                    connect vehicleSoftware.vehicleController.controlPort to engine.engineControlPort;\n                    bind vehicle_b.setSpeedPort = vehicleSoftware.vehicleController.cruiseController.setSpeedPort;\n                    connect speedSensor.speedSensorPort to vehicleSoftware.vehicleController.cruiseController.speedSensorPort;\n                    bind vehicleSoftware.vehicleController.cruiseController.cruiseControlPort = vehicleSoftware.vehicleController.controlPort;\n                    connect transmission.shaftPort_a to driveshaft.shaftPort_b; \n                    connect driveshaft.shaftPort_c to rearAxleAssembly.shaftPort_d;\n                    bind rearAxleAssembly.rearWheel1.wheelToRoadPort=vehicleToRoadPort.wheelToRoadPort1;\n                    bind rearAxleAssembly.rearWheel2.wheelToRoadPort=vehicleToRoadPort.wheelToRoadPort2;\n                    \n                    satisfy Requirements::vehicleSpecification by vehicle_b{\n                        requirement vehicleMassRequirement:>>vehicleMassRequirement{\n                            attribute redefines massActual=vehicle_b.mass;\n                            attribute redefines fuelMassActual = vehicle_b.fuelTank.fuel.fuelMass;\n                        }\n                    }\n                }\n            }\n            package ActionTree{\n                action providePower:ProvidePower{\n                    in item fuelCmd:FuelCmd redefines pwrCmd;\n                    out wheelToRoadTorque redefines wheelToRoadTorque [2] = distributeTorque.wheelToRoadTorque;\n                    action generateTorque:GenerateTorque {\n                        in item = providePower.fuelCmd;\n                    }\n                    action amplifyTorque:AmplifyTorque;\n                    action transferTorque:TransferTorque;\n                    action distributeTorque:DistributeTorque;\n                    \n                    //named flow\n                    flow generateToAmplify from generateTorque.engineTorque to amplifyTorque.engineTorque;\n                    //unnamed flows\n                    flow amplifyTorque.transmissionTorque to transferTorque.transmissionTorque;\n                    flow transferTorque.driveshaftTorque to distributeTorque.driveshaftTorque;\n                }\n                action performSelfTest: PerformSelfTest;\n                action applyParkingBrake: ApplyParkingBrake;\n                action senseTemperature: SenseTemperature;\n            }                   \n            package DiscreteInteractions{\n                package Sequence{\n                    part def Driver{\n                        port p1;\n                        port p2;\n                    }\n\n                    part part0{\n                        perform action startVehicle{\n                            action turnVehicleOn send ignitionCmd via driver.p1{\n                                in ignitionCmd:IgnitionCmd;\n                            }\n                            action trigger1 accept ignitionCmd:IgnitionCmd via vehicle.ignitionCmdPort;\n                            flow of IgnitionCmd from trigger1.ignitionCmd to startEngine.ignitionCmd;\n                            action startEngine{\n                                in item ignitionCmd:IgnitionCmd; \n                                out item es:EngineStatus;\n                            }\n                            flow of EngineStatus from startEngine.es to sendStatus.es;\n                            action sendStatus send es via vehicle.statusPort{\n                                in es:EngineStatus;\n                            }\n                            action trigger2 accept es:EngineStatus via driver.p2;\n                        }\n                        part driver : Driver {\n                            perform startVehicle.turnVehicleOn;\n                            perform startVehicle.trigger2;\n                            event occurrence driverReady;\n                        }\n                        part vehicle : Vehicle {\n                            perform startVehicle.trigger1;\n                            perform startVehicle.sendStatus;\n                            event occurrence doorClosed;\n                        }\n                        first vehicle.doorClosed then driver.driverReady;\n                        message of ignitionCmd:IgnitionCmd from driver.turnVehicleOn to vehicle.trigger1;  \n                        message of es:EngineStatus from vehicle.sendStatus to driver.trigger2;\n                    }\n                }\n                occurrence CruiseControl1{\n                    part vehicle_b:>PartsTree::vehicle_b{\n                        port redefines setSpeedPort{\n                            event occurrence setSpeedReceived;\n                        }\n                        part redefines speedSensor{\n                            port redefines speedSensorPort{\n                                event occurrence sensedSpeedSent;\n                            }\n                        }\n                        part redefines vehicleSoftware{\n                            part redefines vehicleController{\n                                part redefines cruiseController{\n                                    port redefines setSpeedPort{\n                                        //analagous to gate: event occurrence bound but may not need this since the port is bound\n                                        event occurrence setSpeedReceived = vehicle_b.setSpeedPort.setSpeedReceived;\n                                    }\n                                    port redefines speedSensorPort{\n                                        event occurrence sensedSpeedReceived;\n                                    }\n                                    port redefines cruiseControlPort{\n                                        event occurrence fuelCmdSent;\n                                    }\n                                }\n                            }\n                        }\n                        part redefines engine{\n                            port redefines fuelCmdPort{\n                                event occurrence fuelCmdReceived;\n                            }\n                        }\n                        message sendSensedSpeed of SensedSpeed\n                            from speedSensor.speedSensorPort.sensedSpeedSent to vehicleSoftware.vehicleController.cruiseController.speedSensorPort.sensedSpeedReceived;\n                        message sendFuelCmd of FuelCmd\n                            from vehicleSoftware.vehicleController.cruiseController.cruiseControlPort.fuelCmdSent to engine.fuelCmdPort.fuelCmdReceived;\n                    }\n                }\n                occurrence CruiseControl2{\n                    part vehicle_b:>PartsTree::vehicle_b{\n                        port redefines setSpeedPort{\n                            event occurrence setSpeedReceived;\n                        }\n                        part redefines speedSensor{\n                            port redefines speedSensorPort{\n                                event sendSensedSpeed.source;\n                            }\n                        }\n                        part redefines vehicleSoftware{\n                            part redefines vehicleController{\n                                part redefines cruiseController{\n                                    port redefines setSpeedPort{\n                                        //analagous to gate: event occurrence bound but may not need this since the port is bound\n                                        event occurrence setSpeedReceived = vehicle_b.setSpeedPort.setSpeedReceived;\n                                    }\n                                    port redefines speedSensorPort{\n                                        event occurrence setSpeedReceived=setSpeedPort.setSpeedReceived;\n                                        then event sendSensedSpeed.target;\n                                    }\n                                    port redefines cruiseControlPort{             \n                                        event sendFuelCmd.source;\n                                    }\n                                }\n                            }\n                        }\n                        part redefines engine{\n                            port redefines fuelCmdPort{\n                                event sendFuelCmd.target;\n                            }\n                        }\n                        message sendSensedSpeed of SensedSpeed;\n                        message sendFuelCmd of FuelCmd;\n                    }\n                }\n            }\n            package Requirements{\n                public import RequirementDerivation::*;\n                public import ModelingMetadata::*; // incudes status info\n                item marketSurvey;\n                dependency from vehicleSpecification to marketSurvey;\n                \n                requirement vehicleSpecification{\n                    subject vehicle:Vehicle;\n                    requirement <'1'> vehicleMassRequirement: MassRequirement {\n                        doc /* The total mass of the vehicle shall be less than or equal to the required mass.\n                        Assume total mass includes a full tank of gas of 60 kg*/\n                        attribute redefines massRequired=2000 [kg];                     \n                        attribute redefines massActual default vehicle.dryMass + fuelMassActual;\n                        attribute fuelMassActual:>ISQ::mass;\n                        attribute fuelMassMax:>ISQ::mass = 60 [kg];\n                        assume constraint {fuelMassActual==fuelMassMax}\n                    }\n                    \n                    allocate vehicleMassRequirement to PartsTree::vehicle_b.mass;\n                    \n                    requirement <'2'> vehicleFuelEconomyRequirements{\n                        doc /* fuel economy requirements group */\n                        attribute assumedCargoMass:>ISQ::mass;\n                        requirement <'2_1'> cityFuelEconomyRequirement:FuelEconomyRequirement{\n                            redefines requiredFuelEconomy= 10 [km / L];\n                            assume constraint {assumedCargoMass<=500 [kg]}\n                        }\n                        requirement <'2_2'> highwayFuelEconomyRequirement:FuelEconomyRequirement{\n                            redefines requiredFuelEconomy= 12.75 [km / L];\n                            assume constraint {assumedCargoMass<=500 [kg]}\n                            \n                            //StatusInfo is contained in ModelingMetadata library\n                            // StatusKind has values for open, closed, tbd, tbr, tbd\n                            @StatusInfo {\n                                status = StatusKind::closed;     \n                                originator = \"Bob\";\n                                owner = \"Mary\";\n                            }\n                        }\n                    }\n                }\n                requirement engineSpecification {\n                    subject engine1:Engine;\n                    requirement <'1'> engineMassRequirement: MassRequirement {\n                        doc /* The total mass of the engine shall be less than or equal to the required mass.*/\n                        attribute redefines massRequired=200 [kg];                     \n                        attribute redefines massActual = engine1.mass;\n                    }\n                    requirement torqueGenerationRequirement : TorqueGenerationRequirement{\n                        subject generateTorque default engine1.generateTorque;\n                    }\n\n                    requirement drivePowerOutputRequirement : DrivePowerOutputRequirement{\n                        port torqueOutPort{\n                            out torque:Torque;\n                        }\n                    }\n                }\n                // the engine mass requirement is derived from the vehicle mass requirement\n                #derivation connection {\n                    end #original ::> vehicleSpecification.vehicleMassRequirement;\n                    end #derive ::> engineSpecification.engineMassRequirement;\n                }\n\n            }\n        }    \n        package Engine4Cyl_Variant{\n            public import ModelingMetadata::*; // incudes refinement\n            part engine:Engine{\n                part cylinders:Cylinder[4..8] ordered;\n            }\n            part engine4Cyl:>engine{\n                part redefines cylinders [4];\n                part cylinder1 subsets cylinders[1];\n                part cylinder2 subsets cylinders[1];\n                part cylinder3 subsets cylinders[1];\n                part cylinder4 subsets cylinders[1];\n            }\n            #refinement dependency engine4Cyl to VehicleConfiguration_b::PartsTree::vehicle_b::engine;\n        }\n        package WheelHubAssemblies{\n            // alternative 1 - w/o explicit nesxted interfaces\n            part wheelHubAssy1{\n                part wheel1:Wheel{\n                    port :>>lugNutCompositePort:LugNutCompositePort {\n                        port lugNutPort :>> lugNutPort [5];\n                    }\n                }\n                part hub1:Hub{\n                    port :>> shankCompositePort:ShankCompositePort {\n                        port shankPort :>> shankPort [5];\n                    }\n                }\n                interface wheelHubInterface:WheelHubInterface\n                    connect wheel1.lugNutCompositePort [1] to hub1.shankCompositePort [1];\n            }\n            // alternative 2 - w multiple nesxted interfaces\n            part wheelHubAssy2{\n                part wheel1:Wheel{\n                    port :>>lugNutCompositePort:LugNutCompositePort {\n                        port lugNutPort :>> lugNutPort [5];\n                    }\n                }\n                part hub1:Hub{\n                    port :>> shankCompositePort:ShankCompositePort {\n                        port shankPort :>> shankPort [5];\n                    }\n                }\n                interface wheelHubInterface:WheelHubInterface\n                    connect lugNutCompositePort ::> wheel1.lugNutCompositePort [1] to shankCompositePort ::> hub1.shankCompositePort [1] {\n                        interface wheelFastenerInterface1 :> wheelFastenerInterface\n                            connect lugNutPort ::> lugNutCompositePort.lugNutPort [5] to shankPort ::> shankCompositePort.shankPort [5];\n                        }\n            }\n            // alternative 3 - w explicit nesxted interfaces\n            part wheelHubAssy3{\n                part wheel1:Wheel{\n                    port lugNutCompositePort :>> lugNutCompositePort {\n                        port lugNutPort [5] :>> lugNutPort {\n                            attribute :>> threadDia = 14 [mm];\n                            attribute :>> threadPitch = 1.5 [mm];\n                        }\n                        port lugNutPort1 [1] :> lugNutPort;\n                        port lugNutPort2 [1] :> lugNutPort;\n                        port lugNutPort3 [1] :> lugNutPort;\n                    }\n}\n                part hub1:Hub{\n                    port shankCompositePort :>> shankCompositePort {\n                        port shankPort [5] :>> shankPort {\n                            attribute :>> threadDia = 14 [mm];\n                            attribute :>> threadPitch = 1.5 [mm];\n                            attribute :>> shaftLength = 70 [mm];\n                        }\n                        port shankPort1 [1] :> shankPort;\n                        port shankPort2 [1] :> shankPort;\n                        port shankPort3 [1] :> shankPort;\n                    }\n}\n                interface wheelHubInterface:WheelHubInterface\n                    connect lugNutCompositePort ::> wheel1.lugNutCompositePort [1] to shankCompositePort ::> hub1.shankCompositePort [1] {\n                        interface wheelFastenerInterface1 :> wheelFastenerInterface\n                            connect lugNutPort ::> lugNutCompositePort.lugNutPort1 to shankPort ::> shankCompositePort.shankPort1 {\n                                attribute :>> maxTorque = 90 * 1.356 [N*m];\n                        }\n                        interface wheelFastenerInterface2 :> wheelFastenerInterface\n                            connect lugNutPort ::> lugNutCompositePort.lugNutPort2 to shankPort ::> shankCompositePort.shankPort2 {\n                                attribute :>> maxTorque = 90 * 1.356 [N*m];\n                        }\n                        interface wheelFastenerInterface3 :> wheelFastenerInterface\n                            connect lugNutPort ::> lugNutCompositePort.lugNutPort3 to shankPort ::> shankCompositePort.shankPort3 {\n                                attribute :>> maxTorque = 90 * 1.356 [N*m];\n                        }\n                }\n            }\n        }\n    }\n    package VehicleAnalysis{\n        public import RiskMetadata::*;\n        public import RiskLevelEnum::*;\n        // recursive public import uses double asterisk **\n        public import VehicleConfigurations::VehicleConfiguration_b::**;\n        package FuelEconomyAnalysisModel{\n            public import SampledFunctions::SampledFunction;\n              \n            /*\n            This analysis model was provided by Hisashi Miyashita on January 27, 2021\n              We use the simplest fuel consumption analysis model introduced in:\n              Akcelik, R. \"Fuel efficiency and other objectives in traffic system management.\" Traffic Engineering and Control 22.2 (1981): 54-65. \n\n              Fuel consumption rate f can be decomposed to:\n              f = f_a + f_b * tpd_avg,\n              where tpd_avg is average interrupted travel time per unit distance, actually the inverse of the average velocity [t/km];\n              f_a is the best fuel consumption per distance; and\n              f_b is the additional fuel consumption per distance and average travel time, which can be regarded as the idling fuel consumption.\n              Approximately, it is proportional to engine displacement and it ranges from 0.5 to 0.6 [l/hour/litre of engine displacement]\n              according to:\n              Review of the Incidence, Energy Use and Costs of Passenger Vehicle Idling; Gordon W. Taylor, P.Eng. Prepared for the Office of Energy Efficiency, Natural Resources Canada, 2003\n\n              We assume f_a can be approximated to\n              fuel_consumption / distance = BSFC * SGG * required_power_avg * tpd_avg,\n              where required_power_avg is the required power, and it can be approximately derived from:\n                  total_energy == P_req * tpd_avg * distance == 1/2 * mass / tpd_avg^2\n              This part is computed with BestFuelConsumptionPerDistance calc def.\n\n              BSFC means Brake-Specific Fuel Consumption, defined as gram/power.  SGG is the specific gravity of gasoline.\n              The high octane gasoline is about 0.76[l/kg].\n            */\n            \n            attribute def Scenario :> SampledFunction {\n                attribute wayPoint[1..*] {\n                    attribute elapseTime[1] :> ISQ::time;\n                    attribute position[1] :> ISQ::distance;\n                }\n            }\n            \n            calc def FuelConsumption {\n                in bestFuelConsumption: Real;\n                in idlingFuelConsumption: Real; \n                in tpd_avg:>timePerDistance;\n                attribute f = bestFuelConsumption + idlingFuelConsumption * tpd_avg;\n                return dpv :> distancePerVolume = 1/f;\n            }\n            \n            calc def AverageTravelTimePerDistance {\n                in scenario: Scenario;\n                return tpd_avg:>timePerDistance;\n            }\n            calc def TraveledDistance {\n                in scenario: Scenario;\n                return distance:> length;\n            }\n            calc def IdlingFuelConsumptionPerTime {\n                in engine:Engine;\n                attribute idlingFuelConsumptionPerDisplacement: Real = 0.5;\n                return f_a : Real = engine.displacement * idlingFuelConsumptionPerDisplacement;\n            }\n\n            attribute specificGravityOfGasoline: Real = 0.76;\n            calc def BestFuelConsumptionPerDistance {\n                in mass: MassValue;\n                in bsfc: Real;\n                in tpd_avg:> timePerDistance;\n                in distance:>length;\n                attribute required_power_avg:> ISQ::power;\n                constraint {required_power_avg == 1/2 * mass * tpd_avg **(-3) / distance}\n                return f_b : Real = bsfc * specificGravityOfGasoline * required_power_avg * tpd_avg;\n            }\n\n            calc def ComputeBSFC{\n                in engine: Engine;\n                return : Real;\n            }\n\n            analysis fuelEconomyAnalysis  {    \n                subject = vehicle_b; \n                \n                objective fuelEconomyAnalysisObjective {\n                    doc /*estimate the vehicle fuel economy*/\n                    require vehicleSpecification.vehicleFuelEconomyRequirements;\n                }\n                \n                in attribute scenario: Scenario;\n                // define a series of waypoints\n                \n                attribute distance = TraveledDistance(scenario);\n                attribute tpd_avg = AverageTravelTimePerDistance(scenario);\n                attribute bsfc = ComputeBSFC(vehicle_b.engine);\n                attribute f_a = BestFuelConsumptionPerDistance(vehicle_b.mass, bsfc, tpd_avg, distance);\n                attribute f_b = IdlingFuelConsumptionPerTime(vehicle_b.engine);\n\n                return attribute calculatedFuelEconomy:>distancePerVolume=FuelConsumption(f_a, f_b, tpd_avg);\n            }\n        }\n        package ElectricalPowerAnalysis{\n        }\n        package ReliabilityAnalyis{\n        }\n        package VehicleTradeOffAnalysis{\n            /* The following example provides the rationale for selecting the engine4cyl. \n            The rationale and risk are contained in a metadata library. */\n            \n            @Rationale about engineTradeOffAnalysis::vehicle_b_engine4cyl{\n                explanation = VehicleAnalysis::VehicleTradeOffAnalysis::engineTradeOffAnalysis;          \n                text = \"the engine4cyl was evaluated to have a higher objective function compared to the engine6cyl based on the trade-off analyiss\"; \n            }\n            \n            // The following risk for the engine4cyl could have been included as part of the objective evaluaiton criteria\n            \n            @Risk about engineTradeOffAnalysis::vehicle_b_engine4cyl {\n                totalRisk = medium;\n                technicalRisk = medium;\n                scheduleRisk = medium;\n                costRisk = RiskLevelEnum::low;\n            }\n            @Risk about engineTradeOffAnalysis::vehicle_b_engine4cyl::engine::fuelEfficiency {\n                technicalRisk {\n                    probability = 0.3;\n                    impact = 0.5;\n                }\n            }\n            \n                \n            public import TradeStudies::*;\n            //evaluation function with criterion engine mass, engine power, and engine cost\n            calc def EngineEvaluation {\n                in engineMass:>ISQ::mass;\n                in enginePower:>ISQ::power; \n                in engineFuelEfficiency:Real;\n                in engineCost:Real;\n                return eval:Real;\n            }\n            calc def EngineEvaluation_4cyl {\n                in engineMass:>ISQ::mass;\n                in enginePower:>ISQ::power;\n                in engineFuelEfficiency:Real;\n                in engineCost:Real;\n                return eval:Real;\n            }\n            calc def EngineEvaluation_6cyl {\n                in engineMass:>ISQ::mass;\n                in enginePower:>ISQ::power;\n                in engineFuelEfficiency:Real;\n                in engineCost:Real;\n                return eval:Real;\n            }\n            analysis engineTradeOffAnalysis:TradeStudy{\n                subject vehicleAlternatives[2]:>vehicle_b;   \n                \n                part vehicle_b_engine4cyl:>vehicleAlternatives{   \n                    part engine redefines engine{\n                        part cylinders :>> cylinders [4];\n                        attribute mass redefines mass=180 [kg];\n                        attribute peakHorsePower redefines peakHorsePower = 180 [W];\n                        attribute fuelEfficiency redefines fuelEfficiency=.6;\n                        attribute cost redefines cost = 1000;                     \n                    }\n                }\n                part vehicle_b_engine6cyl:>vehicleAlternatives{   \n                    part engine redefines engine{  \n                        part cylinders redefines cylinders [6];\n                        attribute mass redefines mass=220 [kg];\n                        attribute peakHorsePower redefines peakHorsePower = 220 [W];\n                        attribute fuelEfficiency redefines fuelEfficiency=.5;\n                        attribute cost redefines cost = 1500;\n                    }\n                }\n                \n                objective :MaximizeObjective;\n                    /*Select vehicle alternative with the engine whose evaluation function returns the max value*/\n                \n                calc :> evaluationFunction{\n                    in part vehicle:>vehicle_b_engine4cyl;\n                    return attribute eval:Real=EngineEvaluation_4cyl (vehicle.engine.mass, vehicle.engine.peakHorsePower, vehicle.engine.fuelEfficiency, vehicle.engine.cost); \n                }\n                calc :> evaluationFunction{\n                    in part vehicle:>vehicle_b_engine6cyl;\n                    return attribute eval:Real=EngineEvaluation_6cyl (vehicle.engine.mass, vehicle.engine.peakHorsePower, vehicle.engine.fuelEfficiency, vehicle.engine.cost); \n                }                                                  \n                return part selectedVehicle:>vehicle_b;\n            }\n        }\n    }\n    package VehicleVerification{\n        public import VehicleConfigurations::VehicleConfiguration_b::**;\n        public import VerificationCaseDefinitions::*;\n        public import VerificationCases1::*;\n        // the following is a model library which contains VerdictKind\n        public import VerificationCases::*;\n        public import VerificationSystem::*;\n        package VerificationCaseDefinitions{\n            verification def MassTest;\n            verification def AccelerationTest;\n            verification def ReliabilityTest;\n        }\n        package VerificationCases1{\n            verification massTests:MassTest {\n                subject vehicle_uut :> vehicle_b;\n                actor vehicleVerificationSubSystem_1 = verificationContext.massVerificationSystem;\n                objective {\n                    verify vehicleSpecification.vehicleMassRequirement{\n                        redefines massActual=weighVehicle.massMeasured;\n                    }\n                }     \n                // method kinds are test, demo, analyze, should also include inspection, similarity\n               @ VerificationMethod{\n                    kind = (VerificationMethodKind::test, VerificationMethodKind::analyze);\n                }\n                action weighVehicle {\n                    out massMeasured:>ISQ::mass;\n                }\n                then action evaluatePassFail {\n                    in massMeasured:>ISQ::mass;\n                    out verdict = PassIf(vehicleSpecification.vehicleMassRequirement(vehicle_uut));\n                }\n                flow from weighVehicle.massMeasured to evaluatePassFail.massMeasured;\n                return :>> verdict = evaluatePassFail.verdict;\n            }\n        }\n        package VerificationSystem{\n            part verificationContext{\n                perform massTests;\n                part vehicle_UnitUnderTest :> vehicle_b;\n                part massVerificationSystem{\n                    part scale{\n                        perform massTests.weighVehicle;\n                    }\n                    part operator{\n                        perform massTests.evaluatePassFail;\n                    }\n                }\n            }\n        }\n    }\n    package VehicleIndividuals{\n        individual a:VehicleRoadContext_1{\n            timeslice t0_t2_a{\n                snapshot t0_a {             \n                    attribute t0 redefines time=0 [s];\n                    snapshot t0_r:Road_1{\n                        :>>Road::incline =0;\n                        :>>Road::friction=.1;\n                    }\n                    snapshot t0_v:Vehicle_1{\n                        :>>Vehicle::position=0 [m];\n                        :>>Vehicle::velocity=0 [m];\n                        :>>Vehicle::acceleration=1.96 [m/s**2];\n                        // .2 g where 1 g = 9.8 meters/sec^2\n                        snapshot t0_fa:FrontAxleAssembly_1{\n                            snapshot t0_leftFront:Wheel_1;\n                            snapshot t0_rightFront:Wheel_2;\n                        }\n                    }\n                }\n                snapshot t1_a{\n                    attribute t1 redefines time=1 [s];\n                    snapshot t1_r:Road_1{\n                        :>>Road::incline =0;\n                        :>>Road::friction=.1;\n                    }\n                    snapshot t1_v:Vehicle_1{\n                        :>>Vehicle::position=.98 [m];\n                        :>>Vehicle::velocity=1.96 [m/s];\n                        :>>Vehicle::acceleration=1.96 [m/s**2];\n                        // .2 g where 1 g = 9.8 meters/sec^2\n                        snapshot t1_fa:FrontAxleAssembly_1{\n                            snapshot t1_leftFront:Wheel_1;\n                            snapshot t1_rightFront:Wheel_2;\n                        }\n                    }\n                }\n                snapshot t2_a{\n                    attribute t2 redefines time=2 [s];\n                    snapshot t2_r:Road_1{\n                        :>>Road::incline =0;\n                        :>>Road::friction=.1;\n                    }\n                    snapshot t2_v:Vehicle_1{\n                        :>>Vehicle::position=3.92 [m];\n                        :>>Vehicle::velocity=3.92 [m/s];\n                        :>>Vehicle::acceleration=1.96 [m/s**2];\n                        // .2 g where 1 g = 9.8 meters/sec^2\n                        snapshot t2_fa:FrontAxleAssembly_1{\n                            snapshot t2_leftFront:Wheel_1;\n                            snapshot t2_rightFront:Wheel_2;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    package MissionContext{\n        /* Define mission context with mission use cases for vehicle_b */\n        public import VehicleConfigurations::VehicleConfiguration_b::**;\n        public import ParametersOfInterestMetadata::moe;\n        public import TransportPassengerScenario::*;\n        package ContextDefinitions{\n            part def MissionContext:>GenericContext::Context;\n            part def Road;\n            part def Driver{\n                port handPort:HandPort{\n                }\n                exhibit state driverStates{\n                    state initial;\n                    state wait;\n                    transition initial then wait;\n                    //ignition on\n                    transition 'wait-wait-1'\n                        first wait\n                        do send IgnitionCmd (ignitionOnOff=IgnitionOnOff::on) via handPort\n                        then wait;\n                    // ignition off\n                    transition 'wait-wait-2'\n                        first wait\n                        do send IgnitionCmd (ignitionOnOff=IgnitionOnOff::off) via handPort\n                        then wait;\n                }\n            }\n            part def Passenger;\n            \n            requirement transportRequirements;\n            use case def TransportPassenger{\n                objective TransportObjective {\n                    doc /*deliver passenger to destination safely, comfortably, and within acceptable time*/\n                    require transportRequirements;\n                }\n                subject vehicle:Vehicle;\n                actor environment;\n                actor road;\n                actor driver;\n                actor passenger [0..4];\n                include use case getInVehicle_a:>getInVehicle [1..5];\n                include use case getOutOfVehicle_a:>getOutOfVehicle [1..5];\n            }\n            \n            use case getInVehicle:GetInVehicle {\n                action unlockDoor_in [0..1];\n                then action openDoor_in;\n                then action enterVehicle;\n                then action closeDoor_in;\n            }\n            use case def GetInVehicle{\n                subject vehicle:Vehicle;\n                actor driver [0..1];\n                actor passenger [0..1];\n                assert constraint {driver != null xor passenger != null}\n            }\n\n            use case getOutOfVehicle:GetOutOfVehicle {\n                action openDoor_out;\n                then action exitVehicle;\n                then action closeDoor_out;\n                then action lockDoor_out;\n            }\n            use case def GetOutOfVehicle{\n                subject vehicle:Vehicle;\n                actor driver [0..1];\n                actor passenger [0..1];\n                assert constraint {driver != null xor passenger != null}\n            }\n        }\n        package TransportPassengerScenario{\n            public import ContextDefinitions::TransportPassenger;\n            \n            // this version uses nesting vs fork and join for concurrent actions\n            use case transportPassenger:TransportPassenger{\n                first start; \n                then action a{\n                    action driverGetInVehicle subsets getInVehicle_a[1];\n                    action passenger1GetInVehicle subsets getInVehicle_a[1];\n                }\n                then action trigger accept ignitionCmd:IgnitionCmd;\n                then action b{\n                    action driveVehicleToDestination;\n                    action providePower;   \n                }\n                then action c{\n                    action driverGetOutOfVehicle subsets getOutOfVehicle_a[1];\n                    action passenger1GetOutOfVehicle subsets getOutOfVehicle_a[1];\n                }\n                then done;\n            }\n            \n            \n            //this version uses forks and joins\n            use case transportPassenger_1:TransportPassenger{\n                // declare actions\n                action driverGetInVehicle subsets getInVehicle_a[1];\n                action passenger1GetInVehicle subsets getInVehicle_a[1];\n                action driverGetOutOfVehicle subsets getOutOfVehicle_a[1];\n                action passenger1GetOutOfVehicle subsets getOutOfVehicle_a[1];\n                action driveVehicleToDestination;\n                action providePower;\n                item def VehicleOnSignal;\n                join join1;\n                join join2;\n                join join3;\n                action trigger accept ignitionCmd:IgnitionCmd;\n                \n                // define control flow\n                first start;               \n                then fork fork1;\n                    then driverGetInVehicle;\n                    then passenger1GetInVehicle;\n                first driverGetInVehicle then join1;\n                first passenger1GetInVehicle then join1;\n                first join1 then trigger;\n                first trigger then fork2;\n                //succession trigger if trigger.ignitionCmd.ignitionOnOff==IgnitionOnOff::on then fork2;\n                \n                fork fork2;\n                    then driveVehicleToDestination;\n                    then providePower;\n                first driveVehicleToDestination then join2;\n                first providePower then join2;\n                first join2 then fork3;\n\n                fork fork3; \n                    then driverGetOutOfVehicle;\n                    then passenger1GetOutOfVehicle;\n                first driverGetOutOfVehicle then join3;\n                first passenger1GetOutOfVehicle then join3;\n\n                first join3 then done;\n            }\n        }\n        \n        part missionContext:ContextDefinitions::MissionContext{\n            #moe attribute transportTime :> ISQ::time;\n            perform transportPassenger;\n            // bind parts to actors of use case\n            part road:ContextDefinitions::Road = transportPassenger.road;\n            part driver:ContextDefinitions::Driver = transportPassenger.driver{\n                perform transportPassenger.a.driverGetInVehicle.unlockDoor_in;\n                perform transportPassenger.a.driverGetInVehicle.openDoor_in;\n                perform transportPassenger.a.driverGetInVehicle.enterVehicle; \n                perform transportPassenger.a.driverGetInVehicle.closeDoor_in;\n                perform transportPassenger.c.driverGetOutOfVehicle.openDoor_out;\n                perform transportPassenger.c.driverGetOutOfVehicle.exitVehicle; \n                perform transportPassenger.c.driverGetOutOfVehicle.closeDoor_out;\n                perform transportPassenger.c.driverGetOutOfVehicle.lockDoor_out;\n                perform transportPassenger.b.driveVehicleToDestination;\n            }\n            part passenger1:ContextDefinitions::Passenger = transportPassenger.passenger {\n                perform transportPassenger.a.passenger1GetInVehicle.unlockDoor_in;\n                perform transportPassenger.a.passenger1GetInVehicle.openDoor_in;\n                perform transportPassenger.a.passenger1GetInVehicle.enterVehicle; \n                perform transportPassenger.a.passenger1GetInVehicle.closeDoor_in;\n                perform transportPassenger.c.passenger1GetOutOfVehicle.openDoor_out;\n                perform transportPassenger.c.passenger1GetOutOfVehicle.exitVehicle; \n                perform transportPassenger.c.passenger1GetOutOfVehicle.closeDoor_out;\n                perform transportPassenger.c.passenger1GetOutOfVehicle.lockDoor_out;\n            }\n            part vehicle_b_1:>vehicle_b = transportPassenger.vehicle{\n                attribute :>> position3dVector = (0,0,0) [spatialCF];\n                perform transportPassenger.b.providePower redefines providePower;\n                perform transportPassenger.trigger;\n            }\n            connect driver.handPort to vehicle_b_1.ignitionCmdPort;\n            connect road to vehicle_b_1.vehicleToRoadPort;\n        }\n    }\n    package VehicleSuperSetModel{\n        /* all of vehicleFamily is included in the superset model to enable subsetting a specific vehicle configuration*/\n        package VariationPointDefinitions {\n            variation part def TransmissionChoices:>Transmission {\n                variant part transmissionAutomatic:TransmissionAutomatic;\n                variant part transmissionManual:TransmissionManual;\n            }\n        }\n        package VehiclePartsTree{\n            public import VariationPointDefinitions::*;\n            abstract part vehicleFamily {\n                // variation with nested variation\n                variation part engine:Engine{\n                    variant part engine4Cyl:Engine4Cyl;\n                    variant part engine6Cyl:Engine6Cyl{\n                        part cylinder:Cylinder [6]{\n                            variation attribute diameter:LengthValue{\n                                variant attribute smallDiameter:LengthValue;\n                                variant attribute largeDiagmeter:LengthValue;\n                            }\n                        }\n                    }\n                }\n                // variation point based on variation of part definition\n                part transmissionChoices:TransmissionChoices;\n                // optional variation point\n                part sunroof:Sunroof[0..1];\n                // selection constraint\n                assert constraint selectionConstraint{\n                    (engine==engine::engine4Cyl and transmissionChoices==TransmissionChoices::transmissionManual) xor\n                    (engine==engine::engine6Cyl and transmissionChoices==TransmissionChoices::transmissionAutomatic)\n                }\n                part driveshaft;\n                part frontAxleAssembly;\n                part rearAxleAssembly;\n            }\n        }\n    }\n    package SafetyandSecurityGroups {\n        public import VehicleConfigurations::VehicleConfiguration_b::PartsTree::*;\n        package SafetyGroup {\n            /* Parts that contribute to safety. */\n            public import vehicle_b::**;\n            filter @Safety;\n        }\n        package SecurityGroup {\n            /* Parts that contribute to security. */\n            public import vehicle_b::**;\n            filter @Security;\n        }\n        package SafetyandSecurityGroup {\n            /* Parts that contribute to safety OR security. */\n            public import vehicle_b::**;\n            filter @Safety or @Security;\n        }\n        package MandatorySafetyGroup {\n            /* Parts that contribute to safety AND are mandatory. */\n            public import vehicle_b::**;\n            filter @Safety and Safety::isMandatory;\n        }\n    }\n    package Views_Viewpoints{\n       package ViewpointDefinitions{\n            viewpoint def BehaviorViewpoint;\n            viewpoint def SafetyViewpoint{\n                frame concern vs:VehicleSafety;\n            }\n            part def SafetyEngineer;\n            concern def VehicleSafety {\n                doc /* identify system safety features */\n                stakeholder se:SafetyEngineer;\n            }\n        }\n        package ViewDefinitions{\n            //public import Views to access rendering method library \n            public import Views::*;\n            view def TreeView{\n                render asTreeDiagram;\n            }\n            view def NestedView; \n            view def RelationshipView;\n            view def TableView;\n            view def PartsTreeView:>TreeView {\n                filter @SysML::PartUsage;\n            }\n            view def PartsInterconnection:>NestedView;\n        }\n        package VehicleViews{\n            public import ViewpointDefinitions::*;\n            public import ViewDefinitions::*;\n            public import VehicleConfigurations::VehicleConfiguration_b::*;\n            view vehiclePartsTree_Safety:PartsTreeView{\n                satisfy requirement sv:SafetyViewpoint;\n                expose PartsTree::**;\n                filter @Safety;\n            }\n        }\n    }\n}"
    },
    {
      "name": "VehicleUsages",
      "text": "系统应支持定义和管理不同车辆配置及其部件的连接方式。具体来说，系统能够根据不同的配置要求定义车辆的轮毂、轴组件、轮胎配置等部件，并为每个部件设置不同的属性。举例来说，系统应能够定义具有窄轮辋和宽轮辋的轮胎配置，并为每种轮胎配置指定不同数量的轮螺母和相应的扭矩值（如T1和T2）。\n\n对于每辆车，系统应能够创建不同的部件层次结构并进行部分重定义。例如，在基本的车辆配置（vehicle_C1）中，前轴组件和后轴组件分别配备了不同配置的车轮。前轴组件使用窄轮辋的车轮，后轴组件则使用宽轮辋的车轮，并为每个车轮指定了不同的扭矩（T1和T2）。此外，系统能够定义部件间的连接关系和接口，如前后车轮通过轴组件的安装点进行连接。\n\n系统还应支持更为专业化的车辆配置（如vehicle_C2和vehicle_C3）。在这些配置中，用户可以进一步指定车轮的具体位置并为不同的部件设置端口连接。例如，在vehicle_C2配置中，前轴组件的车轮被分别定义为左前轮和右前轮，并为每个车轮配置相应的安装接口。同时，系统也允许更复杂的部件连接，比如vehicle_C3配置中的传动系统，该配置中包含了连接传动系统和后轴组件的传动轴。传动轴的扭矩传递也可以通过系统进行精确控制。\n\n这些配置和连接的设计应确保车辆的各个部件能够根据需求进行灵活定制，同时确保每个连接和部件的功能能够准确反映车辆的设计需求和技术要求。",
      "label": "package VehicleUsages {\n\tdoc\n\t/*\n\t * Example usages of elements from the vehicle definitions model.\n\t */\n\n\tprivate import SI::N;\n\tprivate import SI::m;\n\tprivate import ScalarFunctions::*;\n\n\tpublic import VehicleDefinitions::*;\n\n\t/* VALUES */\t \n\tT1 = 10.0 [N * m];\n\tT2 = 20.0 [N * m];\n\t\n\t/* PARTS */\t\n\tpart narrowRimWheel: Wheel {\n\t\tdoc /* Narrow-rim wheel configuration with 4 to 5 lugbolts. */\n\n\t\tpart lugbolt: Lugbolt[4..5];\n\t}\n\t\n\tpart wideRimWheel: Wheel {\n\t\tdoc /* Wide-rim wheel configuration with 4 to 6 lugbolts. */\t\n\n\t\tpart lugbolt: Lugbolt[4..6];\n\t}\n\n\tpart vehicle_C1: Vehicle {\n\t\tdoc /* Basic Vehicle configuration showing a part hierarchy. */\n\n\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\tpart frontWheel[2] subsets narrowRimWheel {\n\t\t\t\tpart redefines lugbolt[4] {\n\t\t\t\t\tattribute redefines tighteningTorque = T1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart frontAxle: Axle;\n\t\t}\t\t\n\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\tpart rearWheel[2] subsets wideRimWheel {\n\t\t\t\tpart redefines lugbolt[6] {\n\t\t\t\t\tattribute redefines tighteningTorque = T2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart rearAxle: Axle;\t\t\t\n\t\t}\n\t}\n\t\n\tpart vehicle_C2 subsets vehicle_C1 {\n\t\tdoc /* Specialized configuration with part-specific ports. */\n\n\t\tpart redefines frontAxleAssembly {\n\t\t\tpart leftFrontWheel subsets frontWheel = frontWheel#(1);\n\t\t\tpart rightFrontWheel subsets frontWheel = frontWheel#(2);\n\t\t\t\n\t\t\tinterface leftFrontMount: Mounting connect \n\t\t\t\tfrontAxle.leftMountingPoint to leftFrontWheel.hub;\n\t\t\t\t\n\t\t\tinterface rightFrontMount: Mounting connect \n\t\t\t\tfrontAxle.rightMountingPoint to rightFrontWheel.hub;\n\t\t}\n\t\t\n\t\tpart rearAxleAssembly redefines vehicle_C1::rearAxleAssembly {\n\t\t\tpart leftRearWheel subsets rearWheel = rearWheel#(1);\n\t\t\tpart rightRearWheel subsets rearWheel = rearWheel#(2);\n\n\t\t\tinterface leftRearMount: Mounting connect \n\t\t\t\trearAxle.leftMountingPoint to leftRearWheel.hub;\n\t\t\t\t\n\t\t\tinterface rightRearMount: Mounting connect \n\t\t\t\trearAxle.rightMountingPoint to rightRearWheel.hub;\n\t\t}\t\t\n\t}\n\t\n\tpart vehicle_C3 subsets vehicle_C2 {\n\t\tdoc /* Further specialized configuration with a connection to a deeply-nested port. */\n\n\t\t\n\t\tpart transmission: Transmission {\n\t\t\tport drive: ~DriveIF;\n\t\t}\n\t\t\n\t\tpart redefines rearAxleAssembly {\n\t\t\tpart redefines rearAxle {\n\t\t\t\tport drive: DriveIF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driveShaft connect \n\t\t\ttransDrive ::> transmission.drive to axleDrive ::> rearAxleAssembly.rearAxle.drive {\n\t\t\tflow transDrive.driveTorque to axleDrive.driveTorque;\n\t\t}\t\t\n\t}\n}"
    },
    {
      "name": "VehicleDefinitions",
      "text": "系统应支持定义和管理车辆的各个部件。每辆车应具有质量属性，用于表示其整体质量。车辆的组成部分包括传动系统、车轴组件、车轴、轮子和螺栓等，其中每个部件都有其独特的功能和属性。\n\n车辆部件的定义包括传动系统、车轴和轮子等。车轴由左右安装点组成，轮子则通过轮毂与车轴相连接，螺栓则具备拧紧扭矩属性，用于描述安装过程中所施加的力。系统应允许这些部件通过接口进行连接和交互。\n\n系统应支持接口定义，使得不同部件之间能够正确地传递必要的力和扭矩。例如，系统应提供一个用于轮胎安装的接口，该接口将车轴安装点的扭矩传递给轮毂，以确保轮子的正确安装和操作。\n\n此外，系统应允许通过端口进行扭矩的传递，确保各个部件之间能够准确地传递和应用所需的力，确保车辆各部件协同工作。",
      "label": "package VehicleDefinitions {\n\tdoc\n\t/*\n\t * Example vehicle definitions model.\n\t */\n\n\tprivate import ScalarValues::*;\n\tprivate import Quantities::*;\n\tprivate import MeasurementReferences::*;\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\t\n\t/* PART DEFINITIONS */\n\t\n\tpart def Vehicle {\n\t\tattribute mass :> ISQ::mass;\n\t}\n\tpart def Transmission;\t\n\tpart def AxleAssembly;\n\tpart def Axle {\n\t\tport leftMountingPoint: AxleMountIF;\n\t\tport rightMountingPoint: AxleMountIF;\n\t}\n\tpart def Wheel {\n\t\tport hub: WheelHubIF;\n\t}\n\tpart def Lugbolt {\n\t\tattribute tighteningTorque :> ISQ::torque;\n\t}\n\t\n\t/* PORT DEFINITIONS */\n\t\n\tport def DriveIF { \n\t\tin driveTorque :> ISQ::torque;\n\t}\n\t\n\tport def AxleMountIF { \n\t\tout transferredTorque :> ISQ::torque;\n\t}\n\t\n\tport def WheelHubIF { \n\t\tin appliedTorque :> ISQ::torque;\n\t}\n\t\n\t/* INTERFACE DEFINITIONS */\n\t\n\tinterface def Mounting {\n\t\tdoc /* The definition of the interface for mounting a Wheel to an Axle. */\n\t\tend axleMount: AxleMountIF;\n\t\tend hub: WheelHubIF;\n\t\t\n\t\tflow axleMount.transferredTorque to hub.appliedTorque;\n\t}\n}"
    },
    {
      "name": "RiskMetadataExample",
      "text": "系统应支持为各个部件和元素分配详细的风险元数据，并能够根据不同的风险类型对其进行分类。例如，系统应能够为发动机部件（如四缸发动机）定义多个风险属性，包括整体风险、技术风险和进度风险，并为每种风险类型分配具体的风险等级，如“高”或“中”等。风险信息应可以通过不同的方式表达，例如通过概率和影响度来量化风险。\n\n系统应能够为每个部件或元素提供多个风险元数据实例，以反映不同情境下的风险情况。在此示例中，四缸发动机部件的风险信息可能包括两个风险实例，其中第一个实例描述了整体风险为高，技术风险和进度风险为中等；而第二个实例则量化了整体风险的概率为0.3，影响为0.7。系统应能够支持这种灵活的风险定义方式，确保项目中每个部分的潜在风险都能被合理评估并加以管理。",
      "label": "package RiskMetadataExample {\n\tprivate import RiskMetadata::*;\n\tprivate import RiskLevelEnum::*;\n\t\n    part engine4cyl{\n        @Risk {\n            totalRisk = high;\n            technicalRisk = medium;\n            scheduleRisk = medium;\n        }\n        @Risk {\n        \ttotalRisk { \n        \t\tprobability = 0.3;\n        \t\timpact = 0.7;\n        \t}        \t\n        }\n    }\n        \n}"
    },
    {
      "name": "IssueMetadataExample",
      "text": "系统应支持跟踪和管理与系统组件接口相关的问题，并能够通过元数据标识特定问题的来源。系统应能够定义接口兼容性问题，并提供详细的描述，以帮助开发者理解并解决接口不兼容的情况。例如，系统应能够标识发动机与传动系统接口之间的兼容性问题，说明接口定义和实际使用之间的差异，以便及时解决潜在的兼容性问题。\n\n系统应能够定义接口及其端口，并支持接口的具体实现和连接。每个接口应包含多个端口，并且系统应能够支持端口间的连接操作。在此示例中，系统定义了一个发动机与传动系统之间的接口，该接口包括一个由“DrivePwrPort”定义的端口和一个由“ClutchPort”定义的端口。系统应确保在连接端口时能够正确识别接口定义与实际使用之间的差异，并生成相关的兼容性问题报告。\n\n此外，系统应支持通过端口连接不同的部件，如发动机与传动系统之间的连接。在连接操作中，系统应验证端口兼容性并确保接口和端口之间的一致性。如果发现端口之间不兼容，系统应生成相应的兼容性问题，并为开发者提供修复指导。",
      "label": "package IssueMetadataExample {\n\tprivate import ModelingMetadata::Issue;\n\t\n    //Example: the following identifies an issue with the interface\n    \n    metadata InterfaceCompatibilityIssue : Issue about engineToTransmissionInterface {\n    \ttext = \"This issue is about the interface compatability between the engine and transmission.\" +\n               \"The interface def includes an end defined by a ClutchPort.\" +\n               \"However, the interface usage connects the transmission port that is defined by ~DrivePwrPort.\" +\n               \"This should have surfaced a compatibility issue, since the interface is not really compatible with its definition\";\n    }\n    \n    interface def EngineToTransmissionInterface{\n        end p1:DrivePwrPort;\n        end p2:ClutchPort;\n    }\n    port def DrivePwrPort;\n    port def ClutchPort;\n    \n    part engine{\n        port drivePwrPort:DrivePwrPort;\n    }\n    part transmission{\n        port clutchPort:~DrivePwrPort;\n    }\n\n    interface engineToTransmissionInterface:EngineToTransmissionInterface\n        connect engine.drivePwrPort to transmission.clutchPort;       \n\n}"
    },
    {
      "name": "RequirementMetadataExample",
      "text": "系统应支持定义和管理需求，并能够为每个需求提供详细的元数据描述。需求应能够关联相关的风险信息、状态、起始者和所有者等元数据，以便跟踪需求的状态和管理相关的风险。例如，系统应能够定义一个关于车辆质量的需求，要求车辆的总质量不超过预定的最大质量限制。系统应支持将需求与不同的风险类型（如技术风险、时间风险和成本风险）相关联，以便清晰地识别需求在项目中的风险等级。\n\n系统应能够为每个需求提供文档说明，解释需求的背景和目的。例如，在此示例中，系统应为“车辆质量需求”提供文档，说明车辆的总质量必须小于或等于要求的质量值。系统应允许为需求分配不同的风险级别，并通过元数据描述需求的风险情况，例如“技术风险中等”、“时间风险低”以及“成本风险中等”。\n\n此外，系统应支持需求之间的相互关联和依赖关系。例如，系统应能够定义多个目标需求，并支持将其中一个需求（如负载质量限制）与另一个需求（如车辆质量要求）关联，以便确保所有相关需求都得到满足。系统应能够自动管理这些依赖关系，确保每个需求都能在项目中得到合理的实现。",
      "label": "package RequirementMetadataExample {\n\tprivate import Metaobjects::SemanticMetadata;\n\tprivate import ModelingMetadata::*;\n\tprivate import RiskMetadata::*;\n\tprivate import RiskLevelEnum::*;\n\t\n\trequirement def Goal;\n\trequirement goals : Goal[*] nonunique;\n\tmetadata def goal :> SemanticMetadata {\n\t    :>> baseType = goals meta SysML::RequirementUsage;\n\t}\n\n    requirement <'1'> vehicleMassRequirement {\n        doc /* The total mass of a vehicle shall be less than or equal to the required mass. */\n \n        @StatusInfo {\n            status = StatusKind::tbd;\n            risk {\n\t\t    \ttotalRisk = high;\n\t\t    \ttechnicalRisk = medium;\n\t\t    \tscheduleRisk = low;\n\t\t    \tcostRisk = medium;\n\t\t    }            \n\t\t    originator = \"Bob\";\n            owner = \"Mary\";\n        }\n    }\n    \n    #goal requirement deliverPayload {\n    \tassume #goal constraint payloadMassLimit;\n    \trequire #goal vehicleMassRequirement;\n    }\n    \n}"
    },
    {
      "name": "VerificationMetadataExample",
      "text": "系统应能够为不同的验证需求定义并管理验证用例，并支持为每个验证用例指定不同的验证方法类型。例如，系统应支持定义一个质量测试用例，该用例可以包括多种验证方法，如“测试”和“演示”。此外，系统应能够为验证用例中的具体操作指定特定的验证方法，像是“分析”方法。\n\n在这个示例中，质量测试用例 `MassTest` 包含了多个验证方法，其中包括测试和演示两种方法。对于该验证用例的操作“称重车辆”，系统还可以指定采用“分析”方法进行验证。通过这种方式，系统能够灵活地定义验证过程，并根据需要为每个验证步骤选择适当的验证方法，以确保所有验证活动都能够得到准确和可靠的执行。",
      "label": "package VerificationMetadataExample {\n\tprivate import VerificationCases::*;\n\tprivate import VerificationMethodKind::*;\n\t\n    verification def MassTest;\n    verification massTests:MassTest {\n        @VerificationMethod{ kind = (test,demo); }\n        objective {\n        }\n        action weighVehicle {\n        \t@VerificationMethod{ kind = analyze; }\n        }\n    }\n\t\n}"
    },
    {
      "name": "RationaleMetadataExample",
      "text": "系统应支持记录和管理决策过程中的合理性说明，并能够为特定选择提供详细的解释和分析背景。例如，系统应能够为选定的发动机类型（如四缸发动机）提供决策依据，说明为何选择四缸发动机而非其他类型的发动机，如六缸发动机。该合理性说明应通过元数据进行标识，并与特定的分析结果（如发动机选择的权衡分析）相关联，以便开发者理解决策背后的依据。\n\n系统应能够定义和存储决策分析的相关内容，如权衡分析（Trade Study），并允许通过分析不同的替代方案来支持决策过程。在此示例中，系统定义了一个关于发动机选择的权衡分析，其中比较了两种发动机类型（四缸和六缸）。系统应能够将选择结果与权衡分析的具体内容关联，以提供完整的决策背景。\n\n此外，系统应支持将分析结果与决策选择进行绑定，例如，在选择四缸发动机时，系统应能够记录和引用相关的权衡分析，解释为何最终选择四缸发动机作为车辆配置的一部分。这种分析和合理性说明可以帮助用户在日后回顾决策过程时，理解每个选择的背后理由。",
      "label": "package RationaleMetadataExample {\n\tprivate import ModelingMetadata::Rationale;\n\t\n    /* Example: the following provides the rationale for selecting the engine4cyl based on a trade study analysis. \n    The rationale could be contained in the vehicle configuration with the selected engine */\n    \n    part engine;\n    part engine4cyl :> engine;\n    part engine6cyl :> engine;\n    \n    metadata engineSelectionRationale : Rationale about engine4cyl {\n    \ttext = \"This rationale for selecting the engine4cyl refers to the engineTradeOffAnalysis.\";\n    \texplanation = engineTradeOffAnalysis;\n    }\n    \n    private import TradeStudies::*;\n    analysis engineTradeOffAnalysis:TradeStudy{\n        subject alternatives :> engine [2] = (engine4cyl, engine6cyl);\n\n        /* ... */\n        \n        return selectedEngine :> engine;\n     }\n}"
    },
    {
      "name": "PictureTaking",
      "text": "系统应支持描述拍照过程的操作。该过程首先通过对焦操作生成一个曝光数据，然后将该曝光数据传递给拍摄操作以完成拍照。整个拍照动作通过组合对焦和拍摄两个子动作来实现，确保二者之间的数据流畅衔接，从而模拟完整的拍照流程。",
      "label": "package PictureTaking {\n\tpart def Exposure;\n\t\n\taction def Focus { out xrsl: Exposure; }\n\taction def Shoot { in xsf: Exposure; }\t\n\t\t\n\taction takePicture {\t\t\n\t\taction focus: Focus[1];\n\t\tflow focus.xrsl to shoot.xsf;\n\t\taction shoot: Shoot[1];\n\t}\n}"
    },
    {
      "name": "Camera",
      "text": "系统应支持定义一个相机实体，该实体实现拍照功能。相机包含两个子系统，一个用于对焦，一个用于拍摄。拍照操作被细分为两个步骤，由对焦子系统执行对焦动作，由成像子系统执行拍摄动作，两者共同完成整个拍照过程。",
      "label": "part def Camera {\n\tprivate import PictureTaking::*;\n\t\n\tperform action takePicture[*] :> PictureTaking::takePicture;\n\t\n\tpart focusingSubsystem {\n\t\tperform takePicture.focus;\n\t}\n\t\n\tpart imagingSubsystem {\n\t\tperform takePicture.shoot;\n\t}\n\t\n}"
    },
    {
      "name": "PacketUsage",
      "text": "系统应支持使用不同的热数据包实例，每个实例可以根据需求进行定制。每个热数据包应具备标准的二级头部和用户数据字段，能够传输常规的热数据。\n\n此外，系统应允许在某些情况下对热数据包的数据字段进行重定义。例如，第三个热数据包应支持一个特殊的数据字段，该字段替代了标准的用户数据字段，并添加了一个新的特殊数据属性，该属性用于传输特定的实数数据。\n\n通过这种灵活的数据包定义方式，系统能够适应不同类型的数据传输需求，确保热数据的有效处理和传递，且能够根据具体需求进行扩展和调整。",
      "label": "package 'Packet Usage' {\n\tpublic import Packets::*;\n\tprivate import ScalarValues::Real;\n\t\n\tpart packet1: 'Thermal Data Packet';\n\tpart packet2: 'Thermal Data Packet';\n\tpart packet3: 'Thermal Data Packet' {\n\t\tattribute 'special data field' redefines 'packet data field'{\n\t\t\tattribute redefines 'user data field' {\n\t\t\t\tattribute 'special data': Real;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Packets",
      "text": "系统应定义一个数据包结构，包括多个层次的头部和数据字段。每个数据包应具备一个基本的头部信息，其中包括数据包的版本号、标识符和数据长度。数据包应还包含一个数据字段，数据字段包括一个二级头部和用户数据字段。\n\n此外，系统应能够定义热数据包，该数据包应继承自标准数据包，并对数据字段进行进一步的重定义。热数据包应包含一个新的二级头部，其中包括时间戳和遥测数据类型，用于标识热数据包的特殊属性。用户数据字段也应根据需要进行重定义，包含时间戳和温度值，适应热数据的传输需求。\n\n通过这样的设计，系统能够有效管理不同类型的数据包，特别是那些包含热数据的包，确保能够满足不同应用场景中的数据传输需求。",
      "label": "package Packets {\n\tprivate import ScalarValues::*;\n\tprivate import Time::DateTime;\n\t\n\tattribute 'packet header' { }\n\t\n\tattribute 'packet data field' {\t\n\t\tattribute 'packet secondary header' redefines 'packet header';\n\t\tattribute 'user data field';\n\t}\n\t\n\tpart def 'Data Packet' {\n\t\tattribute 'packet primary header' redefines 'packet header' {\n\t\t\tattribute 'packet version number': Integer;\n\t\t\tattribute 'packet identification': String;\n\t\t\tattribute 'packet data length': Integer;\n\t\t}\n\t\tattribute redefines 'packet data field';\n\t}\n\t\n\tpart def 'Thermal Data Packet' :> 'Data Packet' {\n\t\tattribute 'packet data field' redefines Packets::'packet data field'{\n\t\t\tattribute 'packet secondary header' redefines 'packet header' {\n\t\t\t\tattribute 'packet timestamp': DateTime;\n\t\t\t\tattribute 'telemetry packet type': String;\n\t\t\t}\n\t\t\t\n\t\t\tattribute 'user data field' redefines Packets::'packet data field'::'user data field' {\n\t\t\t\tattribute timestamp: DateTime;\n\t\t\t\tattribute temperature: Real;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Flashlight Example",
      "text": "系统应支持定义一个手电筒模型，描述用户与手电筒以及反射光源之间的交互过程。模型中首先定义了两种属性：开关命令和光信号，并为它们分别创建了相应的端口，用于传递命令和光输出。\n\n在上下文中，用户部件拥有一个开关命令端口，通过执行一个动作发送开关命令；该命令通过接口连接传递到手电筒部件的开关命令端口。手电筒部件接收到命令后，通过其执行的动作，将命令转换为定向光输出，并通过光端口传递该光信号。与此同时，反射光源部件从其光端口接收光信号，并执行反射操作。\n\n整个照明区域的操作通过明确定义的动作和流程进行协调：首先是发送开关命令，其次是根据命令产生定向光，最后是将光信号传递给反射光源。这样，系统能够准确地模拟用户操作、手电筒响应和光信号处理之间的联动过程。",
      "label": "package 'Flashlight' {\n\t\n\tattribute def OnOffCmd;\n\tattribute def Light;\n\t\n\tport def OnOffCmdPort {\n\t\tout onOffCmd : OnOffCmd;\n\t}\n\t\n\tport def LightPort {\n\t\tout light: Light;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport onOffCmdPort: OnOffCmdPort;\n\t\t\tperform illuminateRegion.sendOnOffCmd {\n\t\t\t\tout onOffCmd = onOffCmdPort.onOffCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToFlashlight connect user.onOffCmdPort to flashlight.onOffCmdPort {\n\t\t\tref flow references illuminateRegion.onOffCmdFlow\n\t\t\t\tfrom source.onOffCmd to target.onOffCmd; \n\t\t}\n\t\t\n\t\tpart flashlight {\n\t\t\tport onOffCmdPort: ~OnOffCmdPort;\n\t\t\t\n\t\t\tperform illuminateRegion.produceDirectedLight {\n\t\t\t\tin onOffCmd = onOffCmdPort.onOffCmd;\n\t\t\t\tout light = lightPort.light;\n\t\t\t}\n\t\t\t\n\t\t\tport lightPort: LightPort ;\n\t\t}\n\t\tpart reflectingSource {\n\t\t\tport lightPort: ~LightPort;\n\t\t\t\n\t\t\tperform illuminateRegion.reflectLight {\n\t\t\t\tin light = lightPort.light;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction illuminateRegion {\n\t\taction sendOnOffCmd { out onOffCmd: OnOffCmd; }\n\t\t\n\t\tsuccession flow onOffCmdFlow from sendOnOffCmd.onOffCmd to produceDirectedLight.onOffCmd;\n\t\t\n\t\taction produceDirectedLight { in onOffCmd; out light: Light; }\n\t\t\n\t\tsuccession flow lightFlow from produceDirectedLight.light to reflectLight.light;\n\t\t\n\t\taction reflectLight { in light: Light; }\n\t}\n\t\n\t\n\t\n}"
    },
    {
      "name": "Vehicles",
      "text": "系统应支持车辆及其部件的质量管理，并提供基于部件质量累积的计算方式。每个车辆部件都应具备质量属性，并能够通过唯一的序列号进行标识，以便管理和追踪不同的部件。  \n\n系统应能够定义整车及其组成部件的质量计算方式。整车应包含多个部件，如发动机和传动系统，并通过累加所有部件的质量来计算总质量。整车的唯一标识应继承自其部件的序列号，以确保车辆和部件信息的正确对应。  \n\n此外，系统应支持实例化特定车辆，并能够为其分配具体质量值。例如，某辆车的质量可以被设定为 1000 千克，其中发动机的质量为 100 千克，传动系统的质量为 50 千克。系统应能够自动计算整车的总质量，并确保计算结果与各部件质量的累加值一致，以便准确反映车辆的实际质量情况。",
      "label": "package VehicleMasses {\n\tprivate import ScalarValues::*;\n\tprivate import MassRollup::*;\n\t\n\tpart def CarPart :> MassedThing {\t\t\t\n\t\tattribute serialNumber: String;\n\t}\n\t\n\tpart car: CarPart :> compositeThing {\t\n\t\tattribute vin redefines serialNumber;\n\t\t\n\t\tpart carParts: CarPart[*] redefines subcomponents;\n\t\t\n\t\tpart engine :> simpleThing, carParts {\n\t\t\t//...\n\t\t}\n\t\t\n\t\tpart transmission :> simpleThing, carParts {\n\t\t\t//...\n\t\t}\n\t}\n\n\t// Example usage\n\tprivate import SI::*;\t\n\tpart c :> car {\n\t\tredefines mass = 1000 [kg];\n\t\tpart redefines engine {\n\t\t\tredefines mass = 100 [kg];\n\t\t}\n\t\t\n\t\tpart redefines transmission {\n\t\t\tredefines mass = 50 [kg];\n\t\t}\t\n\t}\n\t\n\t// c.totalMass --> 1150.0 [kg]\n}"
    },
    {
      "name": "MassConstraintExample",
      "text": "系统应支持车辆及其组成部件的质量管理。每辆车应具有一个总质量，该质量应由其发动机和传动系统的质量总和计算得出。发动机和传动系统应分别具有质量属性，并确保它们的质量正确累加至车辆的总质量。\n\n系统应提供质量约束机制，确保车辆的总质量等于其部件质量的总和。质量约束应适用于不同类型的车辆，并可用于验证车辆质量计算的正确性。例如，系统应支持对车辆的质量施加约束，使其等于发动机和传动系统质量的总和，并通过断言机制确保该约束的有效性。\n\n此外，系统应支持通用的质量约束规则，使其适用于多个车辆实例。这些规则应能够对质量进行参数化，使车辆的总质量能够通过所有部件质量的总和自动计算，并适用于不同的车辆配置。例如，系统应提供一种质量计算约束，使车辆的总质量等于所有部件质量的累加值，并允许不同的部件组合满足该约束。\n\n系统应提供最大质量限制机制，确保车辆质量不会超过特定阈值。例如，系统应支持对车辆的最大允许质量进行约束，并通过断言机制验证车辆质量是否符合该限制。如果车辆质量超出限制，应触发相应的约束检查，以确保符合质量规范。",
      "label": "package MassConstraintExample {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\t\n\tpart def Engine {\n\t\tattribute m :> mass;\n\t}\n\t\n\tpart def Transmission {\n\t\tattribute m :> mass;\n\t}\n\t\n\tpart def Vehicle1 {\n\t\tattribute m : MassValue = eng.m + trans.m;\n\t\t\n\t\tpart eng : Engine {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t\t\n\t\tpart trans : Transmission {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t}\n\t\n\tpart def Vehicle2 {\n\t\tassert constraint { m == eng.m + trans.m }\n\t\t\n\t\tattribute m : MassValue;\n\t\t\n\t\tpart eng : Engine {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t\t\n\t\tpart trans : Transmission {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t}\n\t\n\tconstraint def MassConstraint3 {\n\t\tin totalMass : MassValue; \n\t\tin partMasses : MassValue[0..*];\n\t\t\t\n\t\ttotalMass == sum(partMasses)\n\t}\n\t\n\tpart def Vehicle3 {\n\t\tassert constraint massConstraint : MassConstraint3 {\n\t\t\tin totalMass = m;\n\t\t\tin partMasses = (eng.m, trans.m);\n\t\t}\n\t\t\n\t\tattribute m : MassValue;\n\t\t\n\t\tpart eng {\n\t\t\tattribute m : MassValue;\n\t\t}\n\t\t\n\t\tpart trans {\n\t\t\tattribute m : MassValue;\n\t\t}\n\t}\n\t\n\tconstraint def MassConstraint4 {\n\t\tin totalMass : MassValue;\n\t\tin partMasses : MassValue[0..*];\n\t}\n\t\n\tconstraint mc : MassConstraint4 {\n\t\tin totalMass : MassValue; \n\t\tin partMasses : MassValue[0..*];\n\t\t\n\t\ttotalMass == sum(partMasses)\n\t}\n\t\n\tpart def Vehicle4 {\n\t\tassert mc {\n\t\t\tin totalMass = m;\n\t\t\tin partMasses = (eng.m, trans.m);\n\t\t}\n\t\t\n\t\tattribute m : MassValue;\n\t\t\n\t\tpart eng : Engine {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t\t\n\t\tpart trans : Transmission {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t}\n\t\n\tconstraint def MassLimit {\n\t\tin mass : MassValue; \n\t\tin maxMass : MassValue;\n\t\t\t\n\t\tmass <= maxMass\n\t}\n\t\n\tpart def Vehicle5 {\n\t\tassert constraint ml : MassLimit {\n\t\t\tin mass = m;\n\t\t\tin maxMass = 2500 [kg];\n\t\t}\n\t\t\n\t\tattribute m : MassValue = eng.m + trans.m;\n\t\t\n\t\tpart eng : Engine {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t\t\n\t\tpart trans : Transmission {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t}\t\n\t\n}"
    },
    {
      "name": "MassRollup",
      "text": "系统应支持质量管理，并提供不同类型的质量计算方式。每个具有质量的对象都应包含一个基本质量属性，以及一个用于计算其总质量的属性，以便支持不同的质量累积模式。  \n\n系统应能够定义简单对象和复合对象的质量计算方式。对于简单对象，其总质量应直接等于其自身质量。而对于复合对象，其总质量应由自身质量加上所有子组件的总质量之和计算得出，以确保系统能够正确累积多层级结构中的质量信息。  \n\n此外，系统应支持质量计算的过滤机制，使复合对象能够根据特定的最小质量标准筛选子组件，并仅累加符合标准的子组件质量至总质量中。例如，系统应能够定义一个最小质量阈值，使总质量的计算仅包含质量大于该阈值的子组件，从而支持更加灵活的质量计算策略。",
      "label": "package MassRollup {\n\tprivate import NumericalFunctions::*;\n\t\n\tpart def MassedThing {\n\t\tattribute mass :> ISQ::mass; \n\t\tattribute totalMass :> ISQ::mass;\n\t}\n\t\n\tpart simpleThing : MassedThing {\n\t\tattribute redefines totalMass = mass;\n\t}\n\t\n\tpart compositeThing : MassedThing {\n\t\tpart subcomponents: MassedThing[*];\n\t\t\n\t\tattribute redefines totalMass default\n\t\t\tmass + sum(subcomponents.totalMass); \n\t}\n\t\n\tpart filteredMassThing :> compositeThing {\n\t\tabstract attribute minMass :> ISQ::mass;\n\t\t\n\t\tattribute redefines totalMass =\n\t\t\tmass + sum(subcomponents.totalMass.?{in p :> ISQ::mass; p > minMass});\n\t}\n\n}"
    },
    {
      "name": "HSUVRequirements",
      "text": "系统应支持定义一系列功能和性能要求，以确保满足不同类型的需求。在系统中，车辆的要求应包括载客人数、燃油容量和货物承载能力等功能要求，这些要求作为复合子要求在载荷需求中进行定义。\n\n此外，系统应具备环境友好性要求，特别是在排放方面，车辆必须符合2010年京都议定书的排放标准。此外，还应包含性能要求，例如加速、燃油经济性、刹车性能、续航能力和动力等要求，其中燃油经济性要求应要求车辆的燃油效率超过2004年生产的95%的车辆。\n\n系统还应考虑人体工学方面的要求，以确保驾驶的舒适性。最后，系统应允许对特定类型的车辆，如混合动力SUV，设定复合要求，包括载荷、环境友好性、性能和人体工学等方面的要求，以确保该类型的车辆满足特定的规格和标准。",
      "label": "package HSUVRequirements {\n\tprivate import Requirements::*;\n\t\n\trequirement <'UR1.1'> Load: FunctionalRequirementCheck {\n\t\t// The following requirements are composite sub-requirements.\n\t\trequirement Passengers;\n\t\trequirement FuelCapacity;\n\t\trequirement Cargo;\n\t}\n\t\n\trequirement <'UR1.2'> EcoFriendliness: PerformanceRequirementCheck {\n\t\trequirement <'URI1.2.1'> Emissions: PerformanceRequirementCheck {\n\t\t\t/* The car shall meet 2010 Kyoto Accord emissions standards. */\n\t\t}\n\t}\n\t\n\trequirement <'UR1.3'> Performance: PerformanceRequirementCheck {\n\t\trequirement Acceleration;\n\t\trequirement <'UR1.3.1'> FuelEconomy: PerformanceRequirementCheck {\n\t\t\t/* User shall obtain fuel economy better than that provided by\n\t\t\t * 95% of cars built in 2004.\n\t\t\t */\n\t\t}\n\t\trequirement Braking;\n\t\trequirement Range;\n\t\trequirement Power;\n\t}\n\t\n\trequirement <'UR1.4'> Ergonomics;\n\t\n\t// Syntactically, should this be explicitly marked as a \"group\"?\n\trequirement HybridSUVSpec {\t\t\n\t\t// The following requirements are required by reference.\n\t\trequire Load;\n\t\trequire EcoFriendliness;\n\t\trequire Performance;\n\t\trequire Ergonomics;\n\t}\n}"
    },
    {
      "name": "VehicleRequirementDerivation",
      "text": "系统应支持对车辆及其各个部件的质量要求进行建模。首先，系统应能够定义一个车辆的质量要求，该要求应包含对车辆整体质量的限制。车辆的质量要求包括一个质量属性，并且要求该质量小于或等于设定的质量限制。\n\n此外，系统应能够为车辆的每个部件（如底盘和引擎）定义独立的质量要求。例如，底盘质量要求应定义为底盘质量小于或等于设定的质量限制，引擎质量要求也是如此。通过建立这些需求之间的派生连接，系统能够追踪并管理车辆整体质量与各个部件质量之间的关系，确保每个部件和整个车辆都符合相应的质量标准。",
      "label": "package VehicleRequirementDerivation {\n\tprivate import RequirementDerivation::*;\n\t\n\tpart vehicle {\n\t\tattribute mass :> ISQ::mass;\n\t\t\n\t\tpart chassis {\n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\n\t}\n\t\n\trequirement def MassRequirement {\n\t\tsubject mass :> ISQ::mass;\n\t\tattribute massLimit :> ISQ::mass;\n\t\trequire constraint { mass <= massLimit }\n\t}\n\t\n\trequirement vehicleMassRequirement : MassRequirement {\n\t\tsubject :>> mass = vehicle.mass;\n\t}\n\t\n\trequirement chassisMassRequirement : MassRequirement {\n\t\tsubject :>> mass = vehicle.chassis.mass;\n\t}\n\t\n\trequirement engineMassRequirement : MassRequirement {\n\t\tsubject :>> mass = vehicle.engine.mass;\n\t}\n\t\n\t#derivation connection {\n\t\tend #original ::> vehicleMassRequirement;\n\t\tend #derive ::> chassisMassRequirement;\n\t\tend #derive ::> engineMassRequirement;\n\t}\n\t\n}"
    },
    {
      "name": "RequirementDerivationExample",
      "text": "系统应支持对需求的派生和满足进行建模。首先，系统应能够定义原始需求和派生需求。例如，系统可以定义一个需求 `Req1`，以及从该需求派生出的子需求 `Req1_1` 和 `Req1_2`。这些派生需求应通过连接进行表示，确保每个派生需求都能从原始需求中导出。\n\n此外，系统应能够在不同的子系统中满足这些需求。例如，系统中的每个子系统应满足特定的需求：`Req1_1` 由子系统1满足，`Req1_2` 由子系统2满足，而原始需求 `Req1` 由整个系统满足。通过建立需求派生连接，系统应能够追踪这些需求如何在不同层级和组件中传播和满足，确保需求的整体一致性和完整性。",
      "label": "package RequirementDerivationExample {\n\tprivate import RequirementDerivation::*;\n\t\n\trequirement def Req1;\n\t\n\trequirement def Req1_1;\n\trequirement def Req1_2;\n\t\n\t#derivation connection def Req1_Derivation {\n\t\tend #original r1 : Req1;\n\t\tend #derive r1_1 : Req1_1;\n\t\tend #derive r1_2 : Req1_2;\n\t}\n\t\n\tpart def System;\n\tpart def Subsystem1;\n\tpart def Subsystem2;\n\t\n\tpart system : System {\n\t\tpart sub1 : Subsystem1;\n\t\tpart sub2 : Subsystem2;\n\t}\n\t\n\tpart satisfactionContext {\n\t\tref :>> system;\n\t\t\n\t\tsatisfy requirement req1 : Req1 by system;\n\t\tsatisfy requirement req1_1 : Req1_1 by system.sub1;\n\t\tsatisfy requirement req1_2 : Req1_2 by system.sub2;\n\t\t\n\t\t#derivation connection : Req1_Derivation {\n\t\t\tend r1 ::> req1;\n\t\t\tend r1_1 ::> req1_1;\n\t\t\tend r1_2 ::> req1_1;\n\t\t}\n\t\t\n\t}\n\t\n}"
    }
  ]
}