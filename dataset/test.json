{
  "test": [
    {
      "name": "1a-Parts Tree",
      "text": "系统应支持车辆及其部件的模块化配置，通过重定义和子集化来管理不同的车辆版本。每个车辆配置应包含前轴、后轴及其配备的车轮，确保完整的结构和准确的质量定义。\n\n在基本配置中，车辆应具有1750千克的质量。前轴和后轴各包含两个车轮，并以有序方式排列，以便识别左右轮的位置，满足车辆完整性要求。\n\n系统应允许创建车辆的修改版本，在质量为2000千克的变体中，前轴类型可调整为支持转向的前轴，且前后轮可进一步子集化，以便单独标识每个轮胎的位置。每个子配置应继承基础部件的结构和属性，同时允许对质量等关键属性进行重新定义，以支持不同的车辆配置需求。\n\n系统通过这些配置管理，确保车辆结构的模块化和可扩展性，为满足不同车辆版本的设计和生产提供灵活的配置支持。",
      "label": "package '1a-Parts Tree' {\n\tprivate import SI::kg;\n\t\n\tpackage Definitions {\t\n\t\tpart def Vehicle {\n\t\t\tattribute mass :> ISQ::mass {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * The 'mass' attribute property is declared here to be a \n\t\t\t * specialization (subset) of the general 'mass' quantity \n\t\t\t * from the 'ISQ' (International System of Quantities) \n\t\t\t * library model.\n\t\t\t */\n\t\t\t}\n\t\t}\t\t\n\t\tpart def AxleAssembly;\t\t\n\t\tpart def Axle { \n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\t\n\t\tpart def FrontAxle :> Axle { \n\t\t\tattribute steeringAngle: ScalarValues::Real;\n\t\t}\t\n\t\tpart def Wheel;\t\n\t}\n\t\n\tpackage Usages {\n\t\tprivate import Definitions::* {\n\t\t\t/*\n\t\t\t * A \"private\" private import makes the imported names private to the\n\t\t\t * imported package.\n\t\t\t */\n\t\t}\n\t\n\t\tpart vehicle1: Vehicle {\n\t\t\t/*\n\t\t\t * 'vehicle1' is a package-owned part of type Vehicle.\n\t\t\t */\n\t\t\t \n\t\t\tattribute mass redefines Vehicle::mass = 1750 [kg] {\n\t\t\t\t/*\n\t\t\t\t * This redefines the 'mass' attribute property from 'Vehicle' to \n\t\t\t\t * give it a fixed attribute.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\t\t/*\n\t\t\t\t * 'frontAxleAssembly' is a nested part of part 'vehicle1'.\n\t\t\t\t * It is a composite part of the containing part.\n\t\t\t\t * \n\t\t\t\t * (And similarly for 'rearAxleAssembly'.)\n\t\t\t\t */\n\t\t\t\n\t\t\t\tpart frontAxle: Axle;\n\t\t\t\t\n\t\t\t\tpart frontWheel: Wheel[2] ordered {\n\t\t\t\t\t/*\n\t\t\t\t\t * 'frontWheel' is a nested part of type 'Wheel' with\n\t\t\t\t\t * multiplicity \"2\". This means that this axle assembly\n\t\t\t\t\t * must have exactly two wheels. However, there is still\n\t\t\t\t\t * only one 'frontWheel' part. The part is \"ordered\",\n\t\t\t\t\t * so that the first wheel can be distinguished from the\n\t\t\t\t\t * second.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\t\tpart rearAxle: Axle;\n\t\t\t\tpart rearWheel: Wheel[2] ordered;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\n\t\tpart vehicle1_c1: Vehicle {\n\t\t\t/*\n\t\t\t * 'vehicle1_c1' is a modified copy of 'vehicle1'. There is no\n\t\t\t * connection between this copy and the original version in the\n\t\t\t * model.\n\t\t\t */\t\t\t\n\t\t\t\n\t\t\tattribute mass redefines Vehicle::mass = 2000 [kg] {\n\t\t\t\t/*\n\t\t\t\t * The mass attribute has been modified.\n\t\t\t\t */\n\t\t\t}\n\t\n\t\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\t\t\n\t\t\t\tpart frontAxle: FrontAxle {\n\t\t\t\t\t/*\n\t\t\t\t\t * The part 'frontAxle' has been modified to have type 'FrontAxle'.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpart frontWheel: Wheel[2] ordered {\n\t\t\t\t\t/*\n\t\t\t\t\t * The parts 'frontWheel_1' and 'frontWheel_2' have been added\n\t\t\t\t\t * as subsets of 'frontWheel'. These are separate parts from\n\t\t\t\t\t * 'frontWheel', but essentially provide alternate names for\n\t\t\t\t\t * each of the two wheels, as given by their defining expressions.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\tpart frontWheel_1 subsets frontWheel = frontWheel#(1);\n\t\t\t\tpart frontWheel_2 subsets frontWheel = frontWheel#(2);\n\t\t\t}\n\t\t\t\n\t\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\t\t/*\n\t\t\t\t * 'rearAxleAssembly' has also been modified to add subsetting parts\n\t\t\t\t * for 'rearWheel'.\n\t\t\t\t */\n\t\t\t\t\t\t\n\t\t\t\tpart rearAxle: Axle;\n\t\t\t\t\n\t\t\t\tpart rearWheel: Wheel[2] ordered;\n\t\t\t\tpart rearWheel_1 subsets rearWheel = rearWheel#(1);\n\t\t\t\tpart rearWheel_2 subsets rearWheel = rearWheel#(2);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\n\t}\n\t\n}"
    },
    {
      "name": "1c-Parts Tree Redefinition",
      "text": "该系统需求描述定义了一个车辆系统的分层结构及其各组件的属性和关系。系统包含一个车辆部件结构，主要包括车辆（Vehicle）、轴组件（AxleAssembly）、轴（Axle）、前轴（FrontAxle）和轮子（Wheel）。其中，车辆具有质量属性，质量单位为千克；轴组件作为车辆的重要组件，用于安装前后轴和轮子；轴同样具有质量属性，前轴是轴的一种特殊类型，增加了转向角属性。轮子作为独立部件可以被轴组件实例化使用。在具体实例vehicle1中，车辆的质量属性被赋予了默认值1750千克，vehicle1包含前轴组件和后轴组件，其中前轴组件包括前轴和两个按顺序排列的轮子，后轴组件则包括后轴和两个按顺序排列的轮子。接着，vehicle1_c1作为vehicle1的特化，继承了vehicle1的所有部件，但进一步重定义或指定了部分属性：车辆质量被重定义为2000千克，前轴组件被重定义为frontAxleAssembly_c1，其中前轴进一步重定义为frontAxle_c1并指定为特殊化类型FrontAxle，前轴组件中的两个轮子被划分为frontWheel_1和frontWheel_2，分别引用前轮的第一个和第二个实例；后轴组件被重定义为rearAxleAssembly_c1，其中后轴重定义为rearAxle_c1并继承了类型Axle，后轴组件的两个轮子分别引用为rearWheel_1和rearWheel_2，分别对应后轮的第一个和第二个实例。此需求描述细化了车辆系统的层次结构以及各部件的质量和关系定义，便于理解系统部件的组合和继承关系。",
      "label": "package '1c-Parts Tree Redefinition' {\n\tprivate import SI::kg;\n\t\n\tpackage Definitions {\t\n\t\tpart def Vehicle {\n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\t\t\n\t\tpart def AxleAssembly;\t\t\n\t\tpart def Axle { \n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\t\n\t\tpart def FrontAxle :> Axle { \n\t\t\tattribute steeringAngle: ScalarValues::Real;\n\t\t}\t\n\t\tpart def Wheel;\t\n\t}\n\t\t\n\tpackage Usages {\n\t\tprivate import Definitions::*;\n\t\t\n\t\tpart vehicle1: Vehicle {\n\t\t\tattribute mass redefines Vehicle::mass default = 1750 [kg] {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * The mass attribute is redefined to give it a default value.\n\t\t\t */\n\t\t\t}\n\t\t\t\t\t\n\t\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\t\tpart frontAxle: Axle;\t\t\t\n\t\t\t\tpart frontWheel: Wheel[2] ordered;\n\t\t\t}\t\t\n\t\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\t\tpart rearAxle: Axle;\n\t\t\t\tpart rearWheel: Wheel[2] ordered;\n\t\t\t}\t\t\n\t\t}\n\t\n\t\tpart vehicle1_c1 :> vehicle1 {\n\t\t\t/*\n\t\t\t * 'vehicle1_c1' is a specialization of 'vehicle1' (technically \n\t\t\t * a subset). It inherits all the parts of 'vehicle1' and\n\t\t\t * only needs to specify additional or redefined parts.\n\t\t\t */\n\t\t\n\t\t\tattribute mass redefines vehicle1::mass = 2000 [kg] {\n\t\t\t\t/*\n\t\t\t\t * The mass is further redefined to override the default value\n\t\t\t\t * with a bound value for 'vehicle_c1'.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\t\t\n\t\t\tpart frontAxleAssembly_c1 redefines frontAxleAssembly {\n\t\t\t\tpart frontAxle_c1: FrontAxle redefines frontAxle {\n\t\t\t\t\t/*\n\t\t\t\t\t * 'frontAxle_c1' redefines 'frontAxleAssembly'::'frontAxle'\n\t\t\t\t\t * to give it a new name and the specialized type\n\t\t\t\t\t * 'FrontAxle'.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * 'frontWheel' is inherited from 'vehicle1'::'frontAxleAssembly',\n\t\t\t\t * allowing it to be used in the following part declarations.\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\tpart frontWheel_1 subsets frontWheel = frontWheel#(1);\n\t\t\t\tpart frontWheel_2 subsets frontWheel = frontWheel#(2);\n\t\t\t}\n\t\t\t\t\n\t\t\tpart rearAxleAssembly_c1 redefines rearAxleAssembly {\n\t\t\t\tpart rearAxle_c1 redefines rearAxle {\n\t\t\t\t\t/*\n\t\t\t\t\t * 'rearAxle_c1' redefines 'rearAxleAssembly'::'rearAxle'\n\t\t\t\t\t * to give it a new name. It inherits the type 'Axle'\n\t\t\t\t\t * from the redefined part.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\tpart rearWheel_1 subsets rearWheel = rearWheel#(1);\n\t\t\t\tpart rearWheel_2 subsets rearWheel = rearWheel#(2);\n\t\t\t}\t\t\n\t\t}\n\t\t\n\t}\n}"
    },
    {
      "name": "1d-Parts Tree with Reference",
      "text": "该系统需求描述定义了一个车辆和挂车系统的部件结构及其各部件的引用关系。在该系统中，主要包括车辆（Vehicle）、挂车（Trailer）、挂车牵引装置（TrailerHitch）、牵引球（HitchBall）和挂车耦合器（TrailerCoupler）等部件。车辆实例vehicle1_c1具有一个名为hitchBall的引用属性，用于指向一个牵引球，这个牵引球并不属于车辆的组成部分。因此，即使车辆被移除或销毁，该引用的牵引球也不受影响。接着，系统在vehicle1_c1中的hitchBall和挂车牵引装置trailerHitch中的hitchBall之间建立了绑定连接，使它们之间保持一致。此外，挂车牵引装置trailerHitch包含一个牵引球和一个挂车耦合器trailerCoupler。挂车实例trailer1定义了一个trailerCoupler的引用属性，通过绑定连接引用了trailerHitch中的挂车耦合器，实现了挂车和牵引装置之间的绑定关联。这样一来，trailerCoupler在挂车内部实现了引用，而该引用的绑定关系是在挂车部件的内部而非系统层面定义的。此需求描述呈现了车辆与挂车系统中部件间的引用关系和绑定关系，有助于理解各部件的关联和独立性。",
      "label": "package '1d-Parts Tree with Reference' {\n\t\n\tpackage Definitions {\n\t\tpart def Vehicle;\n\t\tpart def Trailer;\n\t\tpart def TrailerHitch;\n\t\tpart def HitchBall;\n\t\tpart def TrailerCoupler;\n\t}\n\t\n\tpackage Usages {\n\t\tprivate import Definitions::*;\n\t\t\n\t\tpart vehicle_trailer_system {\n\t\t\t\n\t\t\tpart vehicle1_c1: Vehicle {\n\t\t\t\tref hitchBall : HitchBall {\n\t\t\t\t\t/*\n\t\t\t\t\t * 'vehicle1_c1'::'hitchBall' is a reference property that\n\t\t\t\t\t * references a hitch ball that is not part of this vehicle. \n\t\t\t\t\t * If 'vehicle1_c1' is removed or destroyed, this does not\n\t\t\t\t\t * effect the hitchBall referenced here.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbind vehicle1_c1.hitchBall = trailerHitch.hitchBall {\n\t\t\t\t/*\n\t\t\t\t * This is a binding connector between the 'hitchBall' in 'vehicle1_c1'\n\t\t\t\t * and the 'hitchBall' in 'trailerHitch'.\n\t\t\t\t */\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpart trailerHitch: TrailerHitch {\t\t\t\t\n\t\t\t\tpart hitchBall: HitchBall;\n\t\t\t\tpart trailerCoupler: TrailerCoupler;\n\t\t\t}\n\t\t\t\n\t\t\tpart trailer1: Trailer {\n\t\t\t\tref trailerCoupler : TrailerCoupler = trailerHitch.trailerCoupler {\n\t\t\t\t\t/*\n\t\t\t\t\t * This is a shorthand for a binding connector between the\n\t\t\t\t\t * 'trailerCoupler' here and the 'trailerCoupler' in 'trailerHitch'.\n\t\t\t\t\t * The binding connector is now contained within the 'trailer1'\n\t\t\t\t\t * part, though, rather than being at the system level. \n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "name": "2a-Parts Interconnection",
      "text": "系统应描述一个复杂的车辆构造和部件间的连接。该系统涉及多个部件，如车辆、发动机、传动系统、后轴、差速器和轮子，每个部件通过定义端口和接口与其他部件进行交互。端口和接口的定义确保了部件之间的有效连接和数据传输。\n\n在系统中，**车辆**（`VehicleA`）通过端口与其他部件进行连接。车辆的燃油命令端口（`fuelCmdPort`）与发动机的燃油命令端口连接，发动机提供驱动力输出到传动系统的离合器端口（`clutchPort`）。传动系统通过其端口（`shaftPort_a`）与驱动轴连接，并与后轴系统（`RearAxleAssembly`）互联。\n\n**驱动轴**（`Driveshaft`）作为接口的媒介，连接了传动系统和后轴组件。通过定义的接口（如`DriveshaftInterface`），驱动轴将数据和动力传递到后轴的各个部分。\n\n**后轴**由两个半轴（`HalfAxle`）组成，分别与差速器（`Differential`）的左右差速端口（`leftDiffPort`和`rightDiffPort`）连接。差速器将动力传递给左半轴和右半轴。每个半轴通过与轮毂的连接，进一步将动力传递到轮子上，确保车辆的运动。\n\n系统还包括多个部件之间的层级和子集关系。例如，后轴组件（`RearAxleAssembly`）包含多个部件和子部件，并通过端口和接口的连接实现精确的数据传递和力的传递。每个轮子都连接到后轴的半轴，并通过“轮到路面端口”（`wheelToRoadPort`）连接到地面。\n\n通过这种层次化的结构和端口定义，系统能够精确地描述各个部件之间的物理连接和操作流程，确保每个部件的功能和行为能够在整体系统中协调一致地工作。",
      "label": "package '2a-Parts Interconnection' {\n\tpublic import Definitions::*;\n\tpublic import Usages::*;\n\n\tpackage Definitions {\t\t\n\t\t// Port Definitions\n\t\t\n\t\tport def FuelCmdPort;\n\t\t\n\t\tport def DrivePwrPort;\n\t\tport def ClutchPort;\n\t\t\n\t\tport def ShaftPort_a;\n\t\tport def ShaftPort_b;\n\t\tport def ShaftPort_c;\n\t\tport def ShaftPort_d;\n\t\t\n\t\tport def DiffPort;\n\t\tport def AxlePort;\n\t\tport def AxleToWheelPort;\n\t\tport def WheelToAxlePort;\n\t\tport def WheelToRoadPort;\n\t\t\n\t\tport def VehicleToRoadPort {\n\t\t\t/*\n\t\t\t * A port definition can have nested ports.\n\t\t\t */\n\t\t \n\t\t\tport wheelToRoadPort: WheelToRoadPort[2];\n\t\t}\n\t\n\t\t// Blocks\n\t\n\t\tpart def VehicleA { \n\t\t\tport fuelCmdPort: FuelCmdPort;\n\t\t\tport vehicleToRoadPort: VehicleToRoadPort;\n\t\t}\n\t\t\n\t\tpart def AxleAssembly;\t\t\n\t\tpart def RearAxleAssembly :> AxleAssembly { \n\t\t\tport shaftPort_d: ShaftPort_d;\n\t\t}\n\t\t\n\t\tpart def Axle;\n\t\tpart def RearAxle :> Axle;\n\t\t\n\t\tpart def HalfAxle { \n\t\t\tport axleToDiffPort: AxlePort;\n\t\t\tport axleToWheelPort: AxleToWheelPort;\n\t\t}\n\t\t\n\t\tpart def Engine { \n\t\t\tport fuelCmdPort: FuelCmdPort;\n\t\t\tport drivePwrPort: DrivePwrPort;\n\t\t}\n\t\n\t\tpart def Transmission { \n\t\t\tport clutchPort: ClutchPort;\n\t\t\tport shaftPort_a: ShaftPort_a;\n\t\t}\n\t\t\n\t\tpart def Driveshaft { \n\t\t\tport shaftPort_b: ShaftPort_b;\n\t\t\tport shaftPort_c: ShaftPort_c;\n\t\t}\t\n\t\t\n\t\tpart def Differential {\n\t\t\t/*\n\t\t\t * Ports do not have to be defined on part defs.\n\t\t\t * They can be added directly to their usages.\n\t\t\t */\n\t\t}\n\t\tpart def Wheel;\n\t\t\n\t\t// Interface Definitions\n\t\t\n\t\tinterface def EngineToTransmissionInterface {\n\t\t\t/*\n\t\t\t * The ends of an interface definition are always ports.\n\t\t\t */\n\t\t\n\t\t\tend drivePwrPort: DrivePwrPort;\n\t\t\tend clutchPort: ClutchPort;\n\t\t}\n\t\t\n\t\tinterface def DriveshaftInterface {\n\t\t\tend shaftPort_a: ShaftPort_a;\n\t\t\tend shaftPort_d: ShaftPort_d;\n\t\t\t\n\t\t\tref driveshaft: Driveshaft {\n\t\t\t\t/*\n\t\t\t\t * 'driveshaft' is a reference to the driveshaft that will\n\t\t\t\t * act as the \"interface medium\" for this interface.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\tconnect shaftPort_a to driveshaft.shaftPort_b {\n\t\t\t\t/*\n\t\t\t\t * The two ends of 'DriveShaftInterface' are always connected\n\t\t\t\t * via the referenced 'driveshaft'.\n\t\t\t\t */\n\t\t\t}\n\t\t\tconnect driveshaft.shaftPort_c to shaftPort_d;\n\t\t}\n\t\t\n\t}\n\t\n\tpackage Usages {\n\t\n\t\tpart vehicle1_c1: VehicleA {\n\t\t\t\t\t\t\n\t\t\tbind fuelCmdPort = engine.fuelCmdPort;\n\t\t\t\n\t\t\tpart engine: Engine;\n\t\t\t\n\t\t\tinterface :EngineToTransmissionInterface\n\t\t\t\tconnect engine.drivePwrPort to transmission.clutchPort {\n\t\t\t\t/*\n\t\t\t\t * A usage of an interface definition connects two ports relative to \n\t\t\t\t * a containing context.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\t\n\t\t\tpart transmission: Transmission;\n\t\t\t\n\t\t\tpart driveshaft: Driveshaft {\n\t\t\t\t/*\n\t\t\t\t * This 'driveshaft' is the part of 'vehicle1_c1' that will act as the\n\t\t\t\t * interface medium in the following 'DriveshaftInterface' usage.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\tinterface :DriveshaftInterface\n\t\t\t\tconnect transmission.shaftPort_a to rearAxleAssembly.shaftPort_d {\n\t\t\t\t\tref :>> driveshaft = vehicle1_c1.driveshaft {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The reference property from 'DriveshaftInterface' is redefined\n\t\t\t\t\t\t * in order to bind it to the appropriate part of 'vehicle1_c1'.\n\t\t\t\t\t\t */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\tpart rearAxleAssembly: RearAxleAssembly {\n\t\t\t\tbind shaftPort_d = differential.shaftPort_d;\n\t\t\t\t\n\t\t\t\tpart differential: Differential {\n\t\t\t\t\tport shaftPort_d: ShaftPort_d {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If the part def has no ports, then they can be defined directly in\n\t\t\t\t\t\t * a usage of the part def.\n\t\t\t\t\t\t */\n\t\t\t\t\t}\n\t\t\t\t\tport leftDiffPort: DiffPort;\n\t\t\t\t\tport rightDiffPort: DiffPort;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinterface differential.leftDiffPort to rearAxle.leftHalfAxle.axleToDiffPort {\n\t\t\t\t\t/*\n\t\t\t\t\t * A connection can be to a port that is arbitrarily deeply nested, on either end. \n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\tinterface differential.rightDiffPort to rearAxle.rightHalfAxle.axleToDiffPort;\n\t\t\n\t\t\t\tpart rearAxle: RearAxle {\n\t\t\t\t\tpart leftHalfAxle: HalfAxle;\n\t\t\t\t\tpart rightHalfAxle: HalfAxle;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconnect rearAxle.leftHalfAxle.axleToWheelPort to leftWheel.wheelToAxlePort;\n\t\t\t\tconnect rearAxle.rightHalfAxle.axleToWheelPort to rightWheel.wheelToAxlePort;\n\t\n\t\t\t\tpart rearWheel: Wheel[2] ordered;\n\t\t\t\t\n\t\t\t\t/* The two rear wheels of 'rearAxleAssembly' must be given\n\t\t\t\t * their own names in order to be referenced in connections.\n\t\t\t\t * \n\t\t\t\t * (\":>\" is a shorthand here for \"subsets\".)\n\t\t\t\t */\n\t\t\t\tpart leftWheel :> rearWheel = rearWheel#(1) {\n\t\t\t\t\tport wheelToAxlePort: WheelToAxlePort;\n\t\t\t\t\tport wheelToRoadPort: WheelToRoadPort;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpart rightWheel :> rearWheel = rearWheel#(2) {\n\t\t\t\t\tport wheelToAxlePort: WheelToAxlePort;\n\t\t\t\t\tport wheelToRoadPort: WheelToRoadPort;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tbind rearAxleAssembly.leftWheel.wheelToRoadPort = \n\t\t\t\t vehicleToRoadPort.leftWheelToRoadPort;\n\t\t\t\t \n\t\t\tbind rearAxleAssembly.rightWheel.wheelToRoadPort = \n\t\t\t\t vehicleToRoadPort.rightWheelToRoadPort;\n\t\t\t\t\n\t\t\tport vehicleToRoadPort redefines VehicleA::vehicleToRoadPort {\n\t\t\t\tport leftWheelToRoadPort :> wheelToRoadPort = wheelToRoadPort#(1);\n\t\t\t\tport rightWheelToRoadPort :> wheelToRoadPort = wheelToRoadPort#(2);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\n\t}\n\t\n}"
    },
    {
      "name": "2c-Parts Interconnection-Multiple Decompositions",
      "text": "该系统描述了一个复杂的部件和子部件的连接，采用了多个层次的分解和复合部件之间的连接。系统将多个部件（`A1`、`B11`、`B12`、`B21`、`B22`、`C1`、`C2`、`C3`、`C4`）进行组合，并通过定义端口、引用和连接，确保它们能够协调工作。\n\n在系统的**第一分解**（`a11`）中，`A1`被分解为两个子系统：`B11`和`B12`。在`B11`中，包含了两个部件`C1`和`C2`，并且通过端口`pa`和`pc`进行了连接。在这个分解中，`C1`的`pb`端口与`C2`的`pc`端口连接，并且在`B11`的`pe`端口和`C1`的`pb`端口之间建立了绑定连接。这个绑定连接同时定义了端口和绑定器。`B12`包含了`C3`和`C4`，并将`C3`的`pd`端口与`B12`的`pf`端口绑定。最后，`B11`的`pe`端口与`B12`的`pf`端口连接，形成了这两个子系统之间的连接。\n\n在**第二分解**（`a12`）中，`A1`再次被分解为两个新的子系统：`B21`和`B22`。在`B21`中，`C1`和`C3`被引用为`a11`中的部件，这些部件不能再次作为复合部件在`a12`中出现。`C1`的`pa`端口与`C3`的`pd`端口连接，并且`B21`的`pg`端口与`C1`的`pa`端口绑定。在`B22`中，`C2`和`C4`作为`a11`中的部件被引用，`B22`的`ph`端口与`C2`的`pc`端口连接。\n\n通过这种分解和连接的方式，系统的不同层次和部件之间实现了复杂的协调与交互。每个子系统不仅包含独立的端口和连接，还通过引用和绑定将不同层次的部件连接起来，确保了功能的实现和部件之间的协调。",
      "label": "package '2c-Parts Interconnection-Multiple Decompositions' {\n\t\n\tpart def A1;\n\t\n\tpart def B11 {\n\t\tport pe;\n\t}\n\tpart def B12 {\n\t\tport pf;\n\t}\n\tpart def B21 {\n\t\tport pg;\n\t}\n\tpart def B22 {\n\t\tport ph;\n\t}\n\t\n\tpart def C1 {\n\t\tport pa;\n\t\tport pb;\n\t}\t\n\tpart def C2 {\n\t\tport pc;\n\t}\n\tpart def C3 {\n\t\tport pd;\n\t}\n\tpart def C4;\n\t\n\tpart a11: A1 {\n\tdoc\n\t/*\n\t * Decomposition 1 - Subsystems b11, b12\n\t */\n\t\n\t\tpart b11: B11 {\n\t\t\tpart c1: C1;\t\t\t\n\t\t\tpart c2: C2;\n\t\t\t\n\t\t\tconnect c1.pa to c2.pc;\n\t\t\t\n\t\t\tport :>> pe = c1.pb {\n\t\t\t\tdoc\n\t\t\t\t/*\n\t\t\t\t * This combines the definition of a port with a binding\n\t\t\t\t * connector. (It is the same notation used to bind a\n\t\t\t\t * attribute to a attribute property or a reference to a reference\n\t\t\t\t * property.)\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart b12: B12 {\n\t\t\tpart c3: C3;\t\t\t\n\t\t\tpart c4: C4;\n\t\t\t\n\t\t\tport :>> pf = c3.pd;\n\t\t}\n\t\t\n\t\tconnect b11.pe to b12.pf;\n\t}\n\t\n\tpart a12: A1 {\n\t\tdoc\n\t\t/*\n\t\t * Decomposition 2 - Assemblies b21, b22\n\t\t */\n\t\n\t\tpart b21: B21 {\n\t\t\t/*\n\t\t\t * The c-level entities are already composite parts within\n\t\t\t * a11, so they cannot also be composite parts within a12.\n\t\t\t */\n\t\t\t \n\t\t\tref c1: C1 = a11.b11.c1;\t\t\t\n\t\t\tref c3: C3 = a11.b12.c3;\n\t\t\t\n\t\t\tconnect c1.pb to c3.pd;\n\t\t\t\n\t\t\tport :>> pg = c1.pa;\n\t\t}\n\t\t\n\t\tpart b22: B22 {\n\t\t\tref c2: C2 = a11.b11.c2;\t\t\t\n\t\t\tref c4: C4 = a11.b12.c4;\n\t\t\t\n\t\t\tport :>> ph = c2.pc;\n\t\t}\n\t}\n}"
    },
    {
      "name": "3a-Function-based Behavior-1",
      "text": "该系统需求描述定义了一个基于功能的扭矩生成和分配流程。首先，在定义包中引入了Torque的别名作为扭矩值的表示，同时定义了燃料命令（FuelCmd）、发动机启动（EngineStart）和发动机关闭（EngineOff）等信号，以便作为异步传输的数据模型。接着，定义了几个动作，用于描述系统的行为，包括“生成扭矩”（Generate Torque）、“放大扭矩”（Amplify Torque）、“传递扭矩”（Transfer Torque）和“分配扭矩”（Distribute Torque），这些动作依次从燃料命令输入开始，通过各级扭矩传输，最终输出到两个轮子。提供动力（Provide Power）的动作聚合了这些动作流程，燃料命令输入到generate torque，然后扭矩值依次流向放大、传递和分配动作，以将输出扭矩分配到两个轮子。各个扭矩传输之间的连接通过流（flow）来实现，从一个动作的输出参数流向下一个动作的输入参数。同时，通过绑定连接器（bind）绑定轮子扭矩，使得distribute torque的输出与wheelTorque1和wheelTorque2保持一致。在控制流部分，使用“起始”和“延续”的流程控制动作顺序，确保在发动机启动信号EngineStart触发后，各个扭矩生成和传输动作才得以执行，而在发动机关闭信号EngineOff触发后，则禁止继续执行这些动作。系统通过这一系列的控制流和数据流定义了从燃料指令输入到轮子扭矩输出的动力传输流程，并确保在发动机状态变更时，行为相应地启动或停止。此描述为理解系统的扭矩生成、传递和分配行为提供了清晰的路径。",
      "label": "package '3a-Function-based Behavior-1' {\n\tpublic import Definitions::*;\n\tpublic import Usages::*;\n\n\tpackage Definitions {\n\t\talias Torque for ISQ::TorqueValue {\n\t\t\t/*\n\t\t\t * The 'TorqueValue' type is aliased as 'Torque'.\n\t\t\t */\n\t\t}\n\t\t\n\t\tattribute def FuelCmd;\n\t\t\n\t\t/*\n\t\t * There is no special construct for modeling \"signals\". Data to be\n\t\t * transmitted asynchronously can simply be modeled using attribute defs.\n\t\t */\n\t\t\n\t\tattribute def EngineStart;\n\t\tattribute def EngineOff;\n\t\t\n\t\t/*\n\t\t * Black box definitions for actions include their inputs and outputs.\n\t\t */\n\t\t\n\t\taction def 'Generate Torque' { in fuelCmd: FuelCmd; out engineTorque: Torque; }\n\t\taction def 'Amplify Torque' { in engineTorque: Torque; out transmissionTorque: Torque; }\n\t\taction def 'Transfer Torque' { in transmissionTorque: Torque; out driveshaftTorque: Torque; }\n\t\taction def 'Distribute Torque' { in driveShaftTorque: Torque; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t\t\n\t\taction def 'Provide Power' { in fuelCmd: FuelCmd; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t\n\t}\n\t\n\tpackage Usages {\n\t\n\t\taction 'provide power': 'Provide Power'{\n\t\t\tin fuelCmd: FuelCmd;\n\t\t\tout wheelTorque1: Torque; \n\t\t\tout wheelTorque2: Torque;\n\t\t\n\t\t\t// ITEM FLOW PART\n\t\t\t\n\t\t\tbind 'generate torque'.fuelCmd = fuelCmd {\n\t\t\t\t/*\n\t\t\t\t * This is a binding connector, just as was used to\n\t\t\t\t * model delegation between ports.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\taction 'generate torque': 'Generate Torque' {\n\t\t\t\t/*\n\t\t\t\t * An action usage inherits parameters from its definition.\n\t\t\t\t * They act as its \"pins\".\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\tflow 'generate torque'.engineTorque \n\t\t\t    to 'amplify torque'.engineTorque {\n\t\t\t\t/*\n\t\t\t\t * A flow is a connection between two actions that streams items from\n\t\t\t\t * an output parameter of one action to an input parameter of the other.\n\t\t\t\t * Note that streaming is a property of the connection, not the\n\t\t\t\t * actions or their parameters.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\taction 'amplify torque': 'Amplify Torque';\n\t\t\t\n\t\t\tflow 'amplify torque'.transmissionTorque \n\t\t\t    to 'transfer torque'.transmissionTorque;\n\t\t\t\n\t\t\taction 'transfer torque': 'Transfer Torque';\n\t\t\t\n\t\t\tflow 'transfer torque'.driveshaftTorque \n\t\t\t    to 'distribute torque'.driveShaftTorque;\n\t\t\t\n\t\t\taction 'distribute torque': 'Distribute Torque';\n\t\t\t\n\t\t\tbind wheelTorque1 = 'distribute torque'.wheelTorque1;\n\t\t\tbind wheelTorque2 = 'distribute torque'.wheelTorque2;\n\t\t\t\n\t\t\t// CONTROL FLOW PART\n\n\t\t\tfirst start then continue {\n\t\t\t\t/*\n\t\t\t\t * A first is an assertion that one thing must occur\n\t\t\t\t * before another, acting like a \"control flow\". 'start' is\n\t\t\t\t * the start snapshot of the action, which acts like an\n\t\t\t\t * \"initial node\".\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\tmerge continue {\n\t\t\t\t/*\n\t\t\t\t * A merge node is necessary to prevent a loop of successions\n\t\t\t\t * from being unsatisfiable.\n\t\t\t\t */\n\t\t\t}\n\t\t\tfirst continue then engineStarted;\n\t\t\t\n\t\t\taction engineStarted accept engineStart: EngineStart {\n\t\t\t\t/*\n\t\t\t\t * An accept action accepts an incoming transfer of some item\n\t\t\t\t * from outside an action, in this case the \"signal\" 'EngineStart'.\n\t\t\t\t * Note that 'engineStarted' is the name of the action, while\n\t\t\t\t * 'engineStart' is the name of the received signal attribute.\n\t\t\t\t */\n\t\t\t}\t\t\t\n\t\t\tfirst engineStarted then engineStopped;\n\t\t\t\t\t\n\t\t\taction engineStopped accept engineOff: EngineOff;\t\n\t\t\tfirst engineStopped then continue;\n\t\t\t\n\t\t\t/*\n\t\t\t * These successions act to \"enable\" the torque-related actions.\n\t\t\t * Each action on the right can only be performed following the\n\t\t\t * completion of a performance of 'engineStarted'.\n\t\t\t */\n\t\t\tfirst engineStarted then 'generate torque';\n\t\t\tfirst engineStarted then 'amplify torque';\n\t\t\tfirst engineStarted then 'transfer torque';\n\t\t\tfirst engineStarted then 'distribute torque';\n\t\t\t\n\t\t\t/*\n\t\t\t * These successions act to \"disable\" the torque-related actions.\n\t\t\t * The performance of the actions on the left cannot continue\n\t\t\t * once there is a performance of 'engineStopped'.\n\t\t\t */\n\t\t\tfirst 'generate torque' then engineStopped;\n\t\t\tfirst 'amplify torque' then engineStopped;\t\t\n\t\t\tfirst 'transfer torque' then engineStopped;\t\t\n\t\t\tfirst 'distribute torque' then engineStopped;\t\t\n\t\t}\n\t\n\t}\n}"
    },
    {
      "name": "3a-Function-based Behavior-2",
      "text": "该系统需求描述了一个基于功能的扭矩生成和分配流程，定义了从燃料命令到扭矩分配给车轮的各个行为。在系统中，扭矩值的类型被定义为Torque，并设置了燃料命令（FuelCmd）、发动机启动（EngineStart）和发动机关闭（EngineOff）等信号，作为数据传输的模型。系统行为包括“生成扭矩”（Generate Torque）、“放大扭矩”（Amplify Torque）、“传递扭矩”（Transfer Torque）和“分配扭矩”（Distribute Torque），依次从燃料命令输入，通过各个步骤传递和放大扭矩，最终输出到两个车轮。Provide Power行为聚合了这一过程：燃料命令作为输入触发generate torque，扭矩值依次流向放大、传递和分配步骤，最终将输出扭矩均分到两个车轮上。通过流（flow）连接各个扭矩传输步骤的输入和输出参数，确保数据依次流动。控制流部分则通过顺序控制符号简化了流程，通过“起始”和“延续”来控制行为的执行顺序。当EngineStart信号触发时，各个扭矩生成和传递的行为开始执行；当EngineOff信号触发后，这些行为立即停止。该系统需求描述了从燃料输入到轮子扭矩输出的动力传输过程，并通过控制流确保发动机状态的变化能有序启动和停止相关行为，为系统的扭矩生成和分配过程提供了清晰的逻辑和流程控制。",
      "label": "package '3a-Function-based Behavior-2' {\n\tpublic import Definitions::*;\n\tpublic import Usages::*;\n\n\tpackage Definitions {\n\t\talias Torque for ISQ::TorqueValue;\n\t\t\n\t\t// ATTRIBUTE DEFINITIONS\n\t\t\n\t\tattribute def FuelCmd;\n\t\t\n\t\tattribute def EngineStart;\n\t\tattribute def EngineOff;\n\t\t\n\t\t// ACTION DEFINITIONS\n\t\t\n\t\taction def 'Generate Torque' { in fuelCmd: FuelCmd; out engineTorque: Torque; }\n\t\taction def 'Amplify Torque' { in engineTorque: Torque; out transmissionTorque: Torque; }\n\t\taction def 'Transfer Torque' { in transmissionTorque: Torque; out driveshaftTorque: Torque; }\n\t\taction def 'Distribute Torque' { in driveShaftTorque: Torque; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t\t\n\t\taction def 'Provide Power' { in fuelCmd: FuelCmd; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t\n\t}\n\t\n\tpackage Usages {\n\t\n\t\taction 'provide power': 'Provide Power'{\n\t\t\tin fuelCmd: FuelCmd;\n\t\t\tout wheelTorque1: Torque; \n\t\t\tout wheelTorque2: Torque;\n\n\t\t\t// ITEM FLOW PART\n\t\t\t\n\t\t\taction 'generate torque': 'Generate Torque'{\n\t\t\t\t/*\n\t\t\t\t * The binding connector shorthand can be used on action parameters.\n\t\t\t\t */\n\t\t\t\tin fuelCmd = 'provide power'::fuelCmd;\n\t\t\t}\n\t\t\t\n\t\t\tflow 'generate torque'.engineTorque \n\t\t\t    to 'amplify torque'.engineTorque;\n\t\t\t\n\t\t\taction 'amplify torque': 'Amplify Torque';\n\t\t\t\n\t\t\tflow 'amplify torque'.transmissionTorque \n\t\t\t    to 'transfer torque'.transmissionTorque;\n\t\t\t\n\t\t\taction 'transfer torque': 'Transfer Torque';\n\t\t\t\n\t\t\tflow 'transfer torque'.driveshaftTorque \n\t\t\t    to 'distribute torque'.driveShaftTorque;\n\t\t\t\n\t\t\taction 'distribute torque': 'Distribute Torque';\n\t\t\t\n\t\t\t// CONTROL FLOW PART\n\n\t\t\t/*\n\t\t\t * The following uses a shorthand for a sequence of successions.\n\t\t\t * The source of the first first is given by \"first start\",\n\t\t\t * and the target of each succeeding first is indicated by\n\t\t\t * using the \"then\" keyword.\n\t\t\t */\n\t\t\tfirst start;\n\t\t\tthen merge continue;\t\n\t\t\tthen action engineStarted accept engineStart: EngineStart;\t\t\t\n\t\t\tthen action engineStopped accept engineOff: EngineOff;\t\n\t\t\tthen continue;\n\t\t\t\n\t\t\t/* Enable torque generation. */\n\t\t\tfirst engineStarted then 'generate torque';\n\t\t\tfirst engineStarted then 'amplify torque';\n\t\t\tfirst engineStarted then 'transfer torque';\n\t\t\tfirst engineStarted then 'distribute torque';\n\t\t\t\n\t\t\t/* Disable torque generation. */\n\t\t\tfirst 'generate torque' then engineStopped;\t\t\n\t\t\tfirst 'amplify torque' then engineStopped;\t\t\n\t\t\tfirst 'transfer torque' then engineStopped;\t\t\n\t\t\tfirst 'distribute torque' then engineStopped;\t\t\n\t\t}\n\t\n\t}\n}"
    },
    {
      "name": "3a-Function-based Behavior-3",
      "text": "该系统需求描述了一个循环控制的扭矩生成和分配流程，定义了从燃料指令输入到扭矩分配给车轮的行为。首先，该系统包含燃料指令（FuelCmd）、发动机启动（EngineStart）和发动机关闭（EngineOff）的信号类型，用于控制扭矩生成流程的开启和终止。系统行为的执行从接受EngineStart信号开始，触发一系列动作依次执行：生成扭矩（Generate Torque）、放大扭矩（Amplify Torque）、传递扭矩（Transfer Torque）和分配扭矩（Distribute Torque）。在Provide Power行为中，fuelCmd作为输入提供给generate torque，并通过流连接传递至各步骤的输入和输出参数，直到扭矩输出至两个车轮。循环结构确保该过程在每次接受到EngineStart信号时启动，并在接受到EngineOff信号后终止。通过这种方式，系统实现了从燃料指令输入到扭矩生成、放大、传递和分配至车轮的完整控制流程，并根据发动机信号的状态变更来有序启动和停止各个相关行为，为系统的动力传输过程提供了灵活的控制机制。",
      "label": "package '3a-Function-based Behavior-5' {\n\tpublic import Definitions::*;\n\tpublic import Usages::*;\n\n\tpackage Definitions {\n\t\talias Torque for ISQ::TorqueValue;\n\t\t\n\t\t// ATTRIBUTE DEFINITIONS\n\t\t\n\t\tattribute def FuelCmd;\n\t\t\n\t\tattribute def EngineStart;\n\t\tattribute def EngineOff;\n\t\t\n\t\t// ACTION DEFINITIONS\n\t\t\n\t\taction def 'Generate Torque' { in fuelCmd: FuelCmd; out engineTorque: Torque; }\n\t\taction def 'Amplify Torque' { in engineTorque: Torque; out transmissionTorque: Torque; }\n\t\taction def 'Transfer Torque' { in transmissionTorque: Torque; out driveshaftTorque: Torque; }\n\t\taction def 'Distribute Torque' { in driveShaftTorque: Torque; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t\t\n\t\taction def 'Provide Power' { in fuelCmd: FuelCmd; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t\n\t}\n\t\n\tpackage Usages {\n\t\n\t\taction 'provide power': 'Provide Power' {\n\t\t\t// PARAMETERS\n\t\t\t\n\t\t\tin fuelCmd: FuelCmd; \n\t\t\tout wheelTorque1: Torque; \n\t\t\tout wheelTorque2: Torque;\n\t\t\n\t\t\tloop {\n\t\t\t\taccept engineStart : EngineStart;\n\t\t\t\tthen action {\n\t\t\t\t\taction 'generate torque': 'Generate Torque' {\n\t\t\t\t\t\tin fuelCmd = 'provide power'::fuelCmd;\n\t\t\t\t\t\tout engineTorque: Torque;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tflow 'generate torque'.engineTorque \n\t\t\t\t\t    to 'amplify torque'.engineTorque;\n\t\t\t\t\t\n\t\t\t\t\taction 'amplify torque': 'Amplify Torque' {\n\t\t\t\t\t\tin engineTorque: Torque;\n\t\t\t\t\t\tout transmissionTorque: Torque;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tflow 'amplify torque'.transmissionTorque \n\t\t\t\t\t    to 'transfer torque'.transmissionTorque;\n\t\t\t\t\t\n\t\t\t\t\taction 'transfer torque': 'Transfer Torque' {\n\t\t\t\t\t\tin transmissionTorque: Torque; \n\t\t\t\t\t\tout driveshaftTorque: Torque;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tflow 'transfer torque'.driveshaftTorque \n\t\t\t\t\t    to 'distribute torque'.driveshaftTorque;\n\t\t\t\t\t\n\t\t\t\t\taction 'distribute torque': 'Distribute Torque' {\n\t\t\t\t\t\tin driveshaftTorque: Torque;\n\t\t\t\t\t\tout wheelTorque1: Torque;\n\t\t\t\t\t\tout wheelTorque2: Torque;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthen action accept engineOff : EngineOff;\n\t\t\t}\t\n\t\t}\n\t\n\t}\n}"
    },
    {
      "name": "3c-Function-based Behavior-structure mod-1",
      "text": "该系统需求描述了一个车辆和挂车的连接结构以及连接行为。系统包含车辆（Vehicle）和挂车（Trailer），其中车辆框架（VehicleFrame）包含一个牵引球（HitchBall），而挂车框架（TrailerFrame）包含一个挂车耦合器（TrailerCoupler）。定义了一个连接结构TrailerHitch，其一端为牵引球，另一端为挂车耦合器。在系统中，vehicle-trailer system使用了一个TrailerHitch连接，将车辆的牵引球连接到挂车的挂车耦合器。行为部分定义了连接和断开挂车的操作：首先，通过connect trailer to vehicle动作，创建一个TrailerHitch连接，将挂车连接到车辆；然后，通过destroy connection of trailer to vehicle动作销毁连接对象；最后，通过disconnect trailer from vehicle动作将TrailerHitch连接设置为null，以断开挂车和车辆的连接。整个需求描述了从连接到断开挂车的过程，清晰地定义了各部件的结构关系和连接管理的行为。",
      "label": "package '3c-Function-based Behavior-structure mod-1' {\n\t\n\tpart def Vehicle;\n\tpart def VehicleFrame;\n\t\n\tpart def HitchBall;\n\tpart def TrailerCoupler;\n\t\n\tpart def Trailer;\n\tpart def TrailerFrame;\n\t\n\tconnection def TrailerHitch {\n\t\tend hitch : HitchBall;\n\t\tend coupler : TrailerCoupler;\n\t}\n\t\n\tpart 'vehicle-trailer system' {\n\t\t\n\t\tpart vehicle : Vehicle {\n\t\t\tpart vehicleFrame : VehicleFrame {\n\t\t\t\tpart hitch : HitchBall;\n\t\t\t}\n\t\t}\n\t\t\n\t\tconnection trailerHitch : TrailerHitch[0..1]\n\t\t\tconnect vehicle.vehicleFrame.hitch to trailer.trailerFrame.coupler;\n\t\t\n\t\tpart trailer : Trailer {\n\t\t\tpart trailerFrame : TrailerFrame {\n\t\t\t\tpart coupler : TrailerCoupler;\n\t\t\t}\n\t\t}\n\t\t\n\t\taction {\n\t\t\t// Create a link and assign it as the TrailerHitch connection.\n\t\t\t// Link participants are determined from inherited ends.\n\t\t\taction 'connect trailer to vehicle'\n\t\t\t\tassign 'vehicle-trailer system'.trailerHitch := TrailerHitch();\n\t\t\t\t\n\t\t\t// Destroy the link object.\n\t\t\tthen action 'destroy connection of trailer to vehicle' : \n\t\t\t\tOccurrenceFunctions::destroy {\n\t\t\t\tinout occ = 'vehicle-trailer system'.trailerHitch;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Remove the link from the TrailerHitch connection.\n\t\t\tthen action 'disconnect trailer from vehicle'\n\t\t\t\tassign 'vehicle-trailer system'.trailerHitch := null;\n\t\t}\t\n\t}\t\n}"
    },
    {
      "name": "3c-Function-based Behavior-structure mod-2",
      "text": "该系统需求描述了一个车辆和挂车的连接结构及其连接和断开行为。系统包含车辆（Vehicle）和挂车（Trailer），其中车辆框架（VehicleFrame）中设置了牵引球（HitchBall），挂车框架（TrailerFrame）中设置了挂车耦合器（TrailerCoupler）。定义了连接结构TrailerHitch，用于连接牵引球和挂车耦合器。在vehicle-trailer system中，使用TrailerHitch连接将车辆的牵引球连接至挂车的耦合器。行为部分包含了连接和断开挂车的动作：首先，执行connect trailer to vehicle动作时，系统保证连接存在，即在执行此动作期间，TrailerHitch连接为1个；随后执行disconnect trailer from vehicle动作，系统保证在该动作执行期间不存在任何连接，即TrailerHitch连接为0个。通过这两个动作，系统定义了从挂车连接到断开过程的状态转变，并确保每个动作执行时的连接状态符合预期。",
      "label": "package '3c-Function-based Behavior-structure mod-2' {\n\t\n\tpart def Vehicle;\n\tpart def VehicleFrame;\n\t\n\tpart def HitchBall;\n\tpart def TrailerCoupler;\n\t\n\tpart def Trailer;\n\tpart def TrailerFrame;\n\t\n\tconnection def TrailerHitch {\n\t\tend hitch : HitchBall;\n\t\tend coupler : TrailerCoupler;\n\t}\n\t\n\tpart 'vehicle-trailer system' {\n\t\t\n\t\tpart vehicle : Vehicle {\n\t\t\tpart vehicleFrame : VehicleFrame {\n\t\t\t\tpart hitch : HitchBall;\n\t\t\t}\n\t\t}\n\t\t\n\t\tconnection trailerHitch : TrailerHitch[0..1]\n\t\t\tconnect vehicle.vehicleFrame.hitch to trailer.trailerFrame.coupler;\n\t\t\n\t\tpart trailer : Trailer {\n\t\t\tpart trailerFrame : TrailerFrame {\n\t\t\t\tpart coupler : TrailerCoupler;\n\t\t\t}\n\t\t}\n\t\t\n\t\tperform action {\n\t\t\taction 'connect trailer to vehicle' {\n\t\t\t\t// Assert that exactly one connection exists during the\n\t\t\t\t// performance of this action.\n\t\t\t\tabstract ref :>> trailerHitch[1];\n\t\t\t}\n\t\t\tthen action 'disconnect trailer from vehicle' {\n\t\t\t\t// Assert that exactly no connection exists during the\n\t\t\t\t// performance of this action.\n\t\t\t\tabstract ref :>> trailerHitch[0];\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
    },
    {
      "name": "3c-Function-based Behavior-structure mod-3",
      "text": "该系统需求描述了车辆与挂车之间的连接和断开操作。系统中包含车辆和挂车两个主要部件，车辆的结构中定义了一个带有牵引球（HitchBall）的车辆框架（VehicleFrame），而挂车的结构中定义了一个带有挂车耦合器（TrailerCoupler）的挂车框架（TrailerFrame）。挂车耦合器包含一个引用属性hitch，用于指向车辆的牵引球。在行为部分，系统首先通过connect trailer to vehicle动作将车辆的牵引球插入到挂车的耦合器中，即将trailer.trailerFrame.coupler.hitch引用指向vehicle.vehicleFrame.hitch，从而实现挂车与车辆的连接；接着通过disconnect trailer from vehicle动作将挂车耦合器中的牵引球引用设置为null，实现挂车与车辆的断开。此需求描述了挂车与车辆之间的连接和断开流程，清晰地定义了挂车与车辆在连接状态和断开状态下的结构关系。",
      "label": "package '3c-Function-based Behavior-structure mod-3' {\n\t\n\tpart def Vehicle;\n\tpart def VehicleFrame;\n\tpart def HitchBall;\n\tpart def Trailer;\n\tpart def TrailerFrame;\n\tpart def TrailerCoupler;\n\t\n\tpart vehicle : Vehicle {\n\t\tpart vehicleFrame : VehicleFrame {\n\t\t\tpart hitch : HitchBall;\n\t\t}\n\t}\n\t\n\tpart trailer : Trailer {\n\t\tpart trailerFrame : TrailerFrame {\n\t\t\tpart coupler : TrailerCoupler {\n\t\t\t\tref part hitch : HitchBall;\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\t\t\n\taction {\n\t\t// Insert the vehicle HitchBall into the TrailerCoupler.\n\t\taction 'connect trailer to vehicle'\n\t\t\tassign trailer.trailerFrame.coupler.hitch := vehicle.vehicleFrame.hitch;\n\t\t\n\t\t// Remove the HitchBall from the TrailerCoupler.\n\t\tthen action 'disconnect trailer from vehicle'\n\t\t\tassign trailer.trailerFrame.coupler.hitch := null;\n\t}\n}"
    },
    {
      "name": "3d-Function-based Behavior-item",
      "text": "该系统需求描述了一个燃料传输过程，从存储单元开始，经过泵传递到车辆的燃料储存系统。系统中定义了燃料（Fuel）作为传输的对象，涉及的部件包括存储罐（StorageTank）、泵（Pump）和车辆（Vehicle），各部件之间通过端口传递燃料。首先，燃料从存储罐的输出端口fuelOutPort流向泵的输入端口fuelInPort。泵包含执行PumpFuel的动作，将输入端口的燃料传输至输出端口。接着，燃料从泵的输出端口流向车辆的输入端口fuelInPort。车辆包含一个燃料箱（FuelTank），该燃料箱有最大容积（volumeMax）和当前燃料量（fuelLevel），其燃料量是燃料体积与最大容积的比值。燃料箱内的燃料量属性为保守属性（isConserved = true），表示燃料在系统内的数量是守恒的。总体上，该需求描述了燃料从存储罐传输到车辆燃料箱的整个过程，定义了各部件之间的流动关系和存储属性。",
      "label": "package '3d-Function-based Behavior-item' {\n\tprivate import ScalarValues::Real;\n\tpublic import Definitions::*;\n\tpublic import Usages::*;\n\t\n\tpackage Definitions {\n\t\t\n\t\titem def Fuel;\n\t\t\n\t\tport def FuelPort {\n\t\t\tout item fuel: Fuel;\n\t\t}\n\t\t\t\t\n\t\tpart def Pump {\n\t\t\tport fuelInPort : ~FuelPort;\n\t\t\tport fuelOutPort : FuelPort;\n\t\t}\n\t\t\n\t\tpart def StorageTank {\n\t\t\tport fuelOutPort : FuelPort;\n\t\t}\n\t\t\n\t\tpart def FuelTank {\n\t\t\tport fuelInPort : ~FuelPort;\n\t\t}\n\t\t\n\t\tpart def Vehicle {\n\t\t\tport fuelInPort : ~FuelPort;\n\t\t}\n\t\t\n\t\taction def PumpFuel {\n\t\t\tin fuelIn : Fuel;\n\t\t\tout fuelOut : Fuel;\n\t\t}\n\t\t\n\t}\n\t\n\tpackage Usages {\n\t\t\n\t\tpart context {\n\t\t\t\n\t\t\t/* Storage Element */\n\t\t\tpart storageTank : StorageTank;\n\t\t\t\n\t\t\tflow of  fuel : Fuel\n\t\t\t\tfrom storageTank.fuelOutPort.fuel to pump.fuelInPort.fuel {\n\t\t\t\t/*\n\t\t\t\t * Note: Explicitly notating that the flow is \"of fuel : Fuel\" is optional.\n\t\t\t\t */\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpart pump : Pump {\n\t\t\t\tperform action pumpFuel : PumpFuel {\n\t\t\t\t\tin fuelIn = fuelInPort.fuel;\n\t\t\t\t\tout fuelOut = fuelOutPort.fuel;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tflow of fuel : Fuel\n\t\t\t\tfrom pump.fuelOutPort.fuel to vehicle.fuelInPort.fuel;\n\t\t\t\n\t\t\tpart vehicle : Vehicle {\n\t\t\t\tflow fuelInPort.fuel to fuelTank.fuel {\n\t\t\t\t\t/* \n\t\t\t\t\t * Note: The semantics of flowing to a \"stored item\" is tentative.\n\t\t\t\t\t */\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* Storage Element */\n\t\t\t\tpart fuelTank : FuelTank {\n\t\t\t\t\tattribute volumeMax : Real;\n\t\t\t\t\tattribute fuelLevel : Real = fuel.volume / volumeMax;\n\t\t\t\t\t\n\t\t\t\t\t /* Stored Item */\n\t\t\t\t\titem fuel : Fuel {\n\t\t\t\t\t\tattribute volume : Real;\n\t\t\t\t\t\t/* isConserved = true */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "name": "3e-Function-based Behavior-item",
      "text": "该系统需求描述了车辆在装配线上的组装过程，包括将变速器和发动机逐步组装至车辆中的行为。系统定义了车辆装配（VehicleAssembly）和完整车辆（AssembledVehicle）项，及其部件变速器（Transmission）和发动机（Engine）。在AssemblyLine中，首先执行assemble transmission into vehicle动作，将一个未包含变速器和发动机的车辆装配项作为输入，并将变速器加入到车辆中，生成仅缺少发动机的车辆装配项。接下来，assemble engine into vehicle动作以不含发动机的车辆装配项和发动机为输入，将发动机加入，生成已完整组装的车辆。装配完成后，通过绑定连接将生成的assembledVehicle与定义的vehicle部分关联，最终的vehicle包含变速器和发动机，并执行providePower动作。整个描述细化了车辆装配过程中各部件的逐步添加及其与完整车辆的关系，实现了装配线上的有序装配流程。",
      "label": "package '3e-Function-based Behavior-item' {\n\tpublic import Definitions::*;\n\t\n\tpackage Definitions {\n\t\t\n\t\titem def VehicleAssembly;\n\t\titem def AssembledVehicle :> VehicleAssembly;\n\t\t\n\t\tpart def Vehicle :> AssembledVehicle;\t\t\n\t\tpart def Transmission;\n\t\tpart def Engine;\t\t\n\t\t\n\t}\n\t\n\tpackage Usages {\n\t\t\n\t\tpart AssemblyLine {\n\t\t\n\t\t\tperform action 'assemble vehicle' {\n\t\t\t\t\n\t\t\t\taction 'assemble transmission into vehicle' {\n\t\t\t\t\tin item 'vehicle assy without transmission or engine' : VehicleAssembly;\t\t\t\t\t\n\t\t\t\t\tin item transmission : Transmission {\n\t\t\t\t\t\t/* Note: A part can be treated as an item. */\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tout item 'vehicle assy without engine' : VehicleAssembly = 'vehicle assy without transmission or engine' {\t\t\t\t\t\t\n\t\t\t\t\t\tpart transmission : Transmission = 'assemble transmission into vehicle'.transmission {\n\t\t\t\t\t\t\t/* Note: An item can become a part of something else. */\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tflow 'assemble transmission into vehicle'.'vehicle assy without engine' \n\t\t\t\t    to 'assemble engine into vehicle'.'vehicle assy without engine';\n\t\t\t\t\n\t\t\t\taction 'assemble engine into vehicle' {\n\t\t\t\t\tin item 'vehicle assy without engine' : VehicleAssembly {\n\t\t\t\t\t\tpart transmission : Transmission;\n\t\t\t\t\t}\n\t\t\t\t\tin item engine : Engine;\n\t\t\t\t\t\n\t\t\t\t\tout item assembledVehicle : AssembledVehicle = 'vehicle assy without engine' {\n\t\t\t\t\t\tpart engine : Engine = 'assemble engine into vehicle'.engine;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbind 'assemble vehicle'.'assemble engine into vehicle'.assembledVehicle = vehicle;\n\t\t\t\n\t\t\tpart vehicle : Vehicle {\n\t\t\t\t/*\n\t\t\t\t * Note: An in item one context can become a part in an other.\n\t\t\t\t */\n\t\t\t\n\t\t\t\tpart transmission: Transmission;\n\t\t\t\tpart engine: Engine;\n\t\t\t\t\n\t\t\t\tperform action providePower;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
    },
    {
      "name": "4a-Functional Allocation",
      "text": "该系统需求描述了车辆系统中动力提供行为的功能分配及其相关部件的端口和子行为。以`vehicle1_c1_functional_allocation`为基础，将提供动力（provide power）行为分配到各个车辆部件中。首先，定义了燃料指令端口（fuelCmdPort）用于接收燃料命令输入，并分配“提供动力”行为到车辆系统，赋予`fuelCmdPort`作为`fuelCmd`的输入。接下来，将“提供动力”行为的子步骤逐步分配至车辆系统的各子部件中：在引擎（engine）部分，通过分配`generate torque`子行为接收燃料命令并输出扭矩（engineTorque）至驱动力端口（drivePwrPort）；在变速器（transmission）部分，`amplify torque`子行为将引擎扭矩输入至离合端口（clutchPort），并放大后通过轴端口（shaftPort_a）输出变速器扭矩（transmissionTorque）；在驱动轴（driveshaft）部分，`transfer torque`子行为将传输扭矩通过轴端口（shaftPort_b）输入并输出为驱动轴扭矩（driveshaftTorque）至另一端口（shaftPort_c）。最后，在后轴组件（rearAxleAssembly）部分，`distribute torque`子行为将驱动轴扭矩输入至轴端口（shaftPort_d），并将其分配至后轴的左右半轴，通过半轴端口（axleToWheelPort）分别输出至两个车轮的扭矩（wheelTorque）。整个需求描述了车辆各个部件在动力传输过程中的角色及其端口分配，通过功能分配确保各部件有序地完成从燃料输入到动力输出的全过程。",
      "label": "package '4a-Functional Allocation' {\n\tprivate import '2a-Parts Interconnection'::*;\n\tprivate import '3a-Function-based Behavior-1'::*;\n\tprivate import '3a-Function-based Behavior-1'::'provide power'::*;\n\t\t\n\tpart vehicle1_c1_functional_allocation :> vehicle1_c1 {\n\t\t// Note: The definitions of the port types in '2a-Parts Interconnection' do not include \n\t\t// flow properties.\n\t\tport :>> fuelCmdPort {\n\t\t\tin fuelCmd: FuelCmd;\n\t\t}\n\n\t\tperform 'provide power' {\n\t\tdoc\n\t\t/*\n\t\t * This allocates the action '3a-Function-based Behavior-1'::'provide power' as an enacted \n\t\t * performance of 'vehicle_c1_functional_allocation'.\n\t\t */\n\t\t\n\t\t\t// This assigns the fuelCmdPort to provide the input to 'provide power'.\n\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t}\n\t\t\n\t\t//*\n\t\t// The above is semantically equivalent to:\n\t\t\n\t\tref action 'provide power' (in fuelCmd = fuelCmdPort::fuelCmd) \n\t\t   :> '3a-Function-based Behavior'::'provide power', performedActions;\t\t\n\t\t\t\n\t\t// For a composite enacted performance within the vehicle, replace the above with:\n\t\t\n\t\taction 'provide power' (in fuelCmd = fuelCmdPort::fuelCmd) \n\t\t   :> '3a-Function-based Behavior'::'provide power';\n\t\t*/\n\t\t\n\t\tpart :>> engine {\n\t\t\tport :>> fuelCmdPort {\n\t\t\t\tin fuelCmd: FuelCmd;\n\t\t\t}\n\t\t\t\n\t\t\tperform 'provide power'.'generate torque' {\n\t\t\t\t/*\n\t\t\t\t *  This allocates one of the sub-steps of 'provide power' to a sub-part of vehicle_c1. \n\t\t\t\t */\n\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t\tout engineTorque = drivePwrPort.engineTorque;\n\t\t\t}\n\t\t\t\n\t\t\tport :>> drivePwrPort {\n\t\t\t\tout engineTorque: Torque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart :>> transmission {\n\t\t\tport :>> clutchPort {\n\t\t\t\tin attribute engineTorque: Torque;\n\t\t\t}\n\t\t\t\n\t\t\tperform 'provide power'.'amplify torque' {\n\t\t\t\tin engineTorque = clutchPort.engineTorque; \n\t\t\t\tout transmissionTorque = shaftPort_a.transmissionTorque;\n\t\t\t}\n\n\t\t\tport :>> shaftPort_a {\n\t\t\t\tout transmissionTorque: Torque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart :>> driveshaft {\n\t\t\tport :>> shaftPort_b {\n\t\t\t\tin transmissionTorque: Torque;\n\t\t\t}\n\n\t\t\tperform 'provide power'.'transfer torque' {\n\t\t\t\tin transmissionTorque = shaftPort_b.transmissionTorque; \n\t\t\t\tout driveshaftTorque = shaftPort_c.driveshaftTorque;\n\t\t\t}\n\n\t\t\tport :>> shaftPort_c {\n\t\t\t\tout driveshaftTorque: Torque;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tpart :>> rearAxleAssembly {\n\t\t\tport :>> shaftPort_d {\n\t\t\t\tin driveshaftTorque: Torque;\n\t\t\t}\n\t\t\t\t\n\t\t\tperform 'provide power'.'distribute torque' {\n\t\t\t\tin driveshaftTorque = shaftPort_d.driveshaftTorque; \n\t\t\t\tout wheelTorque1 = rearAxle.leftHalfAxle.axleToWheelPort.wheelTorque; \n\t\t\t\tout wheelTorque2 = rearAxle.rightHalfAxle.axleToWheelPort.wheelTorque;\n\t\t\t}\n\t\t\t\n\t\t\tpart :>> rearAxle {\n\t\t\t\tpart :>> leftHalfAxle {\n\t\t\t\t\tport :>> axleToWheelPort {\n\t\t\t\t\t\tout wheelTorque: Torque;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpart :>> rightHalfAxle {\n\t\t\t\t\tport :>> axleToWheelPort {\n\t\t\t\t\t\tout wheelTorque: Torque;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "name": "5-State-based Behavior-1",
      "text": "该系统需求描述了一个具有状态行为的车辆系统，包含车辆状态和控制器状态。车辆`VehicleA`执行“提供动力”（provide power）动作，同时展示了“车辆状态”（vehicle states），包括“操作状态”（operational states）和“健康状态”（health states），并与控制器状态（controller states）并行工作。在“操作状态”中，车辆初始处于关闭状态（off），当收到车辆启动信号（Vehicle Start Signal）且刹车踏板处于按下状态时，车辆进入启动状态（starting），并向控制器发送启动信号（Start Signal）。随后，车辆在收到车辆开启信号（Vehicle On Signal）后进入开启状态（on），在此状态下执行自检（perform self test），并持续提供动力（provide power）；离开该状态时执行停车制动（apply parking brake）。车辆在收到车辆关闭信号（Vehicle Off Signal）后返回关闭状态。在“健康状态”中，车辆从初始状态进入正常状态（normal），当达到维护时间时进入维护状态（maintenance），并在接收到返回正常信号（Return to Normal）后恢复正常状态；当车辆检测到温度超过阈值时，进入退化状态（degraded），并向控制器发送过热信号（Over Temp），退化状态同样可通过返回正常信号恢复为正常状态。控制器状态并行运行，在接收到启动信号时从关闭状态进入开启状态（on），在收到关闭信号（Off Signal）后返回关闭状态。`vehicle1_c1`作为具体的车辆实例，配有燃料命令端口，定义了刹车踏板状态、维护时间和最高温度等属性，并展示了“车辆状态”作为详细的状态行为。此需求详细描述了车辆和控制器的状态转换条件和响应行为，定义了车辆在不同状态下的操作逻辑。",
      "label": "package '5-State-based Behavior-1' {\n\tprivate import ScalarValues::*;\n\tprivate import ISQ::*;\n\tprivate import '3a-Function-based Behavior-1'::*;\n\t\n\tpackage Definitions {\n\t\tpart def VehicleA {\n\t\t\t/*\n\t\t\t * The following declare that 'VehicleA' performs a\n\t\t\t * 'provide power' action and exhibits some 'vehicle states',\n\t\t\t * without giving details about these behaviors.\n\t\t\t */\n\t\t\tperform action 'provide power': 'Provide Power';\n\t\t\texhibit state 'vehicle states': 'Vehicle States';\n\t\t}\n\t\t\n\t\tpart def VehicleController {\n\t\t\texhibit state 'controller states': 'Controller States';\n\t\t}\n\n\t\t/*\n\t\t * Black box specifications for state definitions may also have\n\t\t * input and output parameters, like activities, though none\n\t\t * are used here.\n\t\t */\n\n\t\tstate def 'Vehicle States';\n\t\tstate def 'Controller States';\t\n\n\t\taction def 'Perform Self Test';\n\t\taction def 'Apply Parking Brake';\n\t\taction def 'Sense Temperature' { out temp: TemperatureValue; }\n\t\t\n\t\tattribute def 'Vehicle Start Signal';\n\t\tattribute def 'Vehicle On Signal';\n\t\tattribute def 'Vehicle Off Signal';\n\t\t\n\t\tattribute def 'Start Signal';\n\t\tattribute def 'Off Signal';\n\t\tattribute def 'Over Temp';\n\t\tattribute def 'Return to Normal';\n\t}\n\t\n\tpackage Usages {\n\t\tprivate import Definitions::*;\n\t\t\n\t\t/*\n\t\t * These actions are used enabled in the state usage \n\t\t * 'vehicle states', in addition to 'provide power'.\n\t\t */\n\t\t \n\t\taction 'perform self test': 'Perform Self Test';\n\t\taction 'apply parking brake': 'Apply Parking Brake';\n\t\taction 'sense temperature': 'Sense Temperature';\n\t\t\n\t\tstate 'vehicle states': 'Vehicle States' parallel {\n\t\t\t/*\n\t\t\t * This is a usage of the state definition 'Vehicle States'.\n\t\t\t * Note that it depends specifically on on the part 'vehicle1_c1'.\n\t\t\t */\n\t\t\n\t\t\tref vehicle : VehicleA;\n\n\t\t\tstate 'operational states' {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * The state definition for this usage is implicit.\n\t\t\t */\n\t\t\t\n\t\t\t\tentry action initial {\n\t\t\t\tdoc\n\t\t\t\t/*\n\t\t\t\t * This empty entry action acts like a start pseudo state.\n\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttransition initial then off;\n\t\t\t    \n\t\t\t\tstate off;\n\t\t\t\t\n\t\t\t\ttransition 'off-starting'\n\t\t\t\t\tfirst off\n\t\t\t\t\taccept 'Vehicle Start Signal' \n\t\t\t\t\tif vehicle1_c1.'brake pedal depressed'\n\t\t\t\t\tdo send 'Start Signal'() to vehicle1_c1.vehicleController\n\t\t\t\t\tthen starting {\n\t\t\t\t\t/*\n\t\t\t\t\t * The transition definition for a transition usage is always implicit.\n\t\t\t\t\t * \"accept\" marks the trigger, \"if\" the guard and \"do\" the effect.\n\t\t\t\t\t * \n\t\t\t\t\t * The notation \"'Start Signal'()\" constructs a specific instance of the\n\t\t\t\t\t * 'Start Signal' attribute def to be sent to the 'vehicleController'. If the\n\t\t\t\t\t * attribute def had properties, their values would be given as arguments\n\t\t\t\t\t * inside the parhentheses.\n\t\t\t\t\t */\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tstate starting;\n\t\t\t\t\n\t\t\t\ttransition 'starting-on'\n\t\t\t\t\tfirst starting\n\t\t\t\t\taccept 'Vehicle On Signal'\n\t\t\t\t\tthen on;\n\t\t\t\t\n\t\t\t\tstate on {\n\t\t\t\t\t/*\n\t\t\t\t\t * A state may have a \"entry\" action that is performed on entry into\n\t\t\t\t\t * the state, a \"do\" action that is performed while in the state\n\t\t\t\t\t * and an \"exit\" action that is performed on exit from the state.\n\t\t\t\t\t */\n\t\t\t\t\n\t\t\t\t\tentry 'perform self test';\n\t\t\t\t\tdo 'provide power';\n\t\t\t\t\texit 'apply parking brake';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttransition 'on-off'\n\t\t\t\t\tfirst on\n\t\t\t\t\taccept 'Vehicle Off Signal'\n\t\t\t\t\tthen off;\n\t\t\t}\n\t\t\t\n\t\t\tstate 'health states' {\n\t\t\t\t/*\n\t\t\t\t * 'health states' is concurrent with 'operational states', because the\n\t\t\t\t * containing state usage is \"parallel\".\n\t\t\t\t */\n\t\t\t\n\t\t\t\tentry action initial;\n\t\t\t\tdo 'sense temperature' { out temp; \n\t\t\t\t\t/*\n\t\t\t\t\t * State-behavior actions may have input and output parameters.\n\t\t\t\t\t */\n\t\t\t\t }\n\t\t\t\t\n\t\t\t\ttransition initial then normal;\n\t\t\t\t\n\t\t\t\tstate normal;\n\t\t\t\t\n\t\t\t\ttransition 'normal-maintenance'\n\t\t\t\t\tfirst normal\n\t\t\t\t\taccept at vehicle1_c1.maintenanceTime\n\t\t\t\t\tthen maintenance;\n\t\t\t\t\n\t\t\t\ttransition 'normal-degraded'\n\t\t\t\t\tfirst normal\n\t\t\t\t\taccept when 'sense temperature'.temp > vehicle1_c1.Tmax\n\t\t\t\t\tdo send 'Over Temp'() to vehicle1_c1.vehicleController \n\t\t\t\t\tthen degraded;\n\t\t\t\t\n\t\t\t\tstate maintenance;\n\t\t\t\t\n\t\t\t\ttransition 'maintenance-normal'\n\t\t\t\t\tfirst maintenance\n\t\t\t\t\taccept 'Return to Normal'\n\t\t\t\t\tthen normal;\n\t\t\t\t\n\t\t\t\tstate degraded;\n\t\t\t\t\n\t\t\t\ttransition 'degraded-normal'\n\t\t\t\t\tfirst degraded\n\t\t\t\t\taccept 'Return to Normal'\n\t\t\t\t\tthen normal;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstate 'controller states': 'Controller States' parallel {\n\t\t\tstate 'operational controller states' {\n\t\t\t\tentry action initial; \n\t\t\t\t\n\t\t\t\ttransition initial then off;\n\t\t\t\t\n\t\t\t\tstate off;\n\t\t\t\t\n\t\t\t\ttransition 'off-on'\n\t\t\t\t\tfirst off\n\t\t\t\t\taccept 'Start Signal'\n\t\t\t\t\tthen on;\n\t\t\t\t\n\t\t\t\tstate on;\n\t\t\t\t\n\t\t\t\ttransition 'on-off'\n\t\t\t\t\tfirst on\n\t\t\t\t\taccept 'Off Signal'\n\t\t\t\t\tthen off;\n\t\t\t}\n\t\t}\t\t\n\n\t\tpart vehicle1_c1: VehicleA {\n\t\t\tport fuelCmdPort {\n\t\t\t\tin fuelCmd: FuelCmd;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t * These attribute properties are used in the specification for\n\t\t\t * 'vehicle states'.\n\t\t\t */\n\t\t\tattribute 'brake pedal depressed': Boolean;\t\t\n\t\t\tattribute maintenanceTime: Time::DateTime;\n\t\t\tattribute Tmax: TemperatureValue;\n\t\t\t\n\t\t\tperform 'provide power' :>> VehicleA::'provide power' {\n\t\t\t\t/*\n\t\t\t\t * In the context of the 'vehicle1_c1' part, the 'provide power' action\n\t\t\t\t * that is enabled in 'vehicle states' gets its input from the 'fuelCmdPort'.\n\t\t\t\t */\n\t\t\t\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t\t\n\t\t\texhibit 'vehicle states' :>> VehicleA::'vehicle states' {\n\t\t\t\t/*\n\t\t\t\t * This allocates the state usage 'vehicle states' as the detailed\n\t\t\t\t * state-based behavior for 'vehicle1_c1' that fills in the generic\n\t\t\t\t * declaration in 'VehicleA'.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\t\n\t\t\t//*\n\t\t\t// The above is semantically equivalent to:\n\t\t\t\n\t\t\tref state 'vehicle states' :> Usages::'vehicle states', exhibitedStates\n\t\t\t\t:>> VehicleA::'vehicle states';\t\t\n\t\t\t\t\n\t\t\t// For a composite state performance within the vehicle, replace the above with:\n\t\t\t\n\t\t\tstate 'vehicle states' :>> Usages::'vehicle states', VehicleA::'vehicle states';\n\t\t\t*/\n\n\t\t\tpart vehicleController: VehicleController {\n\t\t\t\texhibit 'controller states' :>> VehicleController::'controller states';\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "5-State-based Behavior-1a",
      "text": "该系统需求描述了一个基于状态的车辆系统行为，涉及车辆VehicleA和其控制器VehicleController的状态。车辆VehicleA执行“提供动力”动作，并展示“车辆状态”（vehicle states），包括并行的“操作状态”（operational states）和“健康状态”（health states）。在操作状态中，车辆从关闭状态（off）开始，当接收到车辆启动信号（Vehicle Start Signal）且刹车踏板处于按下状态时，车辆进入启动状态（starting），并向控制器发送启动信号。然后，车辆在接收到车辆开启信号（Vehicle On Signal）后进入开启状态（on），此状态下车辆执行自检（perform self test），持续提供动力，离开该状态时执行停车制动（apply parking brake）。当车辆接收到车辆关闭信号（Vehicle Off Signal）时返回关闭状态。在健康状态中，车辆从初始状态进入正常状态（normal），在维护时间到达时进入维护状态，接收恢复信号（Return to Normal）后返回正常状态；当温度超过最高限值时进入退化状态（degraded），并向控制器发送过热信号（Over Temp），退化状态同样可通过恢复信号返回正常。控制器状态并行运行，初始处于关闭状态（off），在接收到启动信号时进入开启状态，接收关闭信号后返回关闭状态。vehicle1_c1作为车辆实例，配有燃料指令端口（fuelCmdPort），定义了刹车踏板状态、维护时间和最高温度等属性，并展示“车辆状态”作为具体的状态行为。该需求通过状态转换和信号交互机制定义了车辆在不同状态下的操作逻辑，为车辆和控制器提供清晰的状态管理和响应规则。",
      "label": "package '5-State-based Behavior-1a' {\n\tprivate import ScalarValues::*;\n\tprivate import ISQ::*;\n\t\n\tpackage Definitions {\n\t\tpart def VehicleA {\n\t\t\t/*\n\t\t\t * The following declare that 'VehicleA' performs a\n\t\t\t * 'provide power' action and exhibits some 'vehicle states',\n\t\t\t * without giving details about these behaviors.\n\t\t\t */\n\t\t\tperform action 'provide power': 'Provide Power';\n\t\t\texhibit state 'vehicle states': 'Vehicle States';\n\t\t}\n\t\t\n\t\tpart def VehicleController {\n\t\t\texhibit state 'controller states': 'Controller States';\n\t\t}\n\n\t\t/*\n\t\t * Black box specifications for state definitions may also have\n\t\t * input and output parameters, like activities, though none\n\t\t * are used here.\n\t\t */\n\n\t\tstate def 'Vehicle States';\n\t\tstate def 'Controller States';\t\n\n\t\taction def 'Provide Power';\n\t\taction def 'Perform Self Test';\n\t\taction def 'Apply Parking Brake';\n\t\taction def 'Sense Temperature' { out temp: TemperatureValue; }\n\t\t\n\t\tattribute def FuelCmd;\n\t\t\n\t\tattribute def 'Vehicle Start Signal';\n\t\tattribute def 'Vehicle On Signal';\n\t\tattribute def 'Vehicle Off Signal';\n\t\t\n\t\tattribute def 'Start Signal';\n\t\tattribute def 'Off Signal';\n\t\tattribute def 'Over Temp';\n\t\tattribute def 'Return to Normal';\n\t}\n\t\n\tpackage Usages {\n\t\tprivate import Definitions::*;\n\t\t\n\t\t/*\n\t\t * These actions are used enabled in the state usage \n\t\t * 'vehicle states', in addition to 'provide power'.\n\t\t */\n\t\t \n\t\taction 'provide power': 'Provide Power';\n\t\taction 'perform self test': 'Perform Self Test';\n\t\taction 'apply parking brake': 'Apply Parking Brake';\n\t\taction 'sense temperature': 'Sense Temperature';\n\t\t\n\t\tstate 'vehicle states': 'Vehicle States' parallel {\n\t\t\t/*\n\t\t\t * This is a usage of the state definition 'Vehicle States'.\n\t\t\t * Note that it depends specifically on on the part 'vehicle1_c1'.\n\t\t\t */\t\t \n\n\t\t\tstate 'operational states' {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * The state definition for this usage is implicit.\n\t\t\t */\n\t\t\t\n\t\t\t\tentry action initial {\n\t\t\t\tdoc\n\t\t\t\t/*\n\t\t\t\t * This empty entry action acts like a start pseudo state.\n\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttransition initial then off;\n\t\t\t    \n\t\t\t\tstate off;\n\t\t\t\t\n\t\t\t\ttransition 'off-starting'\n\t\t\t\t\tfirst off\n\t\t\t\t\taccept 'Vehicle Start Signal' \n\t\t\t\t\tif vehicle1_c1.'brake pedal depressed'\n\t\t\t\t\tdo send 'Start Signal'() to vehicle1_c1.vehicleController\n\t\t\t\t\tthen starting {\n\t\t\t\t\t/*\n\t\t\t\t\t * The transition definition for a transition usage is always implicit.\n\t\t\t\t\t * \"accept\" marks the trigger, \"if\" the guard and \"do\" the effect.\n\t\t\t\t\t * \n\t\t\t\t\t * The notation \"'Start Signal'()\" constructs a specific instance of the\n\t\t\t\t\t * 'Start Signal' attribute def to be sent to the 'vehicleController'. If the\n\t\t\t\t\t * attribute def had properties, their values would be given as arguments\n\t\t\t\t\t * inside the parhentheses.\n\t\t\t\t\t */\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tstate starting;\n\t\t\t\t\n\t\t\t\ttransition 'starting-on'\n\t\t\t\t\tfirst starting\n\t\t\t\t\taccept 'Vehicle On Signal'\n\t\t\t\t\tthen on;\n\t\t\t\t\n\t\t\t\tstate on {\n\t\t\t\t\t/*\n\t\t\t\t\t * A state may have a \"entry\" action that is performed on entry into\n\t\t\t\t\t * the state, a \"do\" action that is performed while in the state\n\t\t\t\t\t * and an \"exit\" action that is performed on exit from the state.\n\t\t\t\t\t */\n\t\t\t\t\n\t\t\t\t\tentry 'perform self test';\n\t\t\t\t\tdo 'provide power';\n\t\t\t\t\texit 'apply parking brake';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttransition 'on-off'\n\t\t\t\t\tfirst on\n\t\t\t\t\taccept 'Vehicle Off Signal'\n\t\t\t\t\tthen off;\n\t\t\t}\n\t\t\t\n\t\t\tstate 'health states' {\n\t\t\t\t/*\n\t\t\t\t * 'health states' is concurrent with 'operational states', because the\n\t\t\t\t * containing state usage is \"parallel\".\n\t\t\t\t */\n\t\t\t\n\t\t\t\tentry action initial;\n\t\t\t\tdo 'sense temperature' { out temp; \n\t\t\t\t\t/*\n\t\t\t\t\t * State-behavior actions may have input and output parameters.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttransition initial then normal;\n\t\t\t\t\n\t\t\t\tstate normal;\n\t\t\t\t\n\t\t\t\ttransition 'normal-maintenance'\n\t\t\t\t\tfirst normal\n\t\t\t\t\taccept at vehicle1_c1.maintenanceTime\n\t\t\t\t\tthen maintenance;\n\t\t\t\t\n\t\t\t\ttransition 'normal-degraded'\n\t\t\t\t\tfirst normal\n\t\t\t\t\taccept when 'sense temperature'.temp > vehicle1_c1.Tmax\n\t\t\t\t\tdo send 'Over Temp'() to vehicle1_c1.vehicleController \n\t\t\t\t\tthen degraded;\n\t\t\t\t\n\t\t\t\tstate maintenance;\n\t\t\t\t\n\t\t\t\ttransition 'maintenance-normal'\n\t\t\t\t\tfirst maintenance\n\t\t\t\t\taccept 'Return to Normal'\n\t\t\t\t\tthen normal;\n\t\t\t\t\n\t\t\t\tstate degraded;\n\t\t\t\t\n\t\t\t\ttransition 'degraded-normal'\n\t\t\t\t\tfirst degraded\n\t\t\t\t\taccept 'Return to Normal'\n\t\t\t\t\tthen normal;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstate 'controller states': 'Controller States' parallel {\n\t\t\tstate 'operational controller states' {\n\t\t\t\tentry action initial; \n\t\t\t\t\n\t\t\t\ttransition initial then off;\n\t\t\t\t\n\t\t\t\tstate off;\n\t\t\t\t\n\t\t\t\ttransition 'off-on'\n\t\t\t\t\tfirst off\n\t\t\t\t\taccept 'Start Signal'\n\t\t\t\t\tthen on;\n\t\t\t\t\n\t\t\t\tstate on;\n\t\t\t\t\n\t\t\t\ttransition 'on-off'\n\t\t\t\t\tfirst on\n\t\t\t\t\taccept 'Off Signal'\n\t\t\t\t\tthen off;\n\t\t\t}\n\t\t}\t\t\n\n\t\tpart vehicle1_c1: VehicleA {\n\t\t\tport fuelCmdPort {\n\t\t\t\tin fuelCmd: FuelCmd;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t * These attribute properties are used in the specification for\n\t\t\t * 'vehicle states'.\n\t\t\t */\n\t\t\tattribute 'brake pedal depressed': Boolean;\t\t\n\t\t\tattribute maintenanceTime: Time::DateTime;\n\t\t\tattribute Tmax: TemperatureValue;\n\t\t\t\n\t\t\tperform 'provide power' :>> VehicleA::'provide power' {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * In the context of the 'vehicle1_c1' part, the 'provide power' action\n\t\t\t * that is enabled in 'vehicle states' gets its input from the 'fuelCmdPort'.\n\t\t\t */\n\t\t\t\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t\t\n\t\t\texhibit 'vehicle states' :>> VehicleA::'vehicle states' {\n\t\t\t\t/*\n\t\t\t\t * This allocates the state usage 'vehicle states' as the detailed\n\t\t\t\t * state-based behavior for 'vehicle1_c1' that fills in the generic\n\t\t\t\t * declaration in 'VehicleA'.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\t\n\t\t\t//*\n\t\t\t// The above is semantically equivalent to:\n\t\t\t\n\t\t\tref state 'vehicle states' :> Usages::'vehicle states', exhibitedStates\n\t\t\t\t:>> VehicleA::'vehicle states';\t\t\n\t\t\t\t\n\t\t\t// For a composite state performance within the vehicle, replace the above with:\n\t\t\t\n\t\t\tstate 'vehicle states' :>> Usages::'vehicle states', VehicleA::'vehicle states';\n\t\t\t*/\n\n\t\t\tpart vehicleController: VehicleController {\n\t\t\t\texhibit 'controller states' :>> VehicleController::'controller states';\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "5-State-based Behavior-2",
      "text": "该系统需求描述了一个基于状态的车辆和控制器的行为模型，包含车辆VehicleA的“车辆状态”（vehicle states）和控制器VehicleController的“控制器状态”（controller states）。在“车辆状态”中，车辆具有“操作状态”（operational states）和“健康状态”（health states），这两种状态并行运行。在操作状态中，车辆初始处于关闭状态（off），当接收到车辆启动信号（Vehicle Start Signal）且刹车踏板处于按下状态时，进入启动状态（starting）并向控制器发送启动信号（Start Signal）。随后，车辆在接收到车辆开启信号（Vehicle On Signal）后进入开启状态（on），该状态下车辆执行自检（perform self test）并持续提供动力（provide power）；离开此状态时，车辆执行停车制动（apply parking brake）。当车辆接收到车辆关闭信号（Vehicle Off Signal）时，返回关闭状态。在健康状态中，车辆从初始状态进入正常状态（normal），当到达维护时间时进入维护状态（maintenance），并在接收到恢复信号（Return to Normal）后返回正常状态；当温度超过最高阈值时，车辆进入退化状态（degraded），并向控制器发送过热信号（Over Temp），退化状态同样可通过恢复信号返回正常状态。控制器状态在并行状态下运行，从关闭状态开始，在接收到启动信号时进入开启状态，并在接收到关闭信号（Off Signal）时返回关闭状态。车辆实例vehicle1_c1配有燃料指令端口，并定义了刹车踏板状态、维护时间和最高温度属性。整个需求明确了车辆和控制器在不同状态间的切换条件及其相应的行为，构建了清晰的状态管理逻辑。",
      "label": "package '5-State-based Behavior-2' {\n\tprivate import ScalarValues::*;\n\tprivate import ISQ::*;\n\tprivate import '3a-Function-based Behavior-1'::*;\n\t\n\tpackage Definitions {\n\t\tpart def VehicleA {\n\t\t\tperform action 'provide power': 'Provide Power';\n\t\t\texhibit state 'vehicle states': 'Vehicle States';\n\t\t}\n\t\t\n\t\tpart def VehicleController {\n\t\t\texhibit state 'controller states': 'Controller States';\n\t\t}\n\n\t\tstate def 'Vehicle States';\n\t\tstate def 'Controller States';\t\n\n\t\taction def 'Perform Self Test';\n\t\taction def 'Apply Parking Brake';\n\t\taction def 'Sense Temperature' { out temp: TemperatureValue; }\n\t\t\n\t\tattribute def 'Vehicle Start Signal';\n\t\tattribute def 'Vehicle On Signal';\n\t\tattribute def 'Vehicle Off Signal';\n\t\t\n\t\tattribute def 'Start Signal';\n\t\tattribute def 'Off Signal';\n\t\tattribute def 'Over Temp';\n\t\tattribute def 'Return to Normal';\n\t}\n\t\n\tpackage Usages {\n\t\tprivate import Definitions::*;\n\t\t \n\t\taction 'perform self test': 'Perform Self Test';\n\t\taction 'apply parking brake': 'Apply Parking Brake';\n\t\taction 'sense temperature': 'Sense Temperature';\n\t\t\n\t\tstate 'vehicle states': 'Vehicle States' parallel {\n\n\t\t\tstate 'operational states' {\n\t\t\t\tentry; then off;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * The following uses a shorthand for a transition whose source \n\t\t\t\t * is the immediately preceding state.\n\t\t\t\t */\n\t\t\t\tstate off;\n\t\t\t\taccept 'Vehicle Start Signal' \n\t\t\t\t\tif vehicle1_c1.'brake pedal depressed'\n\t\t\t\t\tdo send 'Start Signal'() to vehicle1_c1.vehicleController\n\t\t\t\t\tthen starting;\n\t\t\t\t\t\n\t\t\t\tstate starting;\n\t\t\t\taccept 'Vehicle On Signal'\n\t\t\t\t\tthen on;\n\t\t\t\t\t\n\t\t\t\tstate on {\n\t\t\t\t\tentry 'perform self test';\n\t\t\t\t\tdo 'provide power';\n\t\t\t\t\texit 'apply parking brake';\n\t\t\t\t}\n\t\t\t\taccept 'Vehicle Off Signal'\n\t\t\t\t\tthen off;\n\t\t\t}\n\t\t\t\n\t\t\tstate 'health states' {\n\t\t\t\tentry; then normal;\n\t\t\t\tdo 'sense temperature' { out temp; }\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * The shorthand can be used for multiple transitions after\n\t\t\t\t * a single state.\n\t\t\t\t */\n\t\t\t\tstate normal;\n\t\t\t\taccept at vehicle1_c1.maintenanceTime\n\t\t\t\t\tthen maintenance;\n\t\t\t\taccept when 'sense temperature'.temp > vehicle1_c1.Tmax\n\t\t\t\t\tdo send 'Over Temp'() to vehicle1_c1.vehicleController \n\t\t\t\t\tthen degraded;\n\t\t\t\t\n\t\t\t\tstate maintenance;\n\t\t\t\taccept 'Return to Normal'\n\t\t\t\t\tthen normal;\n\t\t\t\t\n\t\t\t\tstate degraded;\n\t\t\t\taccept 'Return to Normal'\n\t\t\t\t\tthen normal;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstate 'controller states': 'Controller States' parallel {\n\t\t\tstate 'operational controller states' {\n\t\t\t\tentry; then off;\n\t\t\t\t\n\t\t\t\tstate off;\n\t\t\t\taccept 'Start Signal'\n\t\t\t\t\tthen on;\n\t\t\t\t\n\t\t\t\tstate on;\n\t\t\t\taccept 'Off Signal'\n\t\t\t\t\tthen off;\n\t\t\t}\n\t\t}\t\t\n\n\t\tpart vehicle1_c1: VehicleA {\n\t\t\tport fuelCmdPort {\n\t\t\t\tin fuelCmd: FuelCmd;\n\t\t\t}\n\t\t\t\n\t\t\tattribute 'brake pedal depressed': Boolean;\t\t\n\t\t\tattribute maintenanceTime: Time::DateTime;\n\t\t\tattribute Tmax: TemperatureValue;\n\t\t\t\n\t\t\tperform 'provide power' :>> VehicleA::'provide power' {\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t\t\t\n\t\t\texhibit 'vehicle states' :>> VehicleA::'vehicle states';\n\t\t\t\t\n\t\t\tpart vehicleController: VehicleController {\n\t\t\t\texhibit 'controller states' :>> VehicleController::'controller states';\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "6-Individual and Snapshots",
      "text": "该系统需求描述了车辆系统的时间-空间参考和快照机制，追踪不同时间点上车辆和道路的状态。系统首先定义了“车辆道路环境”（VehicleRoadContext）和“车辆A”（VehicleA）的相关属性，车辆A具有质量、位置、速度和加速度等属性，并展示车辆的状态行为，包括“开启”和“关闭”状态。系统通过个体定义（Individual Definitions）将这些部件关联到特定的个体，如VehicleA_ID1和Road_ID1，以确保这些部件实例化时保持相同的标识。在快照包中，系统创建了多个时刻的环境快照，以表示在各个时间点（例如t0、t1、tn）的车辆和道路状态。在t0时刻，车辆的质量为m、位置为p0、速度为v0、加速度为a0，同时车辆处于“开启”状态；道路的角度和表面摩擦力分别为theta0和sf0。在t1时刻，车辆的属性更新为位置p1、速度v1、加速度a1，道路状态则为theta1和sf1。在终点时刻tn，车辆位置更新至pn，速度和加速度变为vn和an，同时车辆处于“关闭”状态，道路摩擦力更新至sfn。此描述详细呈现了车辆和道路在不同时间点的状态变化，支持对系统在各个时刻的精确分析和记录。",
      "label": "package '6-Individual and Snapshots' {\n\tprivate import ScalarValues::Real;\n\tprivate import Time::DateTime;\n\tprivate import ISQ::*;\n\t\n\tpackage 'Part Definitions' {\t\n\t\tpart def 'Temporal-Spatial Reference' {\n\t\t\tattribute referenceTime : DateTime;\n\t\t\tattribute referenceCoordinateSystem;\n\t\t}\n\t\t\n\t\t/*\n\t\t * Note that space and time coordinatization have not\n\t\t * been fully specified yet.\n\t\t */\n\t\t\n\t\tpart def VehicleRoadContext {\n\t\t\tattribute t : TimeValue;\n\t\t}\n\t\t\n\t\tpart def VehicleA {\n\t\t\tattribute mass : MassValue;\n\t\t\tattribute position : Real;\n\t\t\tattribute velocity : Real;\n\t\t\tattribute acceleration : Real;\n\t\t\texhibit state vehicleStates {\n\t\t\t\tentry; then on;\n\t\t\t\tstate on;\n\t\t\t\tthen off;\n\t\t\t\tstate off;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart def Road {\n\t\t\tattribute angle : Real;\n\t\t\tattribute surfaceFriction : Real;\n\t\t}\n\t}\n\t\n\tpackage 'Individual Definitions' {\n\t\tprivate import 'Part Definitions'::*;\n\t\t\n\t\t/*\n\t\t * An individual definition restricts the instances of a part def to\n\t\t * those that are portions of the same life (\"identity\").\n\t\t */\n\t\t \n\t\tindividual def 'Temporal-Spatial Reference_ID1' :> 'Temporal-Spatial Reference';\n\t\tindividual def VehicleRoadContext_ID1 :> VehicleRoadContext;\n\t\tindividual def VehicleA_ID1 :> VehicleA;\n\t\tindividual def Road_ID1 :> Road;\n\t\n\t}\n\t\n\tpackage Values {\t\n\t\tattribute t0 : TimeValue;\n\t\tattribute t1 : TimeValue;\n\t\tattribute tn : TimeValue;\n\t\t\n\t\tattribute m : MassValue;\n\t\t\n\t\tattribute p0 : Real;\n\t\tattribute p1 : Real;\n\t\tattribute pn : Real;\n\t\t\n\t\tattribute v0 : Real;\n\t\tattribute v1 : Real;\n\t\tattribute vn : Real;\n\t\t\n\t\tattribute a0 : Real;\n\t\tattribute a1 : Real;\n\t\tattribute an : Real;\n\t\t\n\t\tattribute theta0 : Real;\n\t\tattribute theta1 : Real;\n\t\tattribute thetan : Real;\n\t\t\n\t\tattribute sf0 : Real;\n\t\tattribute sf1 : Real;\n\t\tattribute sfn : Real;\n\t}\n\t\n\tpackage 'Individuals and Snapshots' {\n\t\tprivate import 'Individual Definitions'::*;\n\t\tprivate import Values::*;\n\t\t\n\t\tindividual reference : 'Temporal-Spatial Reference_ID1' {\n\t\t\t/*\n\t\t\t * An individual usage must be typed by an individual definition,\n\t\t\t * representing the condition of that individual during some or all\n\t\t\t * of its life.\n\t\t\t */\n\t\t\n\t\t\tsnapshot context_t0 : VehicleRoadContext_ID1 {\n\t\t\t\t:>> t = t0 {\n\t\t\t\t\t/*\n\t\t\t\t\t * This is a concise notation for showing the redefinition\n\t\t\t\t\t * of a attribute property.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsnapshot vehicle_ID1_t0 : VehicleA_ID1 {\n\t\t\t\t\t/*\n\t\t\t\t\t * A snapshot is a kind of individual usage restricted to\n\t\t\t\t\t * a single instant of time.\n\t\t\t\t\t */\n\t\t\t\t\n\t\t\t\t\t:>> mass = m;\n\t\t\t\t\t:>> position = p0;\n\t\t\t\t\t:>> velocity = v0;\n\t\t\t\t\t:>> acceleration = a0;\n\t\t\t\t\t\n\t\t\t\t\texhibit vehicleStates.on {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This asserts that the snapshot exhibits the referenced \n\t\t\t\t\t\t * state, which means that the vehicle must me in the state \n\t\t\t\t\t\t * at the time of the snapshot.\n\t\t\t\t\t\t */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsnapshot road_ID1_t0 : Road_ID1 {\n\t\t\t\t\t:>> angle = theta0;\n\t\t\t\t\t:>> surfaceFriction = sf0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsnapshot context_t1 : VehicleRoadContext_ID1 {\n\t\t\t\t:>> t = t1;\n\t\t\t\t\n\t\t\t\tsnapshot vehicle_ID1_t1 : VehicleA_ID1 {\n\t\t\t\t\t:>> mass = m;\n\t\t\t\t\t:>> position = p1;\n\t\t\t\t\t:>> velocity = v1;\n\t\t\t\t\t:>> acceleration = a1;\n\t\t\t\t\t\n\t\t\t\t\texhibit vehicleStates.on;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsnapshot road_ID1_t1 : Road_ID1 {\n\t\t\t\t\t:>> angle = theta1;\n\t\t\t\t\t:>> surfaceFriction = sf1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// ...\n\t\t\t\n\t\t\tsnapshot context_tn : VehicleRoadContext_ID1 {\n\t\t\t\t:>> t = tn;\n\t\t\t\t\n\t\t\t\tsnapshot vehicle_ID1_tn : VehicleA_ID1 {\n\t\t\t\t\t:>> mass = m;\n\t\t\t\t\t:>> position = pn;\n\t\t\t\t\t:>> velocity = vn;\n\t\t\t\t\t:>> acceleration = an;\n\t\t\t\t\t\n\t\t\t\t\texhibit vehicleStates.off;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsnapshot road_ID1_tn : Road_ID1 {\n\t\t\t\t\t:>> angle = theta1;\n\t\t\t\t\t:>> surfaceFriction = sfn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "name": "7a-Variant Configuration - General Concept",
      "text": "该系统需求描述了一个车辆系统的变体配置模型，通过定义不同的子系统组合来支持多种配置。在模型中，anyVehicleConfig是一个抽象的车辆配置（Vehicle），包含了两个可变子系统subsystemA和subsystemB。在subsystemA中，可以选择subsystem1或subsystem2作为变体，其中subsystem1包含part1和part2，而subsystem2包含part2和part3。同样，subsystemB包含两个变体配置subsystem3和subsystem4，其中subsystem3包含part4和part5，而subsystem4包含part5和part6。配置中还包含一个约束条件，要求在subsystemA不等于subsystem2时，subsystemB必须等于subsystem3。在具体实例中，vehicleConfigA配置了subsystemA为subsystem1，subsystemB为subsystem3；而VehicleConfigB将subsystemA配置为subsystem2，subsystemB配置为subsystem3。这种配置模型允许灵活地定义不同车辆配置，满足不同功能和组件组合的需求。",
      "label": "package '7a-Variant Configuration - General Concept' {\n\t\n\tpart def Vehicle;\n\t\n\tpart part1;\n\tpart part2;\n\tpart part3;\n\tpart part4;\n\tpart part5;\n\tpart part6;\n\t\n\tabstract part anyVehicleConfig : Vehicle {\n\t\t\n\t\tvariation part subsystemA {\n\t\t\tvariant part subsystem1 {\n\t\t\t\tpart :>> part1;\n\t\t\t\tpart :>> part2;\n\t\t\t}\n\t\t\tvariant part subsystem2 {\n\t\t\t\tpart :>> part2;\n\t\t\t\tpart :>> part3;\n\t\t\t}\n\t\t}\n\n\t\tvariation part subsystemB {\n\t\t\tvariant part subsystem3 {\n\t\t\t\tpart :>> part4;\n\t\t\t\tpart :>> part5;\n\t\t\t}\n\t\t\tvariant part subsystem4 {\n\t\t\t\tpart :>> part5;\n\t\t\t\tpart :>> part6;\n\t\t\t}\n\t\t}\n\t\t\n\t\tassert constraint {\n\t\t\tsubsystemA != subsystemA.subsystem2 | \n\t\t\tsubsystemB == subsystemB::subsystem3\n\t\t}\n\t\t\n\t}\n\t\n\tpart vehicleConfigA :> anyVehicleConfig {\t\t\n\t\tpart :>> subsystemA = subsystemA.subsystem1;\n\t\tpart :>> subsystemB = subsystemB::subsystem3;\n\t}\n\t\n\tpart VehicleConfigB :> anyVehicleConfig {\n\t\tpart :>> subsystemA = subsystemA.subsystem2;\n\t\tpart :>> subsystemB = subsystemB.subsystem3;\n\t}\n\t\n}"
    },
    {
      "name": "7a1-Variant Configuration - General Concept-a",
      "text": "该系统需求描述了一个具有可变配置的车辆系统模型，通过不同子系统和动作的选择支持多种配置。系统中定义了几个关键部件，包括part1、part2、part3（带有端口p1）、part4、part5（带有端口p2和可变动作doXorY，其中包含doX和doY两个变体）、以及part6。定义了抽象子系统SubsystemA和SubsystemB，其中SubsystemA包含一个可选的part3，SubsystemB则必须包含一个part5。在anyVehicleConfig的变体配置中，subsystemA可以选择变体subsystem1（包含part1和part2）或subsystem2（包含part2和part3）；subsystemB则可以选择变体subsystem3（包含part4和part5）或subsystem4（包含part5和part6）。该系统中还定义了一个连接，将subsystemA中的part3.p1端口连接至subsystemB中的part5.p2端口，并设定了一个约束条件，即当subsystemA不等于subsystem2时，subsystemB必须等于subsystem3。在具体实例vehicleConfigA中，subsystemA配置为subsystem1，subsystemB配置为subsystem3，并选择part5执行doX动作；而在VehicleConfigB中，subsystemA配置为subsystem2，subsystemB配置为subsystem4，并选择part5执行doY动作。这种配置模型为系统提供了灵活的配置选择，使其能够适应不同的功能需求。",
      "label": "package '7a1-Variant Configuration - General Concept-a' {\n\t\n\taction doX;\n\taction doY;\n\t\n\tpart part1;\n\tpart part2;\n\tpart part3 {\n\t\tport p1;\n\t}\n\tpart part4;\n\tpart part5 {\n\t\tport p2;\n\t\tvariation perform action doXorY {\n\t\t\tvariant perform doX;\n\t\t\tvariant perform doY;\n\t\t}\n\t}\n\tpart part6;\n\t\n\tabstract part def SubsystemA {\n\t\tabstract part :>> part3[0..1];\n\t}\n\t\n\tabstract part def SubsystemB {\n\t\tabstract part :>> part5[1];\t\t\n\t}\n\t\n\tpart anyVehicleConfig {\n\t\t\n\t\tvariation part subsystemA : SubsystemA {\n\t\t\tvariant part subsystem1 : SubsystemA {\n\t\t\t\tpart :>> part1[1];\n\t\t\t\tpart :>> part2[1];\n\t\t\t}\n\t\t\tvariant part subsystem2 : SubsystemA {\n\t\t\t\tpart :>> part2[1];\n\t\t\t\tpart :>> part3[1];\n\t\t\t}\n\t\t}\n\n\t\tvariation part subsystemB : SubsystemB {\n\t\t\tvariant part subsystem3 : SubsystemB {\n\t\t\t\tpart :>> part4[1];\n\t\t\t\tpart :>> part5[1];\n\t\t\t}\n\t\t\tvariant part subsystem4 : SubsystemB {\n\t\t\t\tpart :>> part5[1];\n\t\t\t\tpart :>> part6[1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tconnect subsystemA.part3.p1[0..1] to subsystemB.part5.p2[1];\n\t\t\n\t\tassert constraint {\n\t\t\tsubsystemA != subsystemA.subsystem2 | \n\t\t\tsubsystemB == subsystemB.subsystem3\n\t\t}\n\t\t\n\t}\n\t\n\tpart vehicleConfigA :> anyVehicleConfig {\t\t\n\t\tpart :>> subsystemA = subsystemA.subsystem1;\n\t\tpart :>> subsystemB = subsystemB.subsystem3 {\n\t\t\tpart :>> part5 {\n\t\t\t\tperform action :>> doXorY = doX;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpart VehicleConfigB :> anyVehicleConfig {\n\t\tpart :>> subsystemA = subsystemA.subsystem2;\n\t\tpart :>> subsystemB = subsystemB.subsystem4 {\n\t\t\tpart :>> part5 {\n\t\t\t\tperform action :>> doXorY = doY;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "name": "7b-Variant Configurations",
      "text": "该系统需求描述了一个车辆的变体配置模型，定义了不同的组件和性能需求之间的选择和约束。系统首先在RequirementsModel中定义了发动机性能需求，包括高性能需求（highPerformanceRequirement）和正常性能需求（normalPerformanceRequirement）。在DesignModel中定义了车辆结构，包括引擎、变速器、离合器、驱动轴、后轴组件和轮胎等部件，以及用于连接各部件的端口。VariantDefinitions部分提供了变体部件的具体定义，如4缸和6缸发动机、手动和自动变速器、手动和自动离合器、窄边和宽边轮胎等。在VariabilityModel中，系统定义了一个anyVehicleConfig变体配置，其中包含了对发动机、变速器和后轮的选择。engineRqtChoice和engineChoice分别定义了发动机性能需求和发动机类型的选择，并通过约束确保高性能需求选择6缸发动机，而正常需求选择4缸发动机。transmissionChoice则定义了变速器的选择，并通过约束确保4缸发动机使用手动变速器，6缸发动机使用自动变速器。同时，后轴组件的rearWheelChoice允许选择窄边或宽边轮胎，并通过约束确保4缸发动机选择窄边轮胎，而6缸发动机选择宽边轮胎。最终，系统定义了一个整体配置vehicleChoice，包含不同配置变体vehicle_c1和vehicle_c2。此配置模型提供了灵活的组件选择机制，使系统能够满足不同的性能需求和设计要求。",
      "label": "package '7b-Variant Configurations' {\n\tprivate import RequirementsModel::*;\n\tprivate import DesignModel::*;\n\tprivate import VariantDefinitions::*;\n\tprivate import ControlFunctions::forAll;\n\t\n\tpackage RequirementsModel {\n\t\trequirement def EnginePerformanceRequirement;\n\t\trequirement highPerformanceRequirement : EnginePerformanceRequirement;\n\t\trequirement normalPerformanceRequirement : EnginePerformanceRequirement;\n\t}\n\t\n\tpackage DesignModel {\n\t\tpart def Vehicle;\n\t\tpart def Engine;\n\t\tpart def Transmission;\n\t\tpart def Clutch;\n\t\tpart def Driveshaft;\n\t\tpart def RearAxleAssembly;\n\t\tpart def Wheel;\n\t\t\n\t\tport def FuelCmdPort;\n\t\tport def ClutchPort;\n\t\tport def ShaftPort_b;\n\t\tport def ShaftPort_c;\n\t\tport def ShaftPort_d;\n\t\tport def VehicleToRoadPort;\n\t\tport def WheelToRoadPort;\n\t\t\n\t\tpart vehicle : Vehicle {\n\t\t\tport fuelCmdPort;\n\t\t\t\n\t\t\tbind fuelCmdPort = engine.fuelCmdPort;\n\t\t\t\n\t\t\tpart engine : Engine[1] {\n\t\t\t\tport fuelCmdPort : FuelCmdPort;\n\t\t\t}\n\t\t\t\n\t\t\tpart transmission : Transmission[1] {\n\t\t\t\tpart clutch: Clutch[1] {\n\t\t\t\t\tport clutchPort : ClutchPort;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpart driveshaft : Driveshaft[1] {\n\t\t\t\tport shaftPort_b : ShaftPort_b;\n\t\t\t\tport shaftPort_c : ShaftPort_c;\n\t\t\t}\n\t\t\t\n\t\t\tpart rearAxleAssembly : RearAxleAssembly {\n\t\t\t\tpart rearWheels : Wheel[2] {\n\t\t\t\t\tport wheelToRoadPort : WheelToRoadPort;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tport vehicleToRoadPort : VehicleToRoadPort {\n\t\t\t\tport wheelToRoadPort : WheelToRoadPort[2];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpackage VariantDefinitions {\n\t\tpart def '4CylEngine' :> Engine;\n\t\tpart def '6CylEngine' :> Engine;\n\t\t\n\t\tpart def ManualTransmission :> Transmission;\n\t\tpart def AutomaticTransmission :> Transmission;\n\t\t\n\t\tpart def ManualClutch :> Clutch;\n\t\tpart def AutomaticClutch :> Clutch;\n\t\t\n\t\tport def ManualClutchPort :> ClutchPort;\n\t\tport def AutomaticClutchPort :> ClutchPort;\n\t\t\n\t\tpart def NarrowRimWheel :> Wheel;\n\t\tpart def WideRimWheel :> Wheel;\t\t\n\t}\n\t\n\tpackage VariabilityModel {\n\t\tpart anyVehicleConfig :> vehicle {\n\t\t\t\n\t\t\tvariation requirement engineRqtChoice : EnginePerformanceRequirement {\n\t\t\t\tvariant highPerformanceRequirement;\n\t\t\t\tvariant normalPerformanceRequirement;\n\t\t\t}\n\t\t\t\n\t\t\tvariation part engineChoice :>> engine {\n\t\t\t\tvariant part '4cylEngine' : '4CylEngine';\n\t\t\t\tvariant part '6cylEngine' : '6CylEngine';\n\t\t\t}\n\t\t\t\n\t\t\tsatisfy engineRqtChoice by engineChoice;\n\t\t\t\n\t\t\tassert constraint 'engine choice constraint' {\n\t\t\t\tif engineRqtChoice == engineRqtChoice::highPerformanceRequirement? \n\t\t\t\t\tengineChoice == engineChoice::'6cylEngine' \n\t\t\t\telse\n\t\t\t\t\tengineChoice == engineChoice::'4cylEngine'\n\t\t\t}\n\t\t\t\n\t\t\tvariation part transmissionChoice :>> transmission {\n\t\t\t\tvariant part manualTransmission : ManualTransmission {\n\t\t\t\t\tpart :>> clutch : ManualClutch {\n\t\t\t\t\t\tport :>> clutchPort : ManualClutchPort;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvariant part automaticTransmission : AutomaticTransmission {\n\t\t\t\t\tpart :>> clutch : AutomaticClutch {\n\t\t\t\t\t\tport :>> clutchPort : AutomaticClutchPort;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tassert constraint 'engine-transmission selection constraint' {\n\t\t\t\t(engineChoice == engineChoice::'4cylEngine' and transmissionChoice == transmissionChoice::manualTransmission) xor\n\t\t\t\t(engineChoice == engineChoice::'6cylEngine' and transmissionChoice == transmissionChoice::automaticTransmission)\n\t\t\t}\n\t\t\t\n\t\t\tpart :>> rearAxleAssembly {\n\t\t\t\tvariation part rearWheelChoice :>> rearWheels {\n\t\t\t\t\tvariant part narrowRimWheel : NarrowRimWheel;\n\t\t\t\t\tvariant part wideRimWheel : WideRimWheel;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tassert constraint 'engine-wheel selection constraint' {\n\t\t\t\t(engineChoice == engineChoice::'4cylEngine' and \n\t\t\t\t\trearAxleAssembly.rearWheelChoice->forAll {in ref w; w == rearAxleAssembly::rearWheelChoice::narrowRimWheel}) xor\n\t\t\t\t(engineChoice == engineChoice::'6cylEngine' and \n\t\t\t\t\trearAxleAssembly.rearWheelChoice->forAll {in ref w; w == rearAxleAssembly::rearWheelChoice::wideRimWheel})\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tvariation part vehicleChoice :> anyVehicleConfig {\n\t\t\tvariant part vehicle_c1;\n\t\t\tvariant part vehicle_c2;\n\t\t}\t\n\t}\n}"
    },
    {
      "name": "8-Requirements",
      "text": "该系统需求描述了车辆系统的多项需求，包括质量限制、可靠性、驱动动力接口和扭矩生成的要求。在Vehicle Definitions中，定义了车辆（Vehicle）、引擎（Engine）、变速器（Transmission）等部件，车辆具有质量、燃料水平和油箱容量属性，引擎包含用于生成扭矩的动作和连接至变速器的接口。在Vehicle Requirements中，定义了多个需求规范：MassLimitationRequirement规定车辆的实际质量不能超过指定的质量，ReliabilityRequirement确保系统可靠性，drivePowerInterface要求引擎通过离合接口将生成的扭矩传输至变速器，torqueGeneration则要求引擎根据转速生成扭矩。具体需求实例中，vehicleMass1要求满油状态下车辆质量不超过2000千克，假设燃油箱是满的；vehicleMass2要求空油状态下车辆质量不超过2500千克，假设燃油箱为空。在vehicle1_c1 Specification Context中，通过将vehicle1_c1实例与需求进行关联，确保它满足相关质量和动力传输接口要求；同时，在vehicle1_c2 Specification Context中，将vehicle1_c2实例与空油状态的质量需求和可靠性要求关联，从而保证该实例符合指定的需求。整个系统通过这些需求定义和约束，确保车辆的不同配置在特定条件下满足各项性能和功能要求。",
      "label": "package '8-Requirements' {\n\tprivate import ScalarValues::Real;\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tpublic import 'Vehicle Usages'::*;\n\tpublic import 'Vehicle Requirements'::*;\n\t\n\tpackage 'Vehicle Definitions' {\n\t\tpart def Vehicle {\n\t\t\tattribute mass: MassValue;\n\t\t\tattribute fuelLevel: Real;\n\t\t\tattribute fuelTankCapacity: Real;\n\t\t}\n\t\t\n\t\tpart def Engine {\n\t\t\tport drivePwrPort: DrivePwrPort;\n\t\t\tperform action 'generate torque': 'Generate Torque';\n\t\t}\n\t\t\n\t\tpart def Transmission {\n\t\t\tport clutchPort: ClutchPort;\n\t\t}\n\t\t\n\t\tport def DrivePwrPort;\n\t\tport def ClutchPort;\n\t\t\n\t\tinterface def EngineToTransmissionInterface {\n\t\t\tend drivePwrPort: DrivePwrPort;\n\t\t\tend clutchPort: ClutchPort;\n\t\t}\n\t\n\t\taction def 'Generate Torque';\n\t}\n\t\n\tpackage 'Vehicle Usages' {\n\t\tpublic import 'Vehicle Definitions'::*;\n\t\t\n\t\taction 'provide power' {\n\t\t\taction 'generate torque' { /* ... */ }\n\t\t\t//...\n\t\t}\n\t\t\n\t\tpart vehicle1_c1: Vehicle {\n\t\t\tattribute :>> mass = 2000 [kg];\n\t\t\tperform 'provide power';\n\t\t\t\t\n\t\t\tpart engine_v1: Engine {\n\t\t\t\tport :>> drivePwrPort;\n\t\t\t\tperform 'provide power'.'generate torque' :>> 'generate torque';\n\t\t\t}\n\t\t\t\n\t\t\tpart transmission: Transmission {\n\t\t\t\tport :>> clutchPort;\n\t\t\t}\n\t\t\t\n\t\t\tinterface engineToTransmission: EngineToTransmissionInterface\n\t\t\t\tconnect engine_v1.drivePwrPort to transmission.clutchPort;\n\t\t}\n\t\t\n\t\tpart vehicle1_c2: Vehicle {\n\t\t\tattribute :>> mass = 2500 [kg];\n\t\t}\n\t}\n\t\n\tpackage 'Vehicle Requirements' {\t\n\t\tpublic import 'Vehicle Definitions'::*;\n\t\n\t\trequirement def <'1'> MassLimitationRequirement {\n\t\t\t/*\n\t\t\t * The optional requirement ID  of this requirement ('1') is given after the keyword \"id\" (using name syntax).\n\t\t\t * Every requirement is parameterized by a \"subject\". The \"subject\" of this requirement is implicitly \"Anything\".\n\t\t\t */\n\t\t\n\t\t\t// The requirement text is given by the documentation in the requirement def body.\n\t\t\tdoc /* The actual mass shall be less than or equal to the required mass. */\n\t\t\t\n\t\t\tattribute massActual: MassValue;\n\t\t\tattribute massReqd: MassValue;\n\t\t\t\n\t\t\trequire constraint {\n\t\t\t\t/*\n\t\t\t\t * A constraint can be used to formalize a requirement.\n\t\t\t\t */\n\t\t\t\t massActual <= massReqd \n\t\t\t }\n\t\t}\n\t\t\n\t\trequirement def <'2'> ReliabilityRequirement;\n\t\t\n\t\trequirement <'1.1'> vehicleMass1: MassLimitationRequirement {\n\t\t\tdoc /* The vehicle mass shall be less than or equal to 2000 kg when the fuel tank is full. */\n\t\t\t\n\t\t\tsubject vehicle : Vehicle {\n\t\t\t\t/*\n\t\t\t\t * The subject of this requirement is redefined to be a \"Vehicle\".\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\tattribute :>> massActual: MassValue = vehicle.mass {\n\t\t\t\t/*\n\t\t\t\t * This redefinition binds the vehicle mass to the actual mass.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\tattribute :>> massReqd = 2000 [kg] {\n\t\t\t\t/*\n\t\t\t\t * This redefinition sets the required mass to 2000 kg.\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\tassume constraint fuelConstraint {\n\t\t\t\t/*\n\t\t\t\t * A constraint can also be used to specify an assumption.\n\t\t\t\t */\n\t\t\t\n\t\t\t\tdoc /* full fuel tank */\n\t\t\t\tvehicle.fuelLevel >= vehicle.fuelTankCapacity\n\t\t\t}\n\t\t}\n\t\t\t\n\t\trequirement <'2.1'> vehicleMass2: MassLimitationRequirement {\n\t\t\tdoc /* The vehicle mass shall be less than or equal to 2500 kg when the fuel tank is empty. */\n\t\t\t\n\t\t\tsubject vehicle : Vehicle;\n\t\t\t\n\t\t\tattribute :>> massActual: MassValue = vehicle.mass;\n\t\t\tattribute :>> massReqd = 2500 [kg];\n\t\t\n\t\t\tassume constraint fuelConstraint {\n\t\t\t\tdoc /* empty fuel tank */\n\t\t\t\tvehicle.fuelLevel == 0.0\n\t\t\t}\n\t\t}\n\t\t\n\t\trequirement <'2.2'> vehicleReliability2: ReliabilityRequirement {\n\t\t\tsubject vehicle : Vehicle;\n\t\t}\n\t\t\t\n\t\trequirement <'3.1'> drivePowerInterface {\n\t\t\tdoc /* The engine shall transfer its generated torque to the transmission via the clutch interface. */\n\t\t\tsubject drivePwrPort: DrivePwrPort;\n\t\t}\n\t\t\n\t\trequirement <'3.2'> torqueGeneration {\n\t\t\tdoc /* The engine shall generate torque as a function of RPM as shown in Table 1. */\n\t\t\tsubject generateTorque: 'Generate Torque';\n\t\t}\n\t\t\t\n\t}\n\t\n\tpart 'vehicle1_c1 Specification Context' {\n\t\tprivate import 'vehicle1-c1 Specification'::*;\n\t\tprivate import 'engine-v1 Specification'::*;\n\t\t\n\t\trequirement 'vehicle1-c1 Specification' {\n\t\tdoc\n\t\t/*\n\t\t * This models a \"requirement group\" as a requirement that references other requirements.\n\t\t */\n\t\t\n\t\t\tsubject vehicle : Vehicle;\n\t\t\trequirement references vehicleMass1 {\n\t\t\t\t/*\n\t\t\t\t * This is a reference to a requirement defined outside the group.\n\t\t\t\t * By default, the subject of the requirement is bound to that of the group.\n\t\t\t\t */\t\t\t\t\n\t\t\t}\n\t\t\t// ...\n\t\t}\n\t\t\n\t\trequirement 'engine-v1 Specification' {\n\t\t\tsubject engine : Engine;\n\t\t\t/* \n\t\t\t * Here the subjects of the referenced requirements are defined to be specific properties of the\n\t\t\t * subject of the group.\n\t\t\t */\n\t\t\trequire torqueGeneration {\n\t\t\t\tin :>> generateTorque = engine.'generate torque';\n\t\t\t}\n\t\t\trequire drivePowerInterface {\n\t\t\t\tin :>> drivePwrPort = engine.drivePwrPort; \n\t\t\t}\n\t\t}\n\t\t\n\t\tsatisfy 'vehicle1-c1 Specification' by vehicle1_c1 {\n\t\t\t/*\n\t\t\t * This asserts that if the assumptions of 'vehicle1-c1 Specification' are true with 'vehicle_c1' as\n\t\t\t * the subject, then the required constraints are also true.\n\t\t\t */\n\t\t}\n\t\tsatisfy 'engine-v1 Specification' by vehicle1_c1.engine_v1;\n\t}\n\t\n\tpart 'vehicle1_c2 Specification Context' {\n\t\tprivate import 'vehicle1-c2 Specification'::*;\n\t\t\n\t\trequirement 'vehicle1-c2 Specification' {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\trequire vehicleMass2;\n\t\t\trequire vehicleReliability2;\n\t\t}\n\t\t\n\t\tsatisfy 'vehicle1-c2 Specification' by vehicle1_c2;\n\t}\n}"
    },
    {
      "name": "9-Verification-simplified",
      "text": "该系统需求描述了车辆质量的验证流程，确保车辆的实际质量符合所要求的质量限制。在Definitions包中，定义了质量需求MassRequirement，要求实际质量不得超过规定的质量上限，并定义了验证对象Vehicle和验证系统MassVerificationSystem。具体实例TestVehicle1和TestVehicle2分别作为验证车辆的个体，TestSystem作为验证系统的个体。在Usages包中，定义了具体的车辆质量需求vehicleMassRequirement，要求车辆质量不超过2500千克。vehicleMassTest验证过程包含三个主要动作：collectData从被测车辆中收集实际质量数据并输出测量质量，processData将收集到的质量数据进一步处理为输出的质量数据，evaluateData将处理后的质量数据与需求进行比较，并输出验证结果。在massVerificationSystem中，系统执行vehicleMassTest，其中被测车辆（vehicleUnderTest）连接到测试过程。scale组件通过测量动作collectData读取被测车辆的质量并输出测量数据。通过timeslice机制，系统首先在test1中将TestVehicle1作为vehicleUnderTest，质量设为2500千克，然后在test2中使用TestVehicle2重复测试。此需求描述了车辆质量验证的整个流程，包括数据收集、处理和评估步骤，以确保测试车辆符合所要求的质量限制。",
      "label": "package '9-Verification-simplified' {\n\tprivate import VerificationCases::*;\n\tprivate import Definitions::*;\n\t\n\tpackage Definitions {\n\t\n\t\trequirement def <'2'> MassRequirement {\n\t\t\tattribute massActual :> ISQ::mass;\n\t\t\tattribute massReqd :> ISQ::mass;\n\t\t\t\n\t\t\tdoc /* The actual mass shall be less than or equal to the required mass limit. */\n\t\t\t\n\t\t\trequire constraint { massActual <= massReqd }\n\t\t}\n\t\t\n\t\tpart def Vehicle {\n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\n\t\t\n\t\tpart def MassVerificationSystem;\n\t\tpart def Scale;\n\t\tpart def TestOperator;\n\t\t\n\t\tindividual def TestVehicle1 :> Vehicle;\n\t\tindividual def TestVehicle2 :> Vehicle;\n\n\t\tindividual def TestSystem :> MassVerificationSystem;\n\t\n\t\tverification def MassTest {\n\t\t\tobjective massVerificationObjective {\n\t\t\t\tverify requirement massRequirement : MassRequirement;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t}\n\t\n\tpackage Usages {\n\t\n\t\trequirement <'2.1'> vehicleMassRequirement : MassRequirement {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\tdoc /* The vehicle mass shall be less than or equal to 2500 kg. */\n\t\t\t\n\t\t\t:>> massActual = vehicle.mass;\t\t\n\t\t\t:>> massReqd = 2500 [SI::kg];\n\t\t}\n\t\t\n\t\tpart vehicle1_c2 : Vehicle {\n\t\t\t// ...\n\t\t}\n\t\t\n\t\tverification vehicleMassTest : MassTest {\n\t\t\tsubject testVehicle : Vehicle;\n\t\t\tobjective vehicleMassVerificationObjective {\n\t\t\t\t// The subject of the verify is automatically bound to 'testVehicle' here.\n\t\t\t\tverify vehicleMassRequirement :>> massRequirement;\n\t\t\t}\n\t\t\t\n\t\t\taction collectData {\n\t\t\t\tin part testVehicle : Vehicle = vehicleMassTest.testVehicle;\n\t\t\t\tout massMeasured :> ISQ::mass;\n\t\t\t}\n\t\t\t\n\t\t\taction processData {\n\t\t\t\tin massMeasured :> ISQ::mass = collectData.massMeasured;\n\t\t\t\tout massProcessed :> ISQ::mass;\n\t\t\t}\n\t\t\t\n\t\t\taction evaluateData {\n\t\t\t\tin massProcessed :> ISQ::mass = processData.massProcessed;\n\t\t\t\tout verdict : VerdictKind = \n\t\t\t\t\t// Check that 'testVehicle' statisfies 'vehicleMassRequirement' if its mass equals 'massProcessed'.\n\t\t\t\t\tPassIf(vehicleMassRequirement(vehicle = testVehicle(mass = massProcessed)));\n\t\t\t}\n\t\t\t\n\t\t\treturn verdict : VerdictKind = evaluateData.verdict;\n\t\t}\n\t\t\n\t\tpart massVerificationSystem : MassVerificationSystem {\n\t\t\tperform vehicleMassTest {\n\t\t\t\tin part :>> testVehicle = vehicleUnderTest;\n\t\t\t}\n\t\t\t\n\t\t\tref part vehicleUnderTest : Vehicle;\n\t\t\t\n\t\t\tpart testOperator : TestOperator;\n\t\t\t\n\t\t\tpart scale : Scale {\n\t\t\t\tperform vehicleMassTest.collectData {\n\t\t\t\t\tin part :>> testVehicle;\n\t\t\t\t\t\n\t\t\t\t\t// In reality, this would be some more involved process.\n\t\t\t\t\tmeasurement = testVehicle.mass;\n\t\t\t\t\t\n\t\t\t\t\tout :>> massMeasured = measurement;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tindividual testSystem : TestSystem :> massVerificationSystem {\n\t\t\ttimeslice test1 {\n\t\t\t\tref individual :>> vehicleUnderTest : TestVehicle1 :> vehicle1_c2 {\n\t\t\t\t\t:>> mass = 2500 [SI::kg];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthen timeslice test2 {\n\t\t\t\tref individual :>> vehicleUnderTest : TestVehicle2 :> vehicle1_c2 {\n\t\t\t\t\t:>> mass = 2500 [SI::kg];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
    },
    {
      "name": "10a-Analysis",
      "text": "该系统需求描述了一个车辆质量分析模型，通过计算车辆各部件的质量总和来实现总体质量评估。在VehicleDesignModel包中，定义了车辆部件的质量属性，车辆（Vehicle）的总质量是其引擎、变速器、前轴组件和后轴组件质量的总和。每个部件（如引擎、变速器等）都有单独的质量属性。VehicleAnalysisModel包中定义了质量分析的目标（MassAnalysisObjective）和分析流程MassAnalysisCase，其中MassAnalysisCase对车辆的总质量进行分析。AnalysisPlan中嵌套了具体的分析案例，依赖于定义在设计模型中的车辆实例，返回车辆总质量。最后，在massAnalysisContext中执行AnalysisPlan，以VehicleDesignModel中的车辆为主体，计算并输出其质量总和。此需求为车辆质量分析提供了系统的结构和流程，确保所有部件的质量被准确累加并符合设计要求。",
      "label": "package '10a-Analysis' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\t\n\tpackage VehicleDesignModel {\n\t\tpart def Vehicle {\n\t\t\tmass : MassValue;\n\t\t}\n\t\t\n\t\tpart vehicle {\n\t\t\t:>> mass : MassValue = sum((\n\t\t\t\tvehicle.engine.mass, \n\t\t\t\tvehicle.transmission.mass, \n\t\t\t\tvehicle.frontAxleAssembly.mass, \n\t\t\t\tvehicle.rearAxleAssembly.mass\n\t\t\t));\n\t\t\t\n\t\t\tpart engine {\n\t\t\t\tmass : MassValue;\n\t\t\t}\n\t\t\t\n\t\t\tpart transmission {\n\t\t\t    mass : MassValue;\n\t\t\t}\n\t\t\t\n\t\t\tpart frontAxleAssembly {\n\t\t\t\tmass : MassValue;\n\t\t\t}\n\t\t\t\n\t\t\tpart rearAxleAssembly {\n\t\t\t\tmass : MassValue;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpackage VehicleAnalysisModel {\n\t\tprivate import VehicleDesignModel::Vehicle;\n\t\t\n\t\trequirement def MassAnalysisObjective {\n\t\t\tsubject mass : MassValue;\n\t\t\tdoc /* ... */\n\t\t}\n\t\n\t\tanalysis def MassAnalysisCase {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\tobjective : MassAnalysisObjective;\n\t\t\t\n\t\t\t// Result\n\t\t\tvehicle.mass\n\t\t}\n\t\t\n\t\tanalysis def AnalysisPlan {\n\t\t\tsubject vehicle : Vehicle;\t\t\t\n\t\t\tobjective {\n\t\t\t\tdoc /* ... */\n\t\t\t}\n\t\t\t\n\t\t\tanalysis massAnalysisCase : MassAnalysisCase {\n\t\t\t\t/*\n\t\t\t\t * By default, the subject of a nested analysis case bound to that\n\t\t\t\t * of its containing analysis case or analysis case definition.\n\t\t\t\t */\n\t\t\t \treturn mass; \n\t\t\t }\n\t\t}\n\t\t\n\t\tpart massAnalysisContext {\n\t\t\tanalysis analysisPlan : AnalysisPlan {\n\t\t\t\tsubject vehicle = VehicleDesignModel::vehicle;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "name": "10b-Trade-off Among Alternative Configurations",
      "text": "该系统需求描述了在多种引擎配置之间进行权衡的分析模型，旨在选择最优配置。在Definitions包中，定义了车辆和引擎的关键部件，包括引擎、活塞（Piston）、气缸（Cylinder）、连杆（ConnectingRod）、以及曲轴（CrankShaft），其中曲轴分为4缸和6缸两种型号。在Usages包中，定义了具体的引擎配置选择（engineChoice），其中4缸引擎包含4个气缸和一个4缸曲轴，而6缸引擎包含6个气缸和一个6缸曲轴。在具体车辆实例中，选择了6缸引擎，并通过约束声明该选择是基于后续分析engineTradeStudy中评估的最佳配置。在Analysis包中，EngineEvaluation计算功能基于功率、质量、效率和成本等指标对引擎配置进行评估。engineTradeStudy定义了权衡分析的流程，目标是最大化整体性能，通过计算功率、质量、效率和成本的累计值，将其输入EngineEvaluation函数，返回评分作为最终的选择依据。系统最终选择评分最高的引擎配置并将其设置为selectedAlternative，用于后续设计选择。此模型提供了系统化的权衡分析流程，确保在不同配置中选择出符合性能和成本要求的最佳引擎配置。",
      "label": "package '10b-Trade-off Among Alternative Configurations' {\n\tprivate import ScalarValues::Real;\n\tprivate import TradeStudies::*;\n\tprivate import Definitions::*;\n\tprivate import Usages::*;\n\t\n\tpackage Definitions {\n\t\t\n\t\tpart def Vehicle;\n\t\t\n\t\tpart def Engine {\n\t\t\tpower : ISQ::PowerValue;\n\t\t\tmass : ISQ::MassValue;\n\t\t\tefficiency : Real;\n\t\t\treliability : Real;\n\t\t\tcost : Real;\n\t\t}\n\t\t\n\t\tpart def Piston;\n\t\tpart def Cylinder;\n\t\tpart def ConnectingRod;\n\t\tpart def CrankShaft;\n\t\t\n\t\tpart def '4CylCrankShaft' :> CrankShaft;\n\t\tpart def '6CylCrankShaft' :> CrankShaft;\n\t\t\n\t}\n\t\n\tpackage Usages {\n\t\t\n\t\tpart engine : Engine {\n\t\t\tpart cyl[*] : Cylinder {\n\t\t\t\tpart p[1] : Piston;\n\t\t\t\tpart rod[1] : ConnectingRod;\n\t\t\t}\n\t\t\t\n\t\t\tpart cs : CrankShaft;\n\t\t}\n\t\t\n\t\tvariation part engineChoice :> engine {\n\t\t\tvariant part '4cylEngine' {\n\t\t\t\tpart :>> cyl[4];\n\t\t\t\tpart :>> cs : '4CylCrankShaft';\n\t\t\t}\n\t\t\t\n\t\t\tvariant part '6cylEngine' {\n\t\t\t\tpart :>> cyl[6];\n\t\t\t\tpart :>> cs : '6CylCrankShaft';\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart vehicle : Vehicle {\n\t\t\tpart engine[1] :> engineChoice = engineChoice::'6cylEngine' {\n\t\t\t\tassert constraint engineSelectionRational { \n\t\t\t\t\tdoc /* Selected the best engine based on the 'engineTradeStudy'. */\n\t\t\t\t\tengine == Analysis::engineTradeStudy.selectedAlternative\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tpackage Analysis {\n\n\t\tcalc def EngineEvaluation {\n\t\t\tdoc /* Evaluation function with criteria power, mass, efficency and cost. */\n\t\t\tin power : ISQ::PowerValue;\n\t\t\tin mass : ISQ::MassValue; \n\t\t\tin efficiency : Real; \n\t\t\tin cost : Real;\n\t\t\treturn evaluation : Real;\n\t\t\t// Compute evaluation...\n\t\t}\n\t\t\t\n\t\tanalysis engineTradeStudy : TradeStudy {\n\t\t\tsubject : Engine[1..*] = all engineChoice;\n\t\t\tobjective : MaximizeObjective;\n\n\t\t\tcalc :>> evaluationFunction {\n\t\t\t\tin part anEngine :>> alternative : Engine;\n\t\t\t\t\n\t\t\t\tcalc powerRollup { in engine = anEngine; return power:>ISQ::power; }\n\t\t\t\tcalc massRollup { in engine = anEngine; return mass:>ISQ::mass; }\n\t\t\t\tcalc efficiencyRollup { in engine = anEngine; return efficiency: Real; }\n\t\t\t\tcalc costRollup { in engine = anEngine; return cost: Real; }\n\t\t\t\t\n\t\t\t\treturn :>> result : Real = EngineEvaluation(\n\t\t\t\t\tpowerRollup.power, massRollup.mass, efficiencyRollup.efficiency, costRollup.cost\n\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\treturn part :>> selectedAlternative : Engine;\n\t\t}\n        \n\t}\n\t\n}"
    },
    {
      "name": "10c-Fuel Economy Analysis",
      "text": "该系统需求描述了一个车辆燃油经济性的分析模型，用于评估车辆在不同驾驶场景下的燃油经济性，确保其满足指定的要求。在FuelEconomyRequirementsModel中定义了燃油经济性需求（FuelEconomyRequirement），要求车辆的实际燃油经济性不低于规定值，其中市区燃油经济性要求不低于25英里/加仑，高速公路燃油经济性要求不低于30英里/加仑。在VehicleDesignModel中，定义了具体的车辆结构，包括车辆、引擎、变速器等，车辆属性包含市区和高速燃油经济性及载重量。具体车辆实例vehicle1_c1配有引擎和变速器，并定义了变速器的齿轮状态。在FuelEconomyAnalysisModel中，定义了燃油经济性的分析模型（FuelEconomyAnalysis），用于模拟市区和高速公路驾驶情景。分析通过动力学分析（dynamicsAnalysis）确定车辆在各情景下的发动机功率需求，并进行燃油消耗分析（fuelConsumptionAnalysis）计算引擎的燃油消耗，燃油经济性结果作为输出。分析上下文analysisContext执行了市区和高速公路燃油经济性分析，将vehicle1_c1作为分析对象，通过计算得到其市区和高速燃油经济性，分别赋值给fuelEconomy_city和fuelEconomy_highway属性，最终验证其是否满足市区和高速公路的燃油经济性需求。此需求描述了系统的分析结构和流程，以确保车辆燃油经济性符合设计目标。",
      "label": "package '10c-Fuel Economy Analysis' {\n\tprivate import ScalarValues::*;\n\tprivate import Quantities::*;\n\tprivate import MeasurementReferences::*;\n\tprivate import ISQ::*;\n\tprivate import USCustomaryUnits::*;\n\t\n\tattribute distancePerVolume : ScalarQuantityValue = length / volume;\t\n\tattribute gallon : MeasurementUnit = 231.0 * 'in'^3;\n\t\n\tpackage FuelEconomyRequirementsModel {\n\t\t\n\t\trequirement def FuelEconomyRequirement {\n\t\t\tattribute actualFuelEconomy :> distancePerVolume;\n\t\t\tattribute requiredFuelEconomy :> distancePerVolume;\n\t\t\t\n\t\t\trequire constraint { actualFuelEconomy >= requiredFuelEconomy }\n\t\t}\n\t\t\n\t\trequirement cityFuelEconomyRequirement : FuelEconomyRequirement {\n\t\t\t:>> requiredFuelEconomy = 25 [mi/gallon];\n\t\t}\n\t\t\n\t\trequirement highwayFuelEconomyRequirement : FuelEconomyRequirement {\n\t\t\t:>> requiredFuelEconomy = 30 [mi/gallon];\n\t\t}\n\t\t\n\t}\n\t\t\n\tpackage VehicleDesignModel {\n\t\t\n\t\tpart def Vehicle {\n\t\t\tattribute fuelEconomy_city :> distancePerVolume;\n\t\t\tattribute fuelEconomy_highway :> distancePerVolume;\n\t\t\t\n\t\t\tattribute cargoWeight : MassValue;\n\t\t}\n\t\t\n\t\tpart def Engine;\n\t\tpart def Transmission;\n\t\t\n\t\tpart vehicle1_c1 : Vehicle {\n\t\t\tpart engine : Engine;\n\t\t\tpart transmission : Transmission {\n\t\t\t\texhibit state transmissionState {\n\t\t\t\t\tentry; then '1stGear';\n\t\t\t\t\tstate '1stGear';\n\t\t\t\t\tthen '2ndGear';\n\t\t\t\t\tstate '2ndGear';\n\t\t\t\t\tthen '3rdGear';\n\t\t\t\t\tstate '3rdGear';\n\t\t\t\t\tthen '4thGear';\n\t\t\t\t\tstate '4thGear';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpackage FuelEconomyAnalysisModel {\n\t\tprivate import VehicleDesignModel::*;\n\t\tprivate import FuelEconomyRequirementsModel::*;\n\t\t\n\t\tattribute def ScenarioState {\n\t\t\tposition : LengthValue;\n\t\t\tvelocity : SpeedValue;\n\t\t\tacceleration : AccelerationValue;\n\t\t\tinclineAngle : AngularMeasureValue;\n\t\t}\n\t\t\n\t\tabstract calc def NominalScenario { \n\t\t\tin t : TimeValue; \n\t\t\treturn : ScenarioState;\n\t\t}\n\t\tcalc cityScenario : NominalScenario;\n\t\tcalc highwayScenario : NominalScenario;\n\t\t\n\t\tanalysis def FuelEconomyAnalysis {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\tin calc scenario : NominalScenario;\n\t\t\tin requirement fuelEconomyRequirement : FuelEconomyRequirement;\n\t\t\treturn calculatedFuelEconomy : ScalarQuantityValue;\n\t\t\t\n\t\t\tobjective fuelEconomyAnalysisObjective {\n\t\t\t\tdoc /*\n\t\t\t\t     * The objective of this analysis is to determine whether the\n\t\t\t\t     * current vehicle design configuration can satisfy the fuel\n\t\t\t\t     * economy requirement.\n\t\t\t\t     */\n\t\t\t\t \n\t\t\t\t assume constraint {\n\t\t\t\t \tdoc /* wheelDiameter == 33 inches\n\t\t\t\t \t     * drive train efficiency == 0.4\n\t\t\t\t \t     */\n\t\t\t\t }\n\t\t\t\t \n\t\t\t\t require fuelEconomyRequirement {\n\t\t\t\t \t:>> actualFuelEconomy = calculatedFuelEconomy;\n\t\t\t\t }\n\t\t\t}\n\t\t\t\n\t\t\taction dynamicsAnalysis {\n\t\t\t\t/*\n\t\t\t\t * Solve for the required engine power as a function of time\n\t\t\t\t * to support the nominal scenarios.\n\t\t\t\t * \n\t\t\t\t * Note: Vehicle force = power/speed\n\t\t\t\t * Note: EngineRPM * EngineGearRatio/WheelRPM = constant\n\t\t\t\t */\n\t\t\t}\n\t\t\t\n\t\t\taction fuelConsumptionAnalysis {\n\t\t\t\t/*\n\t\t\t\t * Solve the engine equations to determine how much fuel is\n\t\t\t\t * consumed. The engine RPM is a function of the speed of the\n\t\t\t\t * vehicle and the gear state.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t\t\n\t\trequirement vehicleFuelEconomyRequirementsGroup {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\trequirement vehicleFuelEconomyRequirement_city :> cityFuelEconomyRequirement {\n\t\t\t\tdoc /* The vehicle shall provide a fuel economy that is greater than or equal to\n\t\t\t\t     * 25 miles per gallon for the nominal city driving scenarios.\n\t\t\t\t     */\n\t\t\t\t \n\t\t\t\t:>> actualFuelEconomy = vehicle.fuelEconomy_city;\n\t\t\t\t\n\t\t\t\tassume constraint { vehicle.cargoWeight == 1000 [lb] }\n\t\t\t}\n\n\t\t\trequirement vehicleFuelEconomyRequirement_highway :> highwayFuelEconomyRequirement {\n\t\t\t\tdoc /* The vehicle shall provide a fuel economy that is greater than or equal to\n\t\t\t\t     * 30 miles per gallon for the nominal highway driving scenarios.\n\t\t\t\t     */\n\t\t\t\t\n\t\t\t\t:>> actualFuelEconomy = vehicle.fuelEconomy_highway;\n\t\t\t\t\n\t\t\t\tassume constraint { vehicle.cargoWeight == 1000 [lb] }\n\t\t\t}\n\n\t\t}\n\n\t\tpart analysisContext {\n\t\t\t\n\t\t\tanalysis cityFuelEconomyAnalysis : FuelEconomyAnalysis {\n\t\t\t\tsubject vehicle = vehicle1_c1;\n\t\t\t\tin calc scenario = cityScenario;\n\t\t\t\tin requirement fuelEconomyRequirement = cityFuelEconomyRequirement;\n\t\t\t} \n\t\t\t\n\t\t\tanalysis highwayFuelEconomyAnalysis : FuelEconomyAnalysis {\n\t\t\t\tsubject vehicle = vehicle1_c1;\n\t\t\t\tin calc scenario = highwayScenario;\n\t\t\t\tin requirement fuelEconomyRequirement = highwayFuelEconomyRequirement;\n\t\t\t}\n\t\t\t\n\t\t\tpart vehicle1_c1_analysized :> vehicle1_c1 {\n\t\t\t\t:>> fuelEconomy_city = cityFuelEconomyAnalysis.calculatedFuelEconomy;\n\t\t\t\t:>> fuelEconomy_highway = highwayFuelEconomyAnalysis.calculatedFuelEconomy;\n\t\t\t}\t\t\n\t\t\t\n\t\t\tsatisfy vehicleFuelEconomyRequirementsGroup by vehicle1_c1_analysized;\n\t\t}\n\t\t\n\t}\n}"
    },
    {
      "name": "10d-Dynamics Analysis",
      "text": "该系统需求描述了一个车辆动力学分析模型，通过计算车辆在特定功率输入下的加速度、速度和位置变化，以评估其动力学行为。在VehicleModel中定义了车辆的基本属性质量（mass）。在DynamicsModel中，定义了多个计算函数：Acceleration函数根据功率、质量和速度计算加速度；Velocity函数根据初始速度、加速度和时间增量计算速度；Position函数根据初始位置、速度和时间增量计算位置。StraightLineDynamics动作整合了这些函数，输入功率、质量、时间增量、初始位置和初始速度，输出新的位置、速度和加速度。在AnalysisModel中，定义了DynamicsAnalysis分析过程，以车辆为主体，输入功率曲线、初始位置、初始速度和时间增量。该过程通过循环遍历功率曲线的每个时间步，调用StraightLineDynamics计算当前步的动力学状态，然后更新位置、速度和加速度，并将每个时间步的加速度值添加至加速度曲线（accelerationProfile）中。整个需求提供了车辆在直线动力学条件下的完整分析过程，支持评估车辆在不同功率输入下的动态表现。",
      "label": "package '10d-Dynamics Analysis' {\n\tprivate import ISQ::*;\n\t\n\tpackage VehicleModel {\n\t\n\t\tpart def Vehicle {\n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\n\t\n\t}\n\t\n\tpackage DynamicsModel {\n\t    \n\t    calc def Acceleration {\n\t    \tin p : PowerValue;\n\t    \tin m : MassValue;\n\t    \tin v : SpeedValue;\n\t    \treturn : AccelerationValue = p / (m * v);\n\t    }\n\t    \n\t    calc def Velocity {\n\t    \tin v0 : SpeedValue; \n\t    \tin a : AccelerationValue; \n\t    \tin dt : TimeValue;\n\t    \treturn : SpeedValue = v0 + a * dt;\n\t    }\n\t    \n\t    calc def Position {\n\t    \tin x0 : LengthValue;\n\t    \tin v : SpeedValue; \n\t    \tin dt : TimeValue;\n\t    \treturn : LengthValue = x0 + v * dt;\n\t    }\n\t    \n\t    action def StraightLineDynamics {\n\t        in power : PowerValue;\n\t        in mass : MassValue;\n\t        in delta_t : TimeValue;\n\t        in x_in : LengthValue;\n\t        in v_in : SpeedValue;\n\t        out x_out : LengthValue = Position(x_in, v_in, delta_t);\n\t        out v_out : SpeedValue = Velocity(v_in, a_out, delta_t);\n\t        out a_out : AccelerationValue = Acceleration(power, mass, v_in);\n\t    }\n\t}\n\t\n\tpackage AnalysisModel {\n\t\tprivate import VehicleModel::*;\n\t\tprivate import DynamicsModel::*;\n\t\tprivate import SampledFunctions::*;\n\t\tprivate import ScalarValues::Natural;\n\t\tprivate import SequenceFunctions::*;\n\t\t\n\t\tanalysis def DynamicsAnalysis {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\tin attribute powerProfile :> ISQ::power[*];\n\t\t\tin attribute initialPosition :> ISQ::length;\n\t\t\tin attribute initialSpeed :> ISQ::speed;\n\t\t\tin attribute deltaT :> ISQ::time;\n\t\t\treturn attribute accelerationProfile :> ISQ::acceleration[*] := ();\n\t\t\t\n\t\t\tprivate attribute position := initialPosition;\n\t\t\tprivate attribute speed := initialSpeed;\n\t\t\t\n\t\t\tfor i in 1..powerProfile->size()-1 {\n\t\t\t\tperform action dynamics : StraightLineDynamics {\n\t\t\t\t\tin power = powerProfile#(i);\n\t\t\t\t\tin mass = vehicle.mass;\n\t\t\t\t\tin delta_t = deltaT;\n\t\t\t\t\tin x_in = position;\n\t\t\t\t\tin v_in = speed;\n\t\t\t\t}\n\t\t\t\tthen assign position := dynamics.x_out;\n\t\t\t\tthen assign speed := dynamics.v_out;\n\t\t\t\tthen assign accelerationProfile := accelerationProfile->including(dynamics.a_out);\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "11a-View-Viewpoint",
      "text": "系统应支持定义多个包，以便组织和管理不同的模型视角和视图。每个包可以包含不同的模型元素，这些元素可以是组件、属性或视图，并且可以通过关联系统模型与视图模型来提供不同的分析视角。\n\n在**SystemModel**包中，系统定义了一个包含多个部分的车辆模型。该模型包括前后轴总成、轴和车轮等部件，每个部件都有特定的质量属性，并且这些部件之间存在层次结构。例如，车辆包括前轴和后轴，每个轴总成包含车轮和轴本身，并且每个轴的质量和转向角度都有明确的属性。这种结构化的定义帮助系统描述车辆的各个部分及其关系。\n\n在**ViewModel**包中，系统定义了一个视图模型，支持基于不同的视角展示系统的结构。此视图模型包括一个名为“系统结构视角”的框架，旨在展示系统的构成。在这个视角下，可以通过列视图的形式呈现系统结构，并用文本标注的方式显示每个元素的详细信息。通过“系统结构生成”视图，系统可以生成并展示系统的各个部分，帮助工程师理解系统组件之间的关系和布局。\n\n整体而言，系统支持通过不同的视角和视图呈现复杂系统模型的结构和组成部分，从而使得模型更加易于理解和管理。",
      "label": "package '11a-View-Viewpoint' {\n\t\n\tpackage SystemModel {\n\t\tprivate import SI::*;\n\t\t\n\t\tpart def Vehicle;\n\t\tpart def AxleAssembly;\n\t\tpart def Axle;\n\t\tpart def Wheel;\n\t\t\n\t\tpart vehicle : Vehicle {\n\t\t\tattribute mass :> ISQ::mass = 2500[SI::kg];\n\t\t\tpart frontAxleAssembly : AxleAssembly[1] {\n\t\t\t\tattribute mass :> ISQ::mass = 150[kg];\n\t\t\t\tpart frontWheel : Wheel[2];\n\t\t\t\tpart frontAxle : Axle[1] {\n\t\t\t\t\tattribute mass;\n\t\t\t\t\tattribute steeringAngle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart rearAxleAssembly : AxleAssembly[1] {\n\t\t\t\tattribute mass :> ISQ::mass = 250[kg];\n\t\t\t\tpart rearWheel : Wheel[2];\n\t\t\t\tpart rearAxle : Axle[1] {\n\t\t\t\t\tattribute mass;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpackage ViewModel {\n\t\tprivate import Views::*;\n\t\n\t\tpart 'systems engineer';\n\t\t\n\t\tconcern 'system breakdown' {\n\t\t\tstakeholder :>> 'systems engineer';\n\t\t}\n\t\t\n\t\tviewpoint 'system structure perspective' {\t\t\n\t\t\tframe 'system breakdown';\n\t\t}\n\t\t\n\t\tview 'system structure generation' {\n\t\t\tsatisfy 'system structure perspective';\n\t\t\texpose SystemModel::vehicle::**[@SysML::PartUsage];\n\t\t\trender asElementTable {\n\t\t\t\tview :>> columnView[1] {\n\t\t\t\t\trender asTextualNotation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t}\n}"
    },
    {
      "name": "11b-Safety and Security Feature Views",
      "text": "系统应支持定义与安全性和保障特性相关的视图和注释，允许对系统部件进行注解并展示安全性和安全特性的结构。\n\n在**AnnotationDefinitions**包中，定义了与安全性和安全保障相关的元数据。安全性（Safety）注释包括一个属性，指定该部件是否为强制性的。安全保障（Security）注释则没有附带额外的属性。通过这些注释，系统能够标明哪些部件具有安全性或安全保障特性，并提供必要的强制性要求。\n\n在**PartsTree**包中，定义了车辆的不同部件，并通过注释标记哪些部件与安全性和安全保障相关。车内部分包括座椅带、安全气囊和警报系统等，其中座椅带和保险杠是强制性的安全部件，而安全气囊则是可选的。车身部分还包括带有安全注释的防撞条和无钥进入系统等。在车轮总成部分，系统包括带有安全注释的防抱死刹车系统。\n\n在**ViewDefinitions**包中，系统定义了不同的视图，用于展示与安全性和保障特性相关的部件。**SafetyFeatureView**视图用于展示所有与安全性相关的部件，并以树形图的方式呈现。**SafetyOrSecurityFeatureView**视图则展示那些既与安全性也与保障相关的部件。\n\n在**Views**包中，系统为不同的视角定义了具体的视图实现。例如，**vehicleSafetyFeatureView**视图展示所有与安全性相关的部件，**vehicleMandatorySafetyFeatureView**视图进一步筛选出所有强制性的安全性部件。此外，**vehicleMandatorySafetyFeatureViewStandalone**视图独立展示所有强制性的安全部件，并以表格的形式呈现。\n\n整体而言，系统通过注释和视图的组合，帮助用户明确哪些部件涉及安全性和安全保障，并通过不同的展示方式呈现这些部件的信息，从而支持系统的安全性分析和管理。",
      "label": "private import Views::*; // private import library package, not internal Views package!\npackage '11b-Safety and Security Feaure Views' {\n\tprivate import ScalarValues::*;\n\t\n\tpackage AnnotationDefinitions {\t\n\t\tmetadata def Safety {\n\t\t\tattribute isMandatory : Boolean;\n\t\t}\n\t\tmetadata def Security;\n\t}\n\t\n\tpackage PartsTree {\n\t\tpublic import AnnotationDefinitions::*;\n\t\tpart vehicle {\n\t\t\tpart interior {\n\t\t\t\tpart alarm {@Security;}\n\t\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\t\tpart frontSeat[2];\n\t\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t\tpart bodyAssy {\n\t\t\t\tpart body;\n\t\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\t\tpart keylessEntry {@Security;}\n\t\t\t}\n\t\t\tpart wheelAssy {\n\t\t\t\tpart wheel[2];\n\t\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t}\n\t}\n\n\tpackage ViewDefinitions {\t\n\t\tpublic import AnnotationDefinitions::*;\n\t\tview def SafetyFeatureView {\n\t\t\t/* Parts that contribute to safety. */\t\t\n\t\t\tfilter @Safety;\n\t\t\trender asTreeDiagram;\n\t\t}\n\t\t\n\t\tview def SafetyOrSecurityFeatureView {\n\t\t\t/* Parts that contribute to safety OR security. */\t\t \n\t\t\tfilter @Safety | @Security;\n\t\t}\t\n\t}\n\t\n\tpackage Views {\n\t\tprivate import ViewDefinitions::*;\n\t\tprivate import PartsTree::vehicle;\n\t\t\n\t\tview vehicleSafetyFeatureView : SafetyFeatureView {\n\t\t\texpose vehicle::**;\n\t\t}\n\t\t\n\t\tview vehicleMandatorySafetyFeatureView :> vehicleSafetyFeatureView {\n\t\t\tfilter Safety::isMandatory;\n\t\t}\n\t\t\n\t\tview vehicleMandatorySafetyFeatureViewStandalone {\n\t\t\texpose vehicle::**[@Safety and Safety::isMandatory];\n\t\t\trender asElementTable;\n\t\t}\t\n\t}\n\t\n}"
    },
    {
      "name": "12a-Dependency",
      "text": "该系统需求描述了一个分层结构的依赖关系模型，其中包含应用层、服务层和数据层三个层次。应用层依赖于服务层，而服务层又依赖于数据层。此外，定义了属性x、y和z，并设定属性z依赖于属性x和y。该依赖模型表明应用层功能需要通过服务层实现，而服务层依赖于数据层进行数据操作；同时，属性z的值或状态依赖于属性x和y的值或状态。此结构确保各层的分工明确，并定义了层次和属性间的依赖关系。",
      "label": "package '12a-Dependency' {\n\t\n\tpackage 'Application Layer';\n\tpackage 'Service Layer';\n\tpackage 'Data Layer';\n\t\n\tdependency Use from 'Application Layer' to 'Service Layer';\n\tdependency from 'Service Layer' to 'Data Layer';\n\t\n\tattribute x;\n\tattribute y;\n\tattribute z;\n\t\n\tdependency z to x, y;\n\t\n}"
    },
    {
      "name": "12b-Allocation-1",
      "text": "该系统需求描述了一个基于逻辑和物理模型的扭矩生成分配模型。在RequirementModel中，定义了扭矩生成需求torqueGeneration，要求扭矩生成器（TorqueGenerator）能够产生大于0的扭矩。在LogicalModel中，定义了动作GenerateTorque用于输出扭矩，并定义了逻辑部件TorqueGenerator作为LogicalElement的子部件，其中generateTorque作为其执行的动作，表明扭矩生成的逻辑功能。同时，逻辑模型中的torqueGenerator实例满足了torqueGeneration需求。在PhysicalModel中，定义了物理部件PowerTrain，并在powerTrain实例中包含了引擎（engine），该引擎执行providePower动作中的generateTorque逻辑动作。通过分配定义（allocation），LogicalToPhysical的分配规则将逻辑部件torqueGenerator映射到物理部件powerTrain，并进一步将torqueGenerator的generateTorque动作分配到powerTrain引擎中的同名动作。这种分配模型实现了逻辑功能到物理部件的映射，使逻辑扭矩生成功能在物理引擎中得以实现，确保需求能够通过物理系统的执行来满足。",
      "label": "package '12b-Allocation-1' {\n\tprivate import SI::*;\n\tprivate import RequirementModel::*;\n\tprivate import LogicalModel::*;\n\tprivate import PhysicalModel::*;\n\t\n\tpackage RequirementModel {\n\t\trequirement torqueGeneration {\n\t\t\tsubject generator: TorqueGenerator;\n\t\t\trequire constraint { \n\t\t\t\t generator.generateTorque.torque > 0.0 [N*m]\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpackage LogicalModel {\n\t\taction def GenerateTorque { out torque :> ISQ::torque; }\n\t\t\n\t\tpart def LogicalElement;\n\t\tpart def TorqueGenerator :> LogicalElement {\n\t\t\tperform action generateTorque : GenerateTorque;\n\t\t}\t\n\t\t\n\t\taction providePower {\n\t\t\taction generateTorque : GenerateTorque;\n\t\t}\n\t\t\n\t\tpart torqueGenerator : TorqueGenerator {\n\t\t\tperform providePower.generateTorque :>> generateTorque;\n\t\t}\n\t\t\n\t\tsatisfy torqueGeneration by torqueGenerator;\t\t\t\n\t}\n\t\n\tpackage PhysicalModel {\n\t\tpart def PhysicalElement;\n\t\tpart def PowerTrain :> PhysicalElement;\n\t\t\n\t\tpart powerTrain : PowerTrain {\n\t\t\tpart engine {\n\t\t\t\tperform providePower.generateTorque;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tallocation def LogicalToPhysical {\n\t\tend logical : LogicalElement;\n\t\tend physical : PhysicalElement;\n\t}\n\t\n\tallocation torqueGenAlloc : LogicalToPhysical \n\t\tallocate logical ::> torqueGenerator to physical ::> powerTrain {\n\t\t\t\n\t\tallocate torqueGenerator.generateTorque to powerTrain.engine.generateTorque;\t\t\n\t}\n}"
    },
    {
      "name": "12b-Allocation",
      "text": "该系统需求描述了扭矩生成功能的分配模型，通过将逻辑模型中的功能分配到物理模型中的具体部件来实现。在LogicalModel中，定义了providePower动作，其中包含generateTorque子动作，逻辑部件torqueGenerator执行此生成扭矩的功能。在PhysicalModel中，定义了物理部件powerTrain，其中包含一个引擎部件，该引擎同样执行providePower中的generateTorque功能。通过分配（allocation）机制，将逻辑部件torqueGenerator映射到物理部件powerTrain，并进一步将torqueGenerator的generateTorque动作分配到powerTrain的引擎部件中的相同动作。这种分配关系确保逻辑上的扭矩生成功能在物理层面得以实现，从而使系统结构和功能保持一致性。",
      "label": "package '12b-Allocation' {\n\tprivate import LogicalModel::*;\n\tprivate import PhysicalModel::*;\n\t\n\tpackage LogicalModel {\n\t\taction providePower {\n\t\t\taction generateTorque;\n\t\t}\n\t\t\n\t\tpart torqueGenerator {\n\t\t\tperform providePower.generateTorque;\n\t\t}\n\t}\n\t\n\tpackage PhysicalModel {\n\t\tpart powerTrain {\n\t\t\tpart engine {\n\t\t\t\tperform providePower.generateTorque;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tallocate torqueGenerator to powerTrain {\n\t\tallocate torqueGenerator.generateTorque to powerTrain.engine.generateTorque;\n\t}\n}"
    },
    {
      "name": "13a-Model Containment",
      "text": "系统应支持复杂的模型组织结构，并能够管理多个包和模块之间的相互依赖和关系。在该系统中，模型可以按层次结构进行划分，每个层次可以包含特定的配置、子系统和需求定义，以便于对整个系统进行全面的建模和分析。\n\n在**Vehicle Model**包中，系统定义了一个顶层“模型”，该模型没有特定的语法用于标识，但它为整个系统的结构提供了基础。这个包下进一步细分了其他包，如**Vehicle1-Configuration**和**Vehicle Reference Model**，它们用于表示不同的车辆配置和参考模型。**Vehicle1-Configuration**包定义了车辆配置，并为其创建了别名“Sport Sedan”，以便在其他上下文中使用。**Vehicle Reference Model**包则充当模型库的角色，包含了车辆模型和子系统的相关内容。\n\n在**VehicleSubsystems**包中，系统定义了车辆的不同子系统，如车身与内饰（Body&Interior）和动力系统（PowerTrain）。这些子系统在其内部定义了所需的部件和功能，并通过私有导入将具体的实现细节与顶层模型分离。\n\n在**Body&Interior**和**PowerTrain**包中，分别定义了车辆的车身与内饰部件，以及动力系统相关的部件。车身与内饰包引用了车身和内饰的需求定义，而动力系统包则引用了发动机、变速器等部件，并结合动力系统的特定需求。",
      "label": "package '13a-Model Containment' {\n\tprivate import '2a-Parts Interconnection'::*;\n\tprivate import '8-Requirements'::*;\n\t\n\trequirement BodyAndInteriorRequirements {\n\t\tpublic import MassLimitationRequirement; \n\t}\n\t\n\trequirement PowerTrainRequirements;\n\t\n\tpackage 'Vehicle Model' {\n\t\tdoc\n\t\t/*\n\t\t * This package is used to represent a top-level \"model\".\n\t\t * There is no specific syntax for identifying a package\n\t\t * used in this way.\n\t\t */\n\t\n\t\t\n\t\tpackage 'Vehicle1-Configuration' {\t\t\t\n\t\t\talias 'Sport Sedan' for vehicle1_c1;\n\t\t\t\n\t\t\tprivate import 'vehicle1_c1 Specification Context'::'vehicle1-c1 Specification';\t\t\n\t\t}\n\t\t\n\t\tpackage 'Vehicle Reference Model' {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This package is used to represent a \"model library\".\n\t\t\t * There is no specific syntax for identifying a package\n\t\t\t * used in this way.\n\t\t\t */\n\t\t\n\t\t\tprivate import VehicleA;\t\t\t\n\t\t\tprivate import VehicleSubsystems;\n\t\t\t\n\t\t\t//*\n\t\t\t// The following would transitively private import all the\n\t\t\t// members of the VehicleSubsystems package, rather\n\t\t\t// then importing the package itself.\n\t\t\t \n\t\t\t   private import VehicleSubsystems::*;\n\t\t\t*/\n\t\t}\n\t\t\n\t\tpackage VehicleSubsystems {\n\t\t\tprivate import 'Body&Interior';\n\t\t\tprivate import 'PowerTrain';\n\t\t}\n\t\t\n\t\tpackage 'Body&Interior' {\n\t\t\tprivate import BodyAndInteriorRequirements;\t\t\t\n\t\t}\n\t\t\n\t\tpackage PowerTrain {\n\t\t\tprivate import Engine;\n\t\t\tprivate import Transmission;\n\t\t\tprivate import PowerTrainRequirements;\t\t\t\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "13b-Safety and Security Features Element Group-1",
      "text": "系统应支持对车辆安全性和安全保障特性进行详细建模，并能够根据不同需求分类和筛选出相关的部件。通过灵活的注释和过滤机制，系统可以清晰地管理和展示安全性和安全保障的部件。\n\n在**AnnotationDefinitions**包中，定义了与安全性（Safety）和安全保障（Security）相关的元数据。安全性注释包括一个名为“isMandatory”的布尔属性，用于标记该部件是否是强制性的。安全保障注释则不附带额外属性，主要用于标识与安全防护相关的部件。\n\n在**PartsTree**包中，系统定义了车辆的不同部件，并为每个部件添加了相应的注释。车内部分包括报警系统、座椅带、安全气囊等部件，其中座椅带是强制性的安全部件，安全气囊是可选的。车身部分包括车身、保险杠和无钥进入系统等，保险杠被标记为强制性的安全部件。车轮总成部分则包括防抱死刹车系统，这也是一个可选的安全部件。\n\n**Safety Features**包包含所有与安全性相关的部件。系统通过私有导入引用车辆模型中的所有部件，并通过过滤器筛选出那些标注为“Safety”的部件，以便单独展示和分析。\n\n**Security Features**包则包含所有与安全保障相关的部件。系统同样通过私有导入引用车辆模型中的所有部件，并通过过滤器筛选出那些标注为“Security”的部件，专门用于展示和分析车辆的安全防护功能。\n\n**Safety & Security Features**包将所有既与安全性又与安全保障相关的部件集合在一起。通过使用逻辑“or”过滤器，系统能够展示那些具有安全性或安全保障特性的部件，提供一个综合的视角，帮助分析两者的交集部分。\n\n**Mandatory Safety Features**包则专注于展示那些既与安全性相关又是强制性要求的部件。通过使用“and”过滤器，系统能够筛选出那些标注为强制性的安全部件，确保在满足安全标准的同时，能够进行详细的合规性检查。",
      "label": "package '13b-Safety and Security Features Element Group-1' {\n\tprivate import ScalarValues::*;\n\tprivate import AnnotationDefinitions::*;\n\tprivate import PartsTree::*;\n\t\n\tpackage AnnotationDefinitions {\n\t\tmetadata def Safety {\n\t\t\tattribute isMandatory : Boolean;\n\t\t}\n\t\tmetadata def Security;\n\t}\n\t\n\tpackage PartsTree {\n\t\tpart vehicle {\n\t\t\tpart interior {\n\t\t\t\tpart alarm {@Security;}\n\t\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\t\tpart frontSeat[2];\n\t\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t\tpart bodyAssy {\n\t\t\t\tpart body;\n\t\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\t\tpart keylessEntry {@Security;}\n\t\t\t}\n\t\t\tpart wheelAssy {\n\t\t\t\tpart wheel[2];\n\t\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpackage 'Safety Features' {\n\t\t/* Parts that contribute to safety. */\t\t\n\t\tprivate import vehicle::**;\n\t\tfilter @Safety;\n\t}\n\t\n\tpackage 'Security Features' {\n\t\t/* Parts that contribute to security. */\t\t\n\t\tprivate import vehicle::**;\n\t\tfilter @Security;\n\t}\n\t\n\tpackage 'Safety & Security Features' {\n\t\t/* Parts that contribute to safety OR security. */\t\t \n\t\tprivate import vehicle::**;\n\t\tfilter @Safety or @Security;\n\t}\n\t\n\tpackage 'Mandatory Safety Features' {\n\t\t/* Parts that contribute to safety AND are mandatory. */\n\t\tprivate import vehicle::**;\n\t\tfilter @Safety and Safety::isMandatory;\n\t}\n}"
    },
    {
      "name": "13b-Safety and Security Features Element Group-2",
      "text": "系统应支持对车辆的安全性和安全保障特性进行详细建模，并能够通过注释和过滤机制有效地分类和筛选相关部件。\n\n在**AnnotationDefinitions**包中，系统定义了与安全性（Safety）和安全保障（Security）相关的元数据。安全性注释包括一个名为“isMandatory”的布尔属性，用于标记该部件是否为强制性安全部件，而安全保障注释没有额外属性，主要用于标记与防护相关的部件。\n\n在**PartsTree**包中，系统定义了车辆的部件，包括车内部分、车身总成和车轮总成等。车内部分包括报警系统、座椅带、安全气囊等，其中座椅带是强制性的安全部件，安全气囊是可选的。车身部分包括车身、保险杠和无钥进入系统，保险杠是强制性的安全部件。车轮总成部分包括防抱死刹车系统，这是一个可选的安全部件。\n\n**Safety Features**包包含所有与安全性相关的部件。通过私有导入引用车辆模型中的所有部件，并通过过滤器筛选出那些标注为“Safety”的部件，专门展示和分析车辆的安全性功能。\n\n**Security Features**包则包含所有与安全保障相关的部件。系统通过私有导入引用车辆模型中的所有部件，并通过过滤器筛选出那些标注为“Security”的部件，专注于展示和分析车辆的防盗和保障功能。\n\n**Safety & Security Features**包将所有既与安全性又与安全保障相关的部件集合在一起。通过“or”过滤器，系统能够展示那些具有安全性或安全保障特性的部件，提供一个综合视角，帮助分析两者的交集部分。\n\n**Mandatory Safety Features**包专注于展示所有强制性的安全部件。通过“and”过滤器，系统能够筛选出那些既与安全性相关又被标记为强制性的部件，从而确保系统在设计和分析时能够符合安全标准。",
      "label": "package '13b-Safety and Security Features Element Group-2' {\n\tprivate import ScalarValues::*;\n\tprivate import AnnotationDefinitions::*;\n\tprivate import PartsTree::*;\n\t\n\tpackage AnnotationDefinitions {\n\t\tmetadata def Safety {\n\t\t\tattribute isMandatory : Boolean;\n\t\t}\n\t\tmetadata def Security;\n\t}\n\t\n\tpackage PartsTree {\n\t\tpart vehicle {\n\t\t\tpart interior {\n\t\t\t\tpart alarm {@Security;}\n\t\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\t\tpart frontSeat[2];\n\t\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t\tpart bodyAssy {\n\t\t\t\tpart body;\n\t\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\t\tpart keylessEntry {@Security;}\n\t\t\t}\n\t\t\tpart wheelAssy {\n\t\t\t\tpart wheel[2];\n\t\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpackage 'Safety Features' {\n\t\t/* Parts that contribute to safety. */\t\t\n\t\tprivate import vehicle::**[@Safety];\n\t}\n\t\n\tpackage 'Security Features' {\n\t\t/* Parts that contribute to security. */\t\t\n\t\tprivate import vehicle::**[@Security];\n\t}\n\t\n\tpackage 'Safety & Security Features' {\n\t\t/* Parts that contribute to safety OR security. */\t\t \n\t\tprivate import vehicle::**[@Safety or @Security];\n\t}\n\t\n\tpackage 'Mandatory Saftey Features' {\n\t\t/* Parts that contribute to safety AND are mandatory. */\n\t\tprivate import vehicle::**[@Safety and Safety::isMandatory];\n\t}\n}"
    },
    {
      "name": "13b-Safety and Security Features Element Group",
      "text": "系统应支持对车辆的安全性和安全保障特性进行详细建模，并将相关部件按功能分类，以便清晰地定义和管理这些特性。\n\n在**vehicle1_c1**包中，系统定义了车辆的不同部件，其中包括车内和车身总成部分。车内部分包含了座椅带、安全气囊、前座和报警系统等部件，车身总成则包含车身、保险杠和无钥进入系统等部件。\n\n**Safety Features**包专门用于定义和管理那些与安全性相关的部件，系统通过私有导入引用了车辆模型中的座椅带、安全气囊和保险杠等部件。所有这些部件都对提升车辆的安全性起到重要作用。\n\n**Security Features**包则定义了与安全保障相关的部件，系统通过私有导入引用了车辆中的报警系统和无钥进入系统等部件，这些部件有助于增强车辆的安全性和防盗功能。\n\n**Safety & Security Features**包则合并了**Safety Features**和**Security Features**两个包中的所有相关部件，创建一个综合的安全性和安全保障特性集合。这些部件在提升车辆安全的同时，也增强了车辆的防护能力，确保在不同的安全需求下，车辆能够提供全面的保护。",
      "label": "package '13b-Safety and Security Features Element Group' {\n\t\n\tpart vehicle1_c1 {\n\t\tpart interior {\n\t\t\tpart alarm;\n\t\t\tpart seatBelt[2];\n\t\t\tpart frontSeat[2];\n\t\t\tpart driverAirBag;\n\t\t}\n\t\tpart bodyAssy {\n\t\t\tpart body;\n\t\t\tpart bumper;\n\t\t\tpart keylessEntry;\n\t\t}\n\t}\n\t\n\tpackage 'Safety Features' {\n\t\t/* Parts that contribute to safety. */\n\t\t\n\t\tprivate import vehicle1_c1::interior::seatBelt;\n\t\tprivate import vehicle1_c1::interior::driverAirBag;\n\t\tprivate import vehicle1_c1::bodyAssy::bumper;\t\t\n\t}\n\t\n\tpackage 'Security Features' {\n\t\t/* Parts that contribute to security. */\n\t\t\n\t\tprivate import vehicle1_c1::interior::alarm;\n\t\tprivate import vehicle1_c1::bodyAssy::keylessEntry;\n\t}\n\t\n\tpackage 'Safety & Security Features' {\n\t\t/* Parts that contribute to safety AND\n\t\t * parts that contribute to security.\n\t\t */\n\t\t \n\t\tprivate import 'Safety Features'::*;\n\t\tprivate import 'Security Features'::*;\n\t}\n}"
    },
    {
      "name": "14a-Language Extensions",
      "text": "该系统需求描述了一个自定义语言扩展，用于为系统部件添加分类级别的元数据。User Defined Extensions包中定义了枚举ClassificationLevel，包括“未分类”（uncl）、“机密”（conf）和“绝密”（secret）三个级别。同时定义了元数据类型Classified，其中引用了SysML::PartUsage类型的注释元素，并设置了classificationLevel属性以指定分类级别。在此模型中，部件part_X和part_Y均应用了Classified元数据，并将其classificationLevel设置为“机密”（conf）。part_X使用完整的元数据语法，part_Y则采用了简化的@注释符号，两者效果相同。这一语言扩展为系统提供了灵活的分类管理机制，使得可以通过元数据对部件进行安全级别的标注。",
      "label": "package '14a-Language Extensions' {\n\tprivate import 'User Defined Extensions'::*;\n\t\n\tpackage 'User Defined Extensions' {\n\t\t\n\t\tenum def ClassificationLevel {\n\t\t\tuncl;\n\t\t\tconf;\n\t\t\tsecret;\n\t\t}\n\t\t\n\t\tmetadata def Classified {\n\t\t\tref :>> annotatedElement : SysML::PartUsage;\n\t\t\tattribute classificationLevel : ClassificationLevel[1];\n\t\t}\n\t}\n\t\n\tpart part_X {\n\t\tmetadata Classified {\n\t\t\tclassificationLevel = ClassificationLevel::conf;\n\t\t}\n\t}\n\t\n\t// Alternative shorthand notation\n\tpart part_Y {\n\t\t@Classified {\n\t\t\tclassificationLevel = ClassificationLevel::conf;\n\t\t}\n\t}\n\n}"
    },
    {
      "name": "14b-Language Extensions",
      "text": "该系统需求描述了一个带有扩展语言的车辆控制单元（Vehicle Control Unit，VCU）和引擎控制单元（Engine Control Unit，ECU）之间的通信模型，基于总线接口（BusIF）进行连接。在LibraryModel中定义了通用的控制单元ECU，并在UserModel的Definitions包中导入并扩展了ECU，定义了具体的控制单元VehicleControlUnit和EngineControlUnit，以及车辆（Vehicle）、引擎（Engine）和控制总线（CanBus）的部件。此外，定义了总线接口BusIF用于通信。\n\n在Usages包中，实例化了vehicle1车辆系统，其中包含车辆控制单元、引擎和控制总线。在vehicle1中，VehicleControlUnit和EngineControlUnit通过各自的busIF端口连接至CanBus的接口，其中CanBus提供多个端口，包括vehicleControlIF、engineControlIF和sensorIF，以支持不同部件间的通信。具体连接方面，vehicleControlUnit.busIF连接至canBus.vehicleControlIF，而engine.engineControlUnit.busIF则连接至canBus.engineControlIF，实现了车辆控制单元与引擎控制单元通过总线接口进行数据通信的配置。此模型清晰地定义了控制单元间的总线通信结构，确保车辆与引擎的控制单元能够在车辆总线上进行无缝交互。",
      "label": "package '14b-Language-Extensions' {\n\t\n\tpackage LibraryModel {\n\t\t\n\t\tpart def ECU;\n\t\t\n\t}\n\t\n\tpackage UserModel {\n\t\t\n\t\tpackage Definitions {\n\t\t\tprivate import LibraryModel::*;\n\t\t\t\n\t\t\tpart def VehicleControlUnit :> ECU;\n\t\t\tpart def EngineControlUnit :> ECU;\n\t\t\t\n\t\t\tpart def Vehicle;\n\t\t\tpart def Engine;\n\t\t\tpart def CanBus;\n\t\t\t\n\t\t\tport def BusIF;\n\t\t}\n\t\t\n\t\tpackage Usages {\n\t\t\tprivate import Definitions::*;\n\t\t\t\n\t\t\tpart vehicle1: Vehicle {\n\t\t\t\tpart vehicleControlUnit : VehicleControlUnit {\n\t\t\t\t\tport busIF: ~BusIF;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconnect vehicleControlUnit.busIF to canBus.vehicleControlIF;\n\t\t\t\t\n\t\t\t\tpart canBus: CanBus {\n\t\t\t\t\tport vehicleControlIF: BusIF;\n\t\t\t\t\tport engineControlIF: BusIF;\n\t\t\t\t\tport sensorIF: BusIF;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconnect engine.engineControlUnit.busIF to canBus.engineControlIF;\n\t\t\t\t\n\t\t\t\tpart engine: Engine {\n\t\t\t\t\tpart engineControlUnit: EngineControlUnit {\n\t\t\t\t\t\tport busIF: ~BusIF;\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t}\n}"
    },
    {
      "name": "14c-Language Extensions",
      "text": "该系统需求描述了一个基于故障模式和影响分析（FMEA）的模型，建立了多个关联和扩展，涵盖了潜在故障的原因、故障模式、影响和控制措施。首先，在FMEALibrary包中定义了FMEA的核心结构，包括Situation抽象发生事件，以及具体的子事件Cause、FailureMode和Effect，分别用于表示故障原因、故障模式和故障影响。每个事件可以记录具体的发生概率、检测概率和影响严重性。FMEAItem则组合了多种情况，包括原因、故障模式和影响，以形成完整的FMEA项。Causation定义了事件之间的因果关系，而Violation、Prevention和Mitigation则分别描述了FMEA需求的违规、预防和缓解措施。此外，还定义了RequirementWithSIL，包含安全完整性等级（SIL）的属性以支持安全分析。\n\n在FMEAMetadata包中，定义了多种元数据类型来标注FMEA中的各元素，如用于标记事件状态的StatusHolder，以及用于标记不同情况和控制措施的元数据，这些元数据扩展了SysML语言的适用性。FMEAUserModel包具体定义了FMEA应用场景，以Glucose FMEA Item为例，该项定义了“电池耗尽”作为故障原因，其后果可能导致“电池无法充电”，进一步导致“血糖水平检测失败”和“治疗延迟”。在具体的应用中，通过causation连接这些事件，形成因果链，表明故障模式如何逐步影响系统。定义了多个需求，包括req1、req2和req3，其中req3要求当电池电量不足时触发警报，且该需求已批准，符合SIL A等级。此外，定义了“Glucose Meter in Use”作为FMEA实例，包含血糖仪的具体部件（如电池、泵和储液罐）及患者事件（如治疗延迟）。通过violation和mitigation，该需求模型明确了各部件如何遵循或满足需求。整体模型支持对系统潜在故障及其影响的详细分析，提供预防和缓解措施，以提升系统的可靠性和安全性。",
      "label": "package '14c-Language-Extensions' {\n\tprivate import ScalarValues::*;\n\t\n\tlibrary package FMEALibrary {\n\t\t\n\t\tabstract occurrence def Situation;\n\t\t\n\t\tabstract occurrence situations : Situation[*] nonunique;\n\t\t\n\t\toccurrence def Cause :> Situation {\n\t\t\tattribute occurs[0..1]: Real;\n\t\t}\n\t\t\n\t\tabstract occurrence causes : Cause[*] nonunique;\n\t\t\n\t\toccurrence def FailureMode :> Situation {\n\t\t\tattribute detected[0..1]: Real;\n\t\t}\n\t\t\n\t\tabstract occurrence failureModes : FailureMode[*] nonunique;\n\t\t\n\t\toccurrence def Effect :> Situation {\n\t\t\tattribute severity[0..1]: String;\n\t\t}\n\t\t\n\t\tabstract occurrence effects : Effect[*] nonunique;\n\t\t\n\t\titem def FMEAItem :> Situation {\n\t\t\tattribute RPN: Real[0..1];\n\t\t\t\n\t\t\toccurrence :>> causes;\n\t\t\toccurrence :>> failureModes;\n\t\t\toccurrence :>> effects;\n\t\t}\n\t\t\n\t\tabstract item fmeaItems : FMEAItem[*] nonunique;\n\t\t\t\t\n\t\tconnection def Causation :> Occurrences::HappensBefore {\n\t\t\tend cause[*]: Situation;\n\t\t\tend effect[*]: Situation;\n\t\t}\n\t\t\n\t\tabstract connection causations : Causation[*] nonunique;\n\t\t\n\t\trequirement def FMEARequirement;\n\t\t\n\t\tabstract requirement fmeaRequirements : FMEARequirement[*] nonunique;\n\t\t\n\t\trequirement def RequirementWithSIL :> FMEARequirement {\n\t\t\tattribute sil: SIL;\n\t\t}\n\t\t\n\t\tenum def SIL { A; B; C; }\n\t\t\n\t\tconnection def Violation {\n\t\t\tend sit[*]: Situation;\n\t\t\tend req[*]: FMEARequirement;\n\t\t}\n\t\t\n\t\tabstract connection violations : Violation[*] nonunique;\n\t\t\n\t\tabstract connection def ControllingMeasure {\n\t\t\tend sit[*]: Situation;\n\t\t\tend req[*]: FMEARequirement;\n\t\t}\n\t\t\n\t\tconnection def Prevention :> ControllingMeasure;\n\t\t\n\t\tabstract connection preventions : Prevention[*] nonunique;\n\t\t\n\t\tconnection def Mitigation :> ControllingMeasure;\n\t\t\n\t\tabstract connection mitigations : Mitigation[*] nonunique;\n\t\t\n\t}\n\t\n\tlibrary package FMEAMetadata {\n\t\tprivate import Metaobjects::SemanticMetadata;\n\t\tprivate import FMEALibrary::*;\n\n\t\tenum def Status {\n\t\t\tApproved;\n\t\t\tNotApproved;\n\t\t}\n\t\t\n\t\tmetadata def StatusHolder {\n\t\t\tstatus: Status;\n\t\t}\n\t\t\n\t\tmetadata def <situation> SituationMetadata :> SemanticMetadata {\n\t\t\t:>> baseType default situations meta SysML::Usage;\n\t\t}\n\t\t\n\t\tmetadata def <cause> CauseMetadata :> SituationMetadata {\n\t\t\t:>> baseType = causes meta SysML::Usage;\n\t\t}\n\t\t\n\t\tmetadata def <failure> FailureModeMetadata :> SituationMetadata {\n\t\t\t:>> baseType = failureModes meta SysML::Usage;\n\t\t}\n\t\t\n\t\tmetadata def <effect> EffectMetadata :> SituationMetadata {\n\t\t\t:>> baseType = effects meta SysML::Usage;\n\t\t}\n\t\t\n\t\tmetadata def <fmea> FMEAItemMetadata :> SituationMetadata {\n\t\t\t:> annotatedElement : SysML::ItemDefinition;\n\t\t\t:> annotatedElement : SysML::ItemUsage;\n\t\t\t:>> baseType = fmeaItems meta SysML::Usage;\n\t\t}\n\t\t\n\t\tmetadata def <causation> CausationMetadata :> SemanticMetadata {\n\t\t\t:>> annotatedElement : SysML::SuccessionAsUsage;\n\t\t\t:>> baseType = causations meta SysML::Usage;\n\t\t}\n\t\t\n\t\tmetadata def <fmeaspec> FMEARequirementMetadata :> SemanticMetadata {\n\t\t\t:>> annotatedElement : SysML::RequirementUsage;\n\t\t\t:>> baseType = fmeaRequirements meta SysML::Usage;\n\t\t}\n\t\t\n\t\tmetadata def <violation> ViolationMetadata :> SemanticMetadata {\n\t\t\t:>> annotatedElement : SysML::ConnectionUsage;\n\t\t\t:>> baseType = violations meta SysML::Usage;\n\t\t}\n\t\t\n\t\tabstract metadata def ControllingMeasureMetadata :> SemanticMetadata {\n\t\t\t:>> annotatedElement : SysML::ConnectionUsage;\n\t\t}\n\t\t\n\t\tmetadata def <prevention> PreventionMetadata :> ControllingMeasureMetadata {\n\t\t\t:>> baseType = preventions meta SysML::Usage;\n\t\t}\n\t\t\n\t\tmetadata def <mitigation> MitigationMetadata :> ControllingMeasureMetadata {\n\t\t\t:>> baseType = mitigations meta SysML::Usage;\n\t\t}\n\t\t\n\t}\n\t\n\tpackage FMEAUserModel {\n\t\tprivate import FMEALibrary::*;\n\t\tprivate import FMEAMetadata::*;\n\t\t\n\t\t#fmeaspec requirement req1 {\n\t\t\tdoc /* Meter designed according to ISO00124 */\n\t\t}\n\t\t\n\t\t#fmeaspec requirement req2 {\n\t\t\tdoc /* Device working for 1 week without the need to replace batteries */\n\t\t}\n\t\t\n\t\t#fmeaspec requirement req3: RequirementWithSIL {\n\t\t\t@StatusHolder { status = Status::Approved; }\n\t\t\t\n\t\t\tdoc /* Alarm when battery has sank */\n\t\t\t\n\t\t\t:>> sil = SIL::A;\n\t\t}\n\t\t\n\t\t#fmea item def 'Glucose FMEA Item' {\n\n\t\t\t#prevention connect 'battery depleted' to req1;\n\t\t\t\n\t\t\t#cause occurrence 'battery depleted' {\n\t\t\t\t:>> occurs = 0.005;\n\t\t\t}\n\t\t\t\n\t\t\t#causation first 'battery depleted' then 'battery cannot be charged';\n\t\t\t\n\t\t\t#failure occurrence 'battery cannot be charged' {\n\t\t\t\t:>> detected = 0.013;\n\t\t\t}\n\t\t\t\n\t\t\t#causation first 'battery cannot be charged' then 'glucose level undetected';\n\t\t\t\n\t\t\t#effect occurrence 'glucose level undetected';\n\t\t\t\n\t\t\t#causation first 'glucose level undetected' then 'therapy delay';\n\t\t\t\n\t\t\t#effect occurrence 'therapy delay' {\n\t\t\t\t:>> severity = \"High\";\n\t\t\t}\n\n\t\t}\n\t\t\n\t\t#violation connect 'Glucose Meter in Use' to req2;\n\t\t#mitigation connect 'Glucose Meter in Use' to req3;\n\t\t\t\n\t\t#fmea item 'Glucose Meter in Use' : 'Glucose FMEA Item' {\n\t\t\t\n\t\t\tpart 'glucose meter' {\n\t\t\t\tevent 'glucose level undetected'[*];\n\t\t\t\tpart battery {\n\t\t\t\t\tevent 'battery depleted'[*];\n\t\t\t\t\tevent 'battery cannot be charged'[*];\n\t\t\t\t}\n\t\t\t\tpart pump;\n\t\t\t\tpart reservoir;\n\t\t\t}\n\t\t\t\n\t\t\tpart patient {\n\t\t\t\tevent 'therapy delay'[*];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
    },
    {
      "name": "15_01-Constants",
      "text": "该系统需求定义了多个重要的数学常数和物理常数，以及在不同上下文中的一些具体常量值。在“数学常数”部分，定义了常用的无理数常数，包括自然对数底e和圆周率pi，要求这些常数的值精确到小数点后20位。在“基本物理常数”部分，定义了2018 CODATA推荐的基础物理常数，包括精细结构常数7.2973525693E-3、电子与质子质量比5.44617021487E-4，并指定了真空中光速为299792458 m/s，此值为确切值，无不确定性。此外，在“全球上下文”中定义了标准地球重力加速度9.80665 m/s²，而在“Model X上下文”中定义了放大器增益常数3.5。这些常量在系统中作为不可重定义的值，确保在不同应用场景下对常用数学和物理量的准确使用。",
      "label": "package '15_01-Constants' {\n    private import MeasurementReferences::*;\n    private import SI::*;\n    private import RealFunctions::*;\n\n    /* Note: Value properties that are bound to specific values are constants and have the specified\n     * values in all contexts. It is not legal to redefine them.\n     */    \n    \n    package 'Mathematical Constants' {\n\t    doc\n\t    /*\n\t     * Standard mathematical constants\n\t     * \n\t     * Irrational constants cannot be represented exactly with finite precision.\n\t     * However, they can be required to be implemented with a attribute that is accurate\n\t     * to at least a certain precision.\n\t     * \n\t     * (The decimal literals here should be interpreted as being fixed point and exact.)\n\t     */\n    \n        attribute e: Real {\n        \tassert constraint { round(e * 1E20) == 271828182845904523536.0 }\n        }\n        attribute pi: Real {\n        \tassert constraint { round(pi * 1E20) == 314159265358979323846.0 }\n        }\n    }\n\n    package 'Fundamental Physical Constants' {\n\t    doc\n\t    /*\n\t     * Standard fundamental physical constants\n\t     * \n\t     * Physical constants have a standard measured attribute to a finite precision.\n\t     *\n\t     * The reference source is:\n\t     * CODATA - Task Group on Fundamental Physical Constants (TGFC) - 2018 CODATA recommended values\n\t     * See https://codata.org/initiatives/strategic-programme/fundamental-physical-constants/\n\t     * For the actual values see https://pml.nist.gov/cuu/Constants/ \n\t     */\n    \n        attribute 'fine structure constant'      : DimensionOneValue = 7.2973525693E-3[one];  // 2018 CODATA attribute 7.2973525693E-3;  uncertainty = 0.0000000011E-3\n        attribute 'electron to proton mass ratio': DimensionOneValue = 5.44617021487E-4[one]; // 2018 CODATA attribute 5.44617021487E-4; uncertainty = 0.00000000033E-4 \n        attribute 'speed of light in vacuum'     : SpeedValue = 299792458[m/s];               // 2018 CODATA attribute 299792458 m s^-1; (exact)\n     }\n\n    package 'Global Context' {\n        attribute 'nominal earth gravitational acceleration': AccelerationValue = 9.80665['m/s²'];\n    }\n\n    package 'Model X Context' {\n        attribute 'amplifier gain': DimensionOneValue = 3.5[one];\n    }\n}"
    },
    {
      "name": "15_02-Basic Value Properties",
      "text": "该系统需求定义了一个轮胎的基本属性模型，包含轮胎的生产商、轮辋直径和宽度等信息。在模型中，LengthValue用于表示实际应用中的长度值类型。Tire部件定义了轮胎的三个属性：制造商（manufacturer）、轮辋直径（hubDiameter）以及宽度（width），其中制造商为字符串类型，轮辋直径为长度值类型，宽度为整数类型。具体实例frenchTire被定义为Tire的一个实例，其属性值设定为制造商“米其林”（Michelin）、轮辋直径18.0和宽度245。这些属性在不同的应用场景中用于描述轮胎的物理和生产信息。",
      "label": "package '15_02-Basic Value Properties' {\n\tprivate import ScalarValues::*;\n\t\n    attribute def LengthValue :> Real {\n\t\tdoc\n\t\t/*\n\t\t * Real world user models would use a quantity type\n\t\t * from the library model. A attribute def is defined\n\t\t * here to show that it is possible.\n\t\t */\n\t}\n\n    part def Tire {\n    \tattribute manufacturer: String;\n        attribute hubDiameter: LengthValue;\n        attribute width: Integer;\n    }\n    \n    part frenchTire: Tire {\n    \tattribute :>> manufacturer = \"Michelin\";\n    \tattribute :>> hubDiameter = 18.0;\n    \tattribute :>> width = 245;\n    }\n    \n}"
    },
    {
      "name": "15_03-Value Expression",
      "text": "该系统需求描述了一个包含车辆和轮胎尺寸信息的模型，具体包括车辆的质量、长度、轮胎的尺寸和合法的胎面深度要求。Vehicle_1定义了车辆的质量为1200千克，长度为4.82米，包含两个前轮部件：左前轮（leftFrontWheel）和右前轮（rightFrontWheel）。Wheel部件定义了轮毂直径为18英寸，轮胎宽度为245毫米，并通过公式计算外直径（outerDiameter），将其设定为轮毂直径加上两倍的轮胎高度，不需额外标记为“派生”。在轮胎（Tire）部分，胎面深度默认值为6.0毫米，并通过约束条件hasLegalProfileDepth确保胎面深度不小于3.5毫米，轮胎高度设定为45毫米。这些属性和约束定义了车辆与轮胎的物理规格，为系统在不同情境中应用提供了详细的标准和约束。",
      "label": "package '15_03-Value Expression' {\n    private import SI::*;\n    private import USCustomaryUnits::*;\n\n    part def Vehicle_1 {\n        attribute mass: MassValue = 1200 [kg];\n        attribute length: LengthValue = 4.82 [m];\n        part leftFrontWheel : Wheel;\n        part rightFrontWheel : Wheel;\n    }\n\n    part def Wheel {\n    \tattribute hubDiameter: LengthValue = 18 ['in'];\n        attribute width: LengthValue = 245 [mm];\n        attribute outerDiameter: LengthValue = (hubDiameter + 2 * tire.height) [mm] {\n\t        doc\n\t        /*\n\t         * This binds 'outDiameter' to the result of a computed attribute.\n\t         * There is no need to mark it as \"derived\".\n\t         */\n        }\n        part tire: Tire[1];\n    }\n    \n    part def Tire {\n    \tattribute profileDepth: LengthValue default 6.0 [mm];\n        constraint hasLegalProfileDepth {profileDepth >= 3.5 [mm]}\n    \tattribute height: LengthValue = 45 [mm];\n    }\n}"
    },
    {
      "name": "15_04-Logical Expressions",
      "text": "该系统需求描述了一个包含逻辑表达式的车辆模型，用于确定车辆的性能等级和引擎与变速器的配置规则。Vehicle部件定义了一个布尔属性isHighPerformance，用于指示车辆是否为高性能版本。该模型包含两个子部件：引擎（engine）和变速器（transmission）。根据约束条件，如果车辆被标记为高性能（isHighPerformance为真），则要求其引擎类型为6缸引擎（6CylEngine）；否则，要求引擎类型为4缸引擎（4CylEngine）。此外，另一约束条件规定4缸引擎必须与手动变速器（ManualTransmission）匹配，而6缸引擎必须与自动变速器（AutomaticTransmission）匹配，这一约束通过异或逻辑（xor）表达，确保每种引擎配置只与一种指定变速器组合。这些逻辑规则确保车辆的引擎和变速器配置符合高性能或常规性能的设计要求。",
      "label": "package '15_04-Logical Expressions' {\n\tprivate import ScalarValues::*;\n\t\n\tpart def Engine;\n\tpart def '4CylEngine' :> Engine;\n\tpart def '6CylEngine' :> Engine;\n\t\n\tpart def Transmission;\n\tpart def ManualTransmission :> Transmission;\n\tpart def AutomaticTransmission :> Transmission;\n\t\n\tpart def Vehicle {\n\t\tattribute isHighPerformance: Boolean;\n\t\t\n\t\tpart engine: Engine[1];\n\t\tpart transmission: Transmission[1];\n\t\t\n\t\tassert constraint {\n\t\t\tif isHighPerformance? engine istype '6CylEngine'\n\t\t\telse engine istype '4CylEngine'\n\t\t}\n\t\t\n\t\tassert constraint {\n\t\t\t(engine istype '4CylEngine' and \n\t\t\t transmission istype ManualTransmission) xor\n\t\t\t(engine istype '6CylEngine' and\n\t\t\t transmission istype AutomaticTransmission)\n\t\t}\n\t}\n}"
    },
    {
      "name": "15_05-Unification of Expression and Constraint Definition",
      "text": "该系统需求描述了用于验证车辆制动组件与轮胎适配性的多个约束条件，确保制动盘的尺寸适合轮胎的外径。首先，定义了DiscBrakeConstraint，要求所有WheelAssy组件中的制动盘组件半径的两倍必须小于轮胎的外径。这一约束通过forAll语句对每个轮胎组件进行验证，未在模型中强制，但工具会在检测到违反约束时发出提示。\n\n此外，定义了另一项约束DiscBrakeFitConstraint_Alt，用于在单一DiscBrakeAssy和Wheel实例中验证该尺寸适配关系，确保制动盘组件的两倍半径小于对应轮胎的外径。此约束在模型中被强制，任何违反此条件的情况会导致模型不一致。\n\n具体到Vehicle_2实例，质量为1200千克，长度为4.82米，包含四个WheelAssy部件。Vehicle_2中应用了DiscBrakeConstraint，将其设定为“计算但不强制”约束，允许在检测到约束违反时发出警告而不影响模型的一致性。\n\n在WheelAssy定义中，包含一个Wheel和一个DiscBrakeAssy，并应用了DiscBrakeFitConstraint_Alt，将其设定为强制约束，以确保制动盘的两倍半径小于轮胎外径。DiscBrakeAssy组件定义了制动盘半径为95毫米，满足该尺寸条件。这一系列约束定义和应用确保车辆的制动组件符合设计的适配性要求。",
      "label": "package '15_05-Unification of Expression and Constraint Definition' {\n\tprivate import '15_03-Value Expression'::*;\n\tprivate import ControlFunctions::forAll;\n\tprivate import SI::*;\n\t\n\tconstraint def DiscBrakeConstraint {\n\t\tin wheelAssy : WheelAssy[4];\n\t\t\n\t\twheelAssy->forAll {in ref w: WheelAssy; \n\t\t\t2 * w.discBrakeAssy.radius < w.wheel.outerDiameter\n\t\t}\n\t}\n\t\n\tconstraint def DiscBrakeFitConstraint_Alt {\n\t\tin discBrakeAssy : DiscBrakeAssy[1];\n\t\tin wheel : Wheel[1];\t\n\t\t\t\n\t\t2 * discBrakeAssy.radius < wheel.outerDiameter\n\t}\n\t\n\tpart def Vehicle_2 {\n\t\tattribute mass : MassValue[1] = 1200 [kg];\n\t\tattribute length : LengthValue[1] = 4.82 [m];\n\t\t\n\t\tpart wheelAssy : WheelAssy[4];\n\t\t\n\t\tconstraint discBrakeConstraint : DiscBrakeConstraint {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This constraint is computed, but not asserted. This means a tool can identify \n\t\t\t * when it is violated without the model being inconsistent.\n\t\t\t */\n\t\t\tin wheelAssy = Vehicle_2::wheelAssy;\n\t\t}\n\t}\n\t\n\tpart def WheelAssy {\n\t\tpart wheel : Wheel[1];\n\t\tpart discBrakeAssy : DiscBrakeAssy[1];\n\t\t\n\t\tassert constraint discBrakeFitConstraint_Alt: DiscBrakeFitConstraint_Alt {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This constraint is asserted to be true, which means that the model\n\t\t\t * is inconsistent if it the constraint is violated.\n\t\t\t */\n\t\t\n\t\t\tin discBrakeAssy = WheelAssy::discBrakeAssy;\n\t\t\tin wheel = WheelAssy::wheel;\n\t\t}\n\t}\n\t\n\tpart def DiscBrakeAssy {\n\t\tattribute radius : LengthValue[1] = 95 [mm];\n\t}\n}"
    },
    {
      "name": "15_06-System of Quantities",
      "text": "系统应支持量纲系统的定义和管理，遵循国际数量系统（ISQ）的结构。每个量纲系统应由一组基础量的幂的乘积表示。基础量应作为简单单位的特殊化表示，定义基础单位向量，并为该系统建立基础量的维度。基础单位的选择并不直接涉及具体的测量单位。\n\n系统还应支持通过添加派生量来完善量纲系统。每个派生量应作为派生单位的特殊化表示，并通过单位幂因子的组合来定义。单位幂因子是基础量（或其他派生量）与指数的组合，用于描述派生量的量纲。例如，加速度单位可以通过长度单位（L）和时间单位（T）的组合来定义，量纲为L¹⋅T⁻²。\n\n系统应支持定义具有维度为1的量，这类量的所有基础量的幂因子的有效指数为零。维度为1的量也可以通过正负指数的组合来定义，以区分不同类型的无量纲量，如角度、质量比、功率比、马赫数等。\n\n该系统应能够管理这些量纲定义，并支持在需要时使用其他自定义的量纲系统。",
      "label": "package '15_06-System of Quantities' {\n    private import ISQ::*;\n\n\t/*\n\t * A System of Quantities is represented by a model library package.\n\t * \n\t * Its structure is modeled after the International System of Quantities (ISQ):\n\t * - Quantity dimension is defined as the product of powers of a selected set of base quantities.\n\t * - A system of quantities is multi-dimensional space spanned by the powers of its base quantities.\n\t * - Any base quantity is modeled as a specialization of a SimpleUnit. Such a specialized SimpleUnit defines one base unit vector \n\t *   (with power one by definition), e.g. MassUnit with symbol M, that establishes a base quantity dimension for the system of quantities, \n\t *\t without committing yet to a particular choice of measurement unit.\n\t * - To complete the system of quantities any number of derived quantities can be added.\n\t * - A derived quantity is modeled as a specialization of a DerivedUnit. A DerivedUnit is defined in terms of so-called UnitPowerFactors. \n\t *   Each UnitPowerFactor is a combination of a base (or other derived) quantity and an exponent.\n\t * - As an example the AccelerationUnit (specialization of DerivedUnit) can be defined as the combination of LengthUnit (symbol L) \n\t *   to the power 1 and TimeUnit (symbol T) to the power -2, so having quantity dimension L¹⋅T⁻².\n\t * - A quantity of dimension one is defined as a derived quantity for which the effective exponent for each \n\t *   of its base quantity power factors is zero. Historically a quantity of dimension one was also called a dimensionless quantity.\n\t * - A quantity of dimension one may be defined by adding all quantity power factors that cancel out by having positive and negative \n\t *   exponents. Doing so enables distinction between different 'kinds of' quantities of dimension one, e.g:\n\t *   angle (L¹⋅L⁻¹), mass ratio (L¹⋅L⁻¹), power ratio (L²⋅M⋅T⁻³⋅L⁻²⋅M⁻¹⋅T³), Mach number (L¹⋅T⁻¹⋅L⁻¹⋅T¹).\n\t * \n\t * The International System of Quantities (ISQ) as defined in ISO/IEC 80000 is added as a predefined model library to SysML v2.\n\t * However, this does not prevent to model any other system of quantities in another model library and use it.\n\t */\n\t \n\t /*\n\t  * Above capabilities were implemented in:\n      * - standard library Quantities:\n      *   TensorQuantityValue, VectorQuantityValue, ScalarQuantityValue,\n      *   tensorQuantities, vectorQuantities, scalarQuantities, \n      *   SystemOfQuantities\n\t  * - standard library MeasurementReferences:\n\t  *   TensorMeasurementReference, VectorMeasurementReference, ScalarMeasurementReference,\n      *   SystemOfUnits\n\t  * - standard library ISQBase:\n\t  *   attribute <isq> 'International System of Quantities': SystemOfQuantities in ISQBase\n\t  */\n}"
    },
    {
      "name": "15_07-System of Units and Scales",
      "text": "系统应支持单位和量表的定义与管理，遵循国际单位制（SI）的结构，作为ISO/IEC 80000中定义的标准。每个测量单位和量表应被统一建模为一个测量引用的超类。具体的量应表示为数值和相应测量单位的元组。\n\n实际的测量单位应作为简单单位或派生单位的特殊化表示，例如时间单位或力单位。实际单位的量纲必须与其所使用的通用单位定义的量纲匹配。\n\n单位系统必须为与其相关的量纲系统中的每个基础量定义一个选定的基础单位。基础单位的集合为在兼容单位和/或量表之间进行自动量值转换提供基础。系统应能够处理不同单位之间的转换因素，无论是通过公约（例如米与英寸之间的转换）还是通过ISO/IEC 80000前缀符号（如千、纳、兆、千比、兆比等）来表示十进制或二进制的倍数或子倍数。\n\n此外，除了测量单位和比率量表外，系统还应支持其他类型的测量量表，包括：序数量表（如博福特风力等级、里氏震级、洛克韦尔C硬度）、区间量表（如绝对温度）、循环比率量表（如旋转角度，模数360度）和对数量表（如dB(A)或dBA声压级）。\n\n该系统应能够管理这些单位和量表定义，并支持根据需要使用其他自定义的单位和量表系统。",
      "label": "package '15_07-System of Units and Scales' {\n    private import ISQ::*;\n    private import USCustomaryUnits::*;\n\n\t/*\n\t * A System of Units and Scales is represented by a model library package.\n\t * \n\t * Its structure is modeled after the International System of Units -- Système Internationale d'Unités, abbreviated to SI -- as defined in ISO/IEC 80000:\n\t * - Measurement units and scales are generalized to a common super type MeasurementReference.\n\t * - A particular quantity is modeled as the tuple of a numerical value (i.e. a mathematical number) and a MeasurementReference.\n\t * - An actual measurement unit is modeled as a usage of a specialization of either SimpleUnit or DerivedUnit, e.g. TimeUnit or ForceUnit,\n\t *   see the SI package.\n\t * - The quantity dimension of the actual unit usage must match the quantity dimension of the generic quantity unit definition that it is a usage of.\n\t * - A system of units and scales must define exactly one selected base unit for each base quantity in the associated system of quantities. The collection of \n\t *   base units forms the foundation for automated quantity value conversion between any pair of compatible units and/or scales.\n\t * - If only a measurement unit is used on a quantity value, it implies expression on a ratio scale, in other words only the ratio between the actual quantity value,\n\t *   and the defined unit value is of importance. On ratio scales for one kind of quantity that only differ in their unit (e.g. metre and inch) \n\t *   zero is zero no matter what unit is selected.\n\t * - A unit may carry a conversion factor definition w.r.t. to another reference unit. It can be a conversion by convention (e.g. between metre and foot) or \n\t *   via an ISO/IEC 80000 prefix symbol that indicates a decimal or binary multiple or sub-multiple (e.g. kilo, nano, mega, kibi, mebi, ...). See package SIPrefixes. \n\t * - In addition to measurement units / ratio scales also other types of measurement scales are supported. The additional scales are:\n\t *   - ordinal scales (e.g. Beaufort wind force, Richter Scale, Rockwell C hardness scale), \n\t *   - interval scales (e.g. absolute temperature in deg C or F), \n\t *   - cyclic ratio scales (e.g. rotation angle with modulus 360 degree), \n\t *   - logarithmic scales (e.g. dB(A) or dBA sound pressure level w.r.t. a reference ambient pressure, dB(m) or dBm power ratio w.r.t. 1 mW).\n\t * - Any base unit quantity is modeled as a specialization of a SimpleUnit. This specialized SimpleUnit (e.g. MassUnit) defines one base unit vector (with power one by definition)\n\t *   that establishes a base quantity dimension for the system of quantities, without committing yet to a particular choice of measurement unit.\n\t * \n\t * The International System of Units (SI) as defined in ISO/IEC 80000 as well as the US Customary System of Units as defined by NIST SP 811\n\t * are added as predefined model libraries to SysML v2.\n\t * However, this does not prevent to model any other system of units and scales in another model library and use it.\n\t */\n\t \n\t /*\n\t  * Above capabilities were implemented in:\n\t  * - standard library MeasurementReferences:\n      *   TensorMeasurementReference, VectorMeasurementReference, ScalarMeasurementReference,\n      *   MeasurementUnit, OrdinalScale, IntervalScale, CyclicRatioScale, LogarithmicScale, \n      *   SystemOfUnits\n\t  * - standard library SI:\n\t  *   attribute <si> 'ISO/IEC 80000 International System of Units' : SystemOfUnits\n      *     :>> systemOfQuantities = isq;\n      *     :>> baseUnits = (m, kg, s, A, K, mol, cd);\n      *   }\n\t  */\n}"
    },
    {
      "name": "15_08-Range Restriction",
      "text": "该系统需求描述了一个用于车灯倾斜角度控制的限制模型，确保车灯的倾斜角度在指定范围内。HeadLightsTiltKnob部件定义了一个属性headLightsTile，用于控制车灯的倾斜角度，其类型为LightBeamTiltAngleValue。该属性类型限制了车灯倾斜角度必须在50至80度之间（包括边界值），通过约束条件angle >= 50° and angle <= 80°强制执行，确保车灯角度始终在允许的范围内。此需求模型确保了车灯的倾斜调节符合安全和设计的标准，不会超出预设的角度范围。",
      "label": "package '15_08-Range Restriction' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import '15_01-Constants'::'Mathematical Constants'::pi;\n\t\n\tpart def HeadLightsTiltKnob {\n\t\tattribute headLightsTile : LightBeamTiltAngleValue[1];\n\t}\n\t\n\tattribute def LightBeamTiltAngleValue :> PlaneAngleValue {\n\t\tattribute angle: LightBeamTiltAngleValue :>> self {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * Tilt angle shall be limited to the range between 50 and 80 degrees (inclusive).\n\t\t\t */\n\t\t}\n\t\tassert constraint { angle >= 50 ['°'] and angle <= 80 ['°'] }\n\t}\n}"
    },
    {
      "name": "15_10-Primitive Data Types",
      "text": "系统应定义多个基本数据类型，包括整数、实数、字符串、布尔值和日期时间，以支持不同类型的数据建模。系统中的整数类型应为带符号类型，而无符号整数则应定义为自然数类型。实数类型同样为带符号的，且可以进一步定义为无符号实数类型，确保数值大于等于零。\n\n系统应提供字符串类型，用于表示字符序列，以及布尔类型，支持两个合法值：`true` 和 `false`。此外，日期时间类型应被引入，以便表示具体的时间点。\n\n系统还应定义枚举类型 `ConditionColor`，用于表示不同的条件颜色，涵盖红色、黄色和绿色三种状态，这些颜色可用于指示不同的状态级别。基于这个枚举类型，系统应进一步定义 `SeverityEnum`，表示三种不同的严重性等级：危险、警告和正常，并通过颜色来反映其对应的状态。\n\n系统应允许对物理量如直径进行建模，支持不同的尺寸选择，如小、中、大三种选项，且每种选项应带有合适的单位（例如毫米）。此外，系统应能够设置默认值，确保能够精确表示并管理不同的尺寸选择。\n\n通过这些基本数据类型和枚举类型，系统能够支持更复杂的建模需求，并且能够确保数据的准确性和一致性。",
      "label": "package '15.10-Primitive Data Types' {\n\t/*\n\t * Primitive data types are defined in normative model libraries.\n\t * Any more specialized data types can be declared in user-defined \n\t * model libraries or models as needed.\n\t */\n\t \n\tprivate import ScalarValues::Integer {\n\tdoc\n\t/*\n\t * The unqualified Integer is signed, in line with integer numbers in mathematics.\n\t */\n\t}\n\t\n\tprivate import ScalarValues::Natural;\n\tattribute def UnsignedInteger :> Natural {\n\t\tdoc /* Mathematically, unsigned integers are just natural numbers (non-negative integers). */\t\t\n\t}\n\t\n\tprivate import ScalarValues::Real {\n\tdoc\n\t/*\n\t * The unqualified Real is signed, in line with real numbers in mathematics.\n\t */\n\t}\n\t\n\tattribute def UnsignedReal :> Real {\n\t\tdoc\n\t\t/*\n\t\t * Example of restriction of the base Real datatype.\n\t\t */\n\t\tattribute x: Real :>> self;\n\t\tassert constraint { x >= 0.0 }\n\t}\n\t\n\tprivate import ScalarValues::String {\n\t\tdoc\n\t\t/*\n\t\t * String attributes are sequences of characters.\n\t\t */\n\t}\n\t\n\tprivate import ScalarValues::Boolean {\n\t\tdoc\n\t\t/*\n\t\t * Boolean type has two legal attributes: true, false.\n\t\t */\n\t}\n\t\n\tprivate import Time::DateTime;\n\t\n\tenum def ConditionColor {\n\t\tdoc\n\t\t/*\n\t\t * Enumerations are defined as an implicit restriction of the extent of the\n\t\t * enumeration type to the listed enumeration values.\n\t\t * Note: Enumerations are currently limited to attributes.\n\t\t */\n\t\n\t\tenum red;\n\t\tenum yellow;\n\t\tenum green;\n\t}\n\t\n\tattribute def ConditionLevel {\n\t\tattribute associatedColor : ConditionColor;\n\t}\n\t\n\tenum def SeverityEnum :> ConditionLevel {\n\t\tdanger { \n\t\t\t:>> associatedColor = ConditionColor::red;\n\t\t}\n\t\twarning { \n\t\t\t:>> associatedColor = ConditionColor::yellow;\n\t\t}\n\t\tnormal { \n\t\t\t:>> associatedColor = ConditionColor::green;\n\t\t}\n\t}\n\t\n\tattribute def Diameter :> ISQ::LengthValue;\t\n\tenum def DiameterChoice :> Diameter {\n\t\tsmall = 60 [SI::mm];\n\t\tmedium = 70 [SI::mm];\n\t\tlarge = 80 [SI::mm];\n\t}\t\n\tattribute aperatureDiameter: DiameterChoice = DiameterChoice::small;\n\t\n}"
    },
    {
      "name": "15_11-Variable Length Collection Types",
      "text": "系统应能够处理多种不同类型的集合，支持对元素的动态管理和组织。系统中应包括对不同集合类型的支持，如袋（Bag）、列表（List）、集合（Set）和有序集合（OrderedSet）。每种集合类型应能够存储指定类型的元素，例如，袋应能够存储备件对象，列表可以存储整数值，集合可存储字符串元素，有序集合则应存储人员对象。\n\n此外，系统还应支持更复杂的集合结构，如列表中包含集合的结构，这允许嵌套的数据组织形式。例如，一个列表可以包含多个集合，每个集合中存储人员对象。\n\n系统还应支持固定长度的数组，例如，定义一个包含四个实数元素的数组，确保能够在系统中以固定的维度和大小进行数据存储和操作。\n\n这些集合类型将帮助系统更加灵活地组织和管理各种数据，适应不同的需求并提升数据处理的效率和可扩展性。",
      "label": "package '15_11-Variable Length Collection Types' {\n\tprivate import ScalarValues::*;\n\tprivate import Collections::*;\n\t\n\tpart def SparePart;\n\tpart def Person;\n\t\n\t/* Examples of declaring syntactic sugar-like names for instantiating collection types. */\n\t\n\tattribute def 'Bag<SparePart>' :> Bag {\n\t\tref part :>> elements: SparePart;\n\t}\n\t\n\tattribute def 'List<Integer>' :> List {\n\t\tvalue :>> elements: Integer;\n\t}\n\t\n\tattribute def 'Set<String>' :> Set {\n\t\tattribute :>> elements: String;\n\t}\n\t\n\tattribute def 'OrderedSet<Person>' :> OrderedSet {\n\t\tref part :>> elements: Person;\n\t}\n\t\n\tattribute def 'List<Set<Person>>' :> List {\n\t\tattribute :>> elements: Set {\n\t\t\tref part :>> elements: Person;\n\t\t}\n\t}\n\t\n\tattribute def 'Array<Real>[4]' :> Array {\n\t\tattribute :>> elements: Real;\n\t\tattribute :>> dimensions = 4;\n\t}\n}"
    },
    {
      "name": "15_12-Compound Value Type",
      "text": "系统应能够处理复杂的复合值类型，以满足不同类型的数据需求。系统中应支持定义多个具有多个属性的复合类型，如位置向量、长度值和轮胎信息。位置向量应包括三个实数值，分别表示x、y和z坐标，能够准确描述空间中的位置。长度值应作为实数值的扩展，用于表示物理长度的量。\n\n系统还应定义一个轮胎信息类型，该类型应包含制造商名称、轮毂直径、宽度和位置等属性。轮胎的制造商应为字符串类型，轮毂直径应使用长度值类型表示，而宽度应为整数类型。轮胎的位置应为一个位置向量，可以表示轮胎在不同位置上的放置情况。\n\n系统应支持通过具体值定义特定轮胎的属性，例如，定义一个法国品牌的轮胎，其制造商为“Michelin”，轮毂直径为18英寸，宽度为245，位置可以为空或包含一个位置向量。这些复合值类型能够帮助系统管理和处理更多复杂的数据结构，确保数据在多个维度上的准确表达和灵活应用。",
      "label": "package '15_12-Compound Value Type' {\n\tprivate import ScalarValues::*;\n\tprivate import USCustomaryUnits::'in';\n\t\n\t/*\n\t * Real world user models would use quantity and vector types\n\t * from library models. They are included here for the purpose\n\t * of showing how such attribute defs can be defined.\n\t */\n\n    attribute def PositionVector {\n        attribute x: Real[1];\n        attribute y: Real[1];\n        attribute z: Real[1];\n    }\n    \n    attribute def LengthValue :> Real;\n\n    attribute def TireInfo {\n    \tattribute manufacturer: String;\n        attribute hubDiameter: LengthValue;\n        attribute width: Integer;\n        attribute placement: PositionVector[0..1];\n    }\n    \n    attribute frenchTireInfo: TireInfo {\n    \tattribute :>> manufacturer = \"Michelin\";\n    \tattribute :>> hubDiameter = 18.0['in'];\n    \tattribute :>> width = 245;\n    }\n}"
    },
    {
      "name": "15_13-Discretely Sampled Function Value",
      "text": "系统应能够定义并处理任务经过时间的度量标准，以确保任务的时间管理与相关操作同步。任务经过时间应以一个时间尺度表示，起始点从任务开始时刻定义，并且能够以UTC时间转换为参考时间。系统应能够支持不同时间单位的转换，并以秒为单位定义时间刻度。\n\n系统还应能够支持任务经过时间的值作为标量量值，确保能够表示任务进行中的每个时刻的时间，并与任务经过时间的度量标准进行关联。任务的空间坐标系应能够定义为三维笛卡尔坐标系，并且该坐标系应支持通过除以秒来转换为速度坐标系，从而实现对位置和速度的精确描述。\n\n此外，系统应能够定义一个包含位置和速度的类型，用于描述任务过程中的每个时间点的空间状态。系统应能够通过抽样函数来定义任务的上升过程，包括在不同任务经过时间点的空间状态和速度。任务上升的每个采样点应包含任务经过时间和对应的空间位置与速度。\n\n系统应能够支持记录任务上升过程中的多个采样点，并能够对这些采样点进行排序，确保在任务时间过程中各个点的信息被准确记录和处理。通过这种方式，系统可以有效地跟踪和管理任务过程中位置、速度和时间的变化，以支持更复杂的任务规划和分析。",
      "label": "package '15_13-Discretely Sampled Function Value' {\n\tprivate import SampledFunctions::SampledFunction;\n\tprivate import SampledFunctions::SamplePair;\n\tprivate import Collections::Array;\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import MeasurementReferences::*;\n\tprivate import Time::*;\n\n\tattribute def MissionElapsedTimeScale :> TimeScale {\n\t\t:>> unit = s;\n\t\tattribute :>> definitionalEpoch {\n\t\t\t:>> num = 0;\n\t\t\t:>> definition = \"time instant zero at launch\";\n\t\t}\n\t\tattribute definitionalEpochInUTC : Iso8601DateTime;\n\t\t\n\t\t// Map the definitional epoch (t = 0) of this scale to a reference epoch expressed in UTC\n\t\t// This modeled as a 1D coordinate transformation (translation only)\n\t\tattribute :>> transformation : CoordinateFramePlacement {\n\t\t\t:>> source = UTC;\n\t\t\t:>> origin = definitionalEpochInUTC;\n\t\t\t:>> basisDirections = 1 [UTC];\n\t\t}\n  }\n\n\tattribute mets: MissionElapsedTimeScale { \n\t\tdoc\n\t\t/*\n\t\t * Define mission elapsed time scale starting at given UTC date time (in microsecond resolution)\n\t\t */\n\t\t:>> definitionalEpochInUTC { :>> val = \"2020-08-23T22:42:32.924534Z\";}\t\t\n\t}\n\n\tattribute def MissionElapsedTimeValue :> TimeInstantValue {\n\t\tdoc\n\t\t/*\n\t\t * Define scalar quantity value type for mission elapsed time\n\t\t */\n\t \t:>> mRef = mets; \n\t}\n\n\tattribute spatialCF: CartesianSpatial3dCoordinateFrame[1] {\n\t\tdoc\n\t\t/*\n\t\t * Define Cartesian 3D coordinate systems for position and velocity\n\t\t * Create a velocity coordinate system from the spatial coordinate system through division by second\n\t\t */\n\t   :>> mRefs = (m, m, m);\n\t}\n\tattribute velocityCF: CartesianVelocity3dCoordinateFrame[1] = spatialCF/s;\n\n\tattribute def PositionAndVelocity {\n\t\tattribute position : CartesianPosition3dVector[1];\n\t\tattribute velocity : CartesianVelocity3dVector[1];\n\t}\n\n\tattribute def AscentProfile :> SampledFunction {\n\t\tattribute def AscentSample :> SamplePair {\n\t\t\tattribute :>> domainValue: MissionElapsedTimeValue[1];\n\t\t\tattribute :>> rangeValue: PositionAndVelocity[1];\n\t\t}\n\t\tattribute :>> samples: AscentSample[*] ordered;\n\t}\n\n\tattribute ascentProfile1: AscentProfile {\n\t\tdoc /* Example ascent profile */\n\t\tattribute sample1: AscentSample { :>> domainValue = 0.0 [mets]; :>> rangeValue = pv1;\n\t\t\tattribute pv1: PositionAndVelocity {:>> position = (0, 0, 0) [spatialCF]; :>> velocity = (0, 0, 0) [velocityCF]; } }\n\t\tattribute sample2: AscentSample { :>> domainValue = 2.5 [mets]; :>> rangeValue = pv1;\n\t\t\tattribute pv1: PositionAndVelocity {:>> position = (0.01, 0.03, 8.6) [spatialCF]; :>> velocity = (0, 0, 5.5) [velocityCF]; } }\n\t\tattribute sample3: AscentSample { :>> domainValue = 5.1 [mets]; :>> rangeValue = pv1;\n\t\t\tattribute pv1: PositionAndVelocity {:>> position = (0.04, 0.12, 18.6) [spatialCF]; :>> velocity = (0.05, 0.03, 25.3) [velocityCF]; } }\n\t\tattribute :>> samples = (sample1, sample2, sample3);\n\t}\n}"
    },
    {
      "name": "15_19-Materials with Properties",
      "text": "系统应能够定义和管理不同类型的材料，支持为每种材料指定特定的物理属性。每种材料应包括其质量属性，并允许通过具体的单位和量纲来描述其强度特性。系统应能够管理物质的分类，支持金属和合金等基本类型，并能够进一步细分为具体的元素成分和它们的质量分数。\n\n金属类应包含每个元素的原子质量属性，如铁、碳和锰等常见金属。系统还应支持合金的定义，允许通过成分的质量分数来组合不同的金属材料。合金如钢应能定义多个成分以及它们在合金中的比例。钢的属性应包括特定的拉伸强度值，并通过单位“牛顿每平方毫米”进行表示，系统应能够精确地管理和表示这些物理属性。",
      "label": "package '15_19-Materials with Properties' {\n\tprivate import ScalarValues::Real;\n\tprivate import Quantities::*;\n\tprivate import MeasurementReferences::*;\n\tprivate import SI::*;\n\t\n    attribute def AtomicMassValue :> MassValue;\n    \n\tattribute def TensileStrengthUnit :> DerivedUnit {\n        private attribute lengthPF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = -1; }\n        private attribute massPF: QuantityPowerFactor[1] { :>> quantity = isq.M; :>> exponent = 1; }\n        private attribute durationPF: QuantityPowerFactor[1] { :>> quantity = isq.T; :>> exponent = -2; }\n        attribute :>> quantityDimension { :>> quantityPowerFactors = (lengthPF, massPF, durationPF); }\t\t\n\t}\n    \n    attribute def TensileStrengthValue :> ScalarQuantityValue {\n\t\tattribute :>> num: Real;\n    \tattribute :>> mRef: TensileStrengthUnit;\n    }\n    \n    attribute <'N/mm²'> 'newton per square millimetre' : TensileStrengthUnit = N / mm^2;\n\n    part def Substance;\n    part def Material :> Substance;\n\n\t/*\n\t * The classification of materials into metals and alloys is grossly simplified and not exhaustive.\n\t * A more complete classification would include: ChemicalSubstance, PureMaterial, MixedMaterial,\n\t * Class, Ceramic, OrganicMaterial, AnorganicMaterial, Polymer, HybridMaterial, CompositeMaterial,\n\t * etc.\n\t */\n\n    part def Metal :> Material {\n        attribute atomicMass: AtomicMassValue[1];\n    }\n\n    attribute def MaterialFraction {\n        ref material: Material[1]; \n        attribute massFraction: MassFractionValue[1];\n    }\n\n    attribute def MassFractionValue :> DimensionOneValue;    \n\n    part def Alloy :> Material {\n        attribute fractions: MaterialFraction[2..*];\n    }\n\n    individual def Iron :> Metal {\n        attribute :>> atomicMass = 55.845 [Da];\n    }\n\n    individual def Carbon :> Metal {\n        attribute atomicMass :>> Metal::atomicMass = 12.011[Da];\n    }\n\n    individual def Manganese :> Metal {\n        attribute atomicMass :>> Metal::atomicMass = 54.938[Da];\n    }\n\n    individual def Steel_980 :> Alloy {\n\t \t/*\n\t\t * Particular example of high tensile strength steel.\n\t\t */\n \t\n        attribute fraction1 :> fractions {\n        \tref :>> material : Iron;\n        \tattribute :>> massFraction = 0.9862[one];\n        }\n        \n        attribute fraction2 :> fractions {\n        \tref :>> material : Carbon;\n        \tattribute :>> massFraction = 0.9862[one];\n        }\n        \n        attribute fraction3 :> fractions {\n        \tref :>> material : Manganese;\n        \tattribute :>> massFraction = 0.9862[one];\n        }\n        \n        attribute tensileStrength: TensileStrengthValue = 980['N/mm²'];\n    }\n}"
    },
    {
      "name": "15_19a-Materials with Properties",
      "text": "系统应能够定义和管理不同类型的材料，并能够对其进行分类和属性分配。每种材料应具备质量和物理属性，例如原子质量和拉伸强度等。材料的定义应支持包括金属、合金等类型，并能够进一步细分为不同的子类型，例如铁、碳和锰等金属，或钢等合金。每种金属应具备原子质量属性，合金则应包含多个材料成分及其相应的质量分数。\n\n系统还应支持对拉伸强度的度量，拉伸强度应包含一个具体的单位，单位应为牛顿每平方毫米。合金如钢应具体定义其成分和成分比例，支持通过特定的质量分数对各组成部分进行表示。系统应能够管理这些材料的复合属性，确保它们的质量、成分和力学性质等能够准确描述和反映实际材料的特性。",
      "label": "package '15_19a-Materials with Properties' {\n\tprivate import ScalarValues::*;\n\tprivate import Quantities::*;\n\tprivate import MeasurementReferences::*;\n\tprivate import SI::*;\n\t\n    attribute def AtomicMassValue :> MassValue;\n    \n\t/* Example declarations of a quantity and unit that are not specified in ISQ and SI */\n\n\tattribute def TensileStrengthUnit :> DerivedUnit {\n        private attribute lengthPF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = -1; }\n        private attribute massPF: QuantityPowerFactor[1] { :>> quantity = isq.M; :>> exponent = 1; }\n        private attribute durationPF: QuantityPowerFactor[1] { :>> quantity = isq.T; :>> exponent = -2; }\n        attribute :>> quantityDimension { :>> quantityPowerFactors = (lengthPF, massPF, durationPF); }\t\t\n\t}\n    \n    attribute def TensileStrengthValue :> ScalarQuantityValue {\n\t\tattribute :>> num: Real;\n    \tattribute :>> mRef: TensileStrengthUnit;\n    }\n    \n    attribute <'N/mm²'> 'newton per square millimetre' : TensileStrengthUnit = N / mm^2;\n\n    attribute def Substance;\n\tattribute def Material :> Substance;\n\t\n\t/*\n\t * The classification of materials into metals and alloys is grossly simplified and not exhaustive.\n\t * A more complete classification would include: ChemicalSubstance, PureMaterial, MixedMaterial,\n\t * Class, Ceramic, OrganicMaterial, AnorganicMaterial, Polymer, HybridMaterial, CompositeMaterial,\n\t * etc.\n\t */\n\n    attribute def Metal :> Material {\n        attribute atomicMass: AtomicMassValue[1];\n    }\n\n    attribute def Alloy :> Material {\n        attribute fractions: MaterialFraction[2..*];\n    }\n\n    attribute def MaterialFraction {\n        attribute material: Material[1]; \n        attribute massFraction: MassFractionValue[1];\n    }\n\n    attribute def MassFractionValue :> DimensionOneValue;    \n\n\t/*\n\t * Value properties bound to specifically constructed compound values.\n\t */\n    attribute Iron: Metal { :>> atomicMass = 55.845[Da]; }\n    attribute Carbon: Metal { :>> atomicMass = 12.011[Da]; }\n    attribute Manganese: Metal { :>> atomicMass = 54.938[Da]; }\n    \n    attribute Steel_980: Alloy {\n\t\t/*\n\t\t * Value property with redefined/added sub-properties.\n\t\t * (Particular example of high tensile strength steel.)\n\t\t */\n\t\n        private attribute fraction1: MaterialFraction { :>> material = Iron; :>> massFraction = 0.9862[one]; }\n        private attribute fraction2: MaterialFraction { :>> material = Carbon; :>> massFraction = 0.0018[one]; }\n        private attribute fraction3: MaterialFraction { :>> material = Manganese; :>> massFraction = 0.012[one]; }\n    \tattribute :>> fractions = (fraction1, fraction2, fraction3);\n        attribute tensileStrength: TensileStrengthValue = 980 ['N/mm²'];\n    } \n}"
    },
    {
      "name": "17a-Sequence-Modeling",
      "text": "系统应支持定义一个用于序列建模的模型，能够描述发布、订阅和交付等事件驱动的交互过程。\n在此模型中，首先定义了几个基础项目类型，用于表示订阅、发布和交付的动作。这些项目包括订阅（Subscribe），发布（Publish）和交付（Deliver），其中每个项目都包含相关的属性和引用。\n\n系统应能够定义一个事件序列模型（PubSubSequence），描述生产者、服务器和消费者之间的交互过程。每个参与方（生产者、服务器、消费者）都包括一组事件，并能够按照事件发生的顺序触发和处理消息。生产者通过发布事件生成发布消息，服务器接收订阅事件并产生发布和交付事件，最终消费者接收交付消息。\n\n该模型通过消息传递机制，确保每个参与方在正确的时间执行相应的事件，完成从订阅到发布，再到消息交付的完整交互流程。",
      "label": "package '17a-Sequence-Modeling' {\n\tprivate import ScalarValues::*;\n\tprivate import PayloadDefinitions::*;\n\n\tpackage PayloadDefinitions {\n\t    item def Subscribe {\n\t    \tattribute topic : String;\n\t    \tref part subscriber;\n\t    }\n\t    \n\t\titem def Publish {\n\t\t\tattribute topic : String;\n\t\t\tref publication;\n\t\t}\n\t\t\n\t\titem def Deliver {\n\t\t\tref publication;\n\t\t}\n\t}\n\n\toccurrence def PubSubSequence {\n\t\tpart producer[1] {\n\t\t\tevent occurrence publish_source_event;\n\t\t}\n\t\t\n\t\tmessage publish_message of Publish[1] from producer.publish_source_event to server.publish_target_event;\n\t\t\n\t\tpart server[1] {\n\t\t\tevent occurrence subscribe_target_event;\n\t\t\tthen event occurrence publish_target_event;\n\t\t\tthen event occurrence deliver_source_event;\n\t\t}\n\t\t\n\t\tmessage subscribe_message of Subscribe[1] from consumer.subscribe_source_event to server.subscribe_target_event;\n\t\tmessage deliver_message of Deliver[1] from server.deliver_source_event to consumer.deliver_target_event;\n\t\t\n\t\tpart consumer[1] {\n\t\t\tevent occurrence subscribe_source_event;\n\t\t\tthen event occurrence deliver_target_event;\n\t\t}\n\t}\n}"
    },
    {
      "name": "17b-Sequence-Modeling",
      "text": "系统应支持定义一个用于序列建模的模型，描述发布、订阅和交付事件的交互过程。该模型强调了参与方之间的消息传递顺序及事件触发机制。\n\n在该模型中，首先定义了几个基础项目类型：订阅（Subscribe）、发布（Publish）和交付（Deliver）。每个项目都包含必要的属性和引用，以支持在事件驱动的场景中使用。\n\n该模型中的事件序列（PubSubSequence）描述了生产者、服务器和消费者之间的消息交互。每个参与方（生产者、服务器和消费者）都具有一组事件，并且可以根据事件的顺序触发和处理消息。生产者首先触发发布消息，服务器在接收到订阅消息后，先触发发布消息再触发交付消息，最后消费者接收到交付消息。\n\n该模型通过定义清晰的事件顺序和消息流，确保了从订阅到发布，再到消息交付的完整过程，支持多方协同工作，完成异步的事件驱动通信。",
      "label": "package '17b-Sequence-Modeling' {\n\tprivate import ScalarValues::*;\n\tprivate import PayloadDefinitions::*;\n\n\tpackage PayloadDefinitions {\n\t    item def Subscribe {\n\t    \tattribute topic : String;\n\t    \tref part subscriber;\n\t    }\n\t    \n\t\titem def Publish {\n\t\t\tattribute topic : String;\n\t\t\tref publication;\n\t\t}\n\t\t\n\t\titem def Deliver {\n\t\t\tref publication;\n\t\t}\n\t}\n\n\toccurrence def PubSubSequence {\n\t\tpart producer[1] {\n\t\t\tevent publish_message.source;\n\t\t}\n\t\t\n\t\tmessage publish_message of Publish[1];\n\t\t\n\t\tpart server[1] {\n\t\t\tevent subscribe_message.target;\n\t\t\tthen event publish_message.target;\n\t\t\tthen event deliver_message.source;\n\t\t}\n\t\t\n\t\tmessage subscribe_message of Subscribe[1];\n\t\tmessage deliver_message of Deliver[1];\n\t\t\n\t\tpart consumer[1] {\n\t\t\tevent subscribe_message.source;\n\t\t\tthen event deliver_message.target;\n\t\t}\n\t}\n}"
    },
    {
      "name": "18-Use Case",
      "text": "系统应支持定义并管理用例模型，以描述不同的用户需求和行为过程。在该模型中，用例通过一系列的操作步骤和参与者角色，定义了如何满足具体目标。\n\n在本模型中，定义了多个用例，包括“提供运输”（provide transportation）、“进入车辆”（enter vehicle）、“退出车辆”（exit vehicle）和“加油”（add fuel）。每个用例都有明确的主体、参与者和目标。用例“提供运输”描述了车辆、驾驶员、乘客和环境之间的交互过程，目标是将驾驶员和乘客从起始位置运输到目的地，并满足安全性、可靠性、舒适性和经济性的要求。\n\n每个用例的执行过程都由一系列事件步骤组成，例如“进入车辆”用例描述了驾驶员和乘客进入车辆的行为，而“加油”用例则涉及驾驶员在加油站为车辆加油的过程。\n\n在执行过程中，系统允许定义不同的前置条件、后置条件以及约束条件。例如，在“提供运输”用例中，起始条件是车辆处于起始位置，而结束条件是车辆到达目标位置。用例中的每个步骤还可以引用其他用例，允许在复杂的交互中复用已有的行为。\n\n通过这种方式，系统能够明确地建模和管理不同的业务场景，并确保各参与者在正确的时间执行相应的任务，从而实现系统目标。",
      "label": "package '18-Use Case' {\n\t\n\tpart def Vehicle;\n\tpart def Person;\n\tpart def Environment;\n\tpart def 'Fuel Station';\n\t\n\tuse case 'provide transportation' {\n\t\tsubject vehicle : Vehicle;\n\t\t\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t\tactor environment : Environment;\n\t\t\n\t\tobjective {\n\t\t\tdoc \n\t\t\t/* Satisfy mission requirements to transport driver and passengers \n\t\t\t * from starting location to ending location in conformance with \n\t\t\t * the driving profile and meet the mission requirements for safety, \n\t\t\t * reliability, comfort, and affordability.\n\t\t\t */\n\t\t}\n\t\t\n\t\tref :>> start {\n\t\t\tdoc /* Mock-up of a pre-condition. */\n\t\t\tassert constraint {\n\t\t\t\tdoc /* Vehicle at starting location */\n\t\t\t}\n\t\t}\n\t\t\n\t\tfirst start;\n\t\t\n\t\tthen include 'enter vehicle' {\n\t\t\tactor :>> driver = 'provide transportation'::driver;\n\t\t\tactor :>> passengers = 'provide transportation'::passengers;\n\t\t}\n\t\t\n\t\tthen use case 'drive vehicle' {\n\t\t\tinclude 'add fuel'[0..*] {\n\t\t\t\tdoc\n\t\t\t\t/*\n\t\t\t\t * Mock-up of an extension point.\n\t\t\t\t * (But reference to 'add fuel' is in the wrong direction, and it doesn't\n\t\t\t\t * make the extension condition sufficient to trigger the behavior.)\n\t\t\t\t */\n\t\t\t \n\t\t\t\tactor :>> fueler = driver;\n\t\t\t\tref :>> start {\n\t\t\t\t\tdoc /* Fuel level < 10% max fuel */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthen include 'exit vehicle' {\n\t\t\tactor :>> driver = 'provide transportation'::driver;\n\t\t\tactor :>> passengers = 'provide transportation'::passengers;\n\t\t}\n\t\t\n\t\tthen done;\n\t\t\n\t\tref :>> done {\n\t\t\tdoc /* Mock-up of a post-condition. */\n\t\t\tassert constraint {\n\t\t\t\tdoc /* Vehicle at ending location */\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tuse case 'enter vehicle' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t}\n\t\n\tuse case 'exit vehicle' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t}\n\t\t\n\tuse case 'add fuel' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor fueler : Person;\n\t\tactor 'fuel station' : 'Fuel Station';\n\t}\n}"
    }
  ]
}