{
  "train": [
    {
      "name": "Individuals and Snapshots Example",
      "text": "系统应定义一个车辆实例的个体化状态管理流程，通过快照记录不同时间点的车辆属性和状态变化。该流程包含以下需求：\n\n车辆实例定义：定义一个特定的车辆实例Vehicle_1，并通过多个快照捕获其状态和属性在不同时刻的变化。\n\n初始快照（vehicle_1_t0）：在车辆的初始状态下，记录以下属性：\n\n质量（mass）：2000.0 kg\n状态（status）：\n档位设定（gearSetting）：0（空挡）\n油门位置（acceleratorPosition）：0.0（未踩油门）\n更新快照（vehicle_1_t1）：在后续时间点更新车辆的状态和属性，记录以下变化：\n\n质量（mass）：1500.0 kg\n状态（status）：\n档位设定（gearSetting）：2（行驶模式）\n油门位置（acceleratorPosition）：0.5（部分油门）\n时间序列：系统应按时间顺序管理车辆状态的变化，从初始快照vehicle_1_t0到更新快照vehicle_1_t1，确保对车辆在不同时间点的属性状态进行有序追踪。\n\n通过该个体和快照的定义，系统能够详细记录车辆的关键属性变化，为车辆状态的历史分析、维护决策和操作记录提供可靠的数据支持。这种方法确保车辆生命周期内的状态变化信息清晰、可追溯。",
      "label": "package 'Individuals and Snapshots Example' {\n\tpublic import 'Part Definition Example'::*;\n\t\n\tindividual part def Vehicle_1 :> Vehicle {\n\t\t\n\t\tsnapshot part vehicle_1_t0 {\n\t\t\t:>> mass = 2000.0;\n\t\t\t:>> status {\n\t\t\t\t:>> gearSetting = 0;\n\t\t\t\t:>> acceleratorPosition = 0.0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsnapshot part vehicle_1_t1 {\n\t\t\t:>> mass = 1500.0;\n\t\t\t:>> status {\n\t\t\t\t:>> gearSetting = 2;\n\t\t\t\t:>> acceleratorPosition = 0.5;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfirst vehicle_1_t0 then vehicle_1_t1;\n\t}\n}"
    },
    {
      "name": "Individuals and Time Slices",
      "text": "系统应定义一个车辆实例的个体化时间片管理流程，以追踪车辆在不同驾驶员下的状态和属性变化。该流程包含以下需求：\n\n驾驶员个体定义：定义两位驾驶员个体：\n\nAlice：作为驾驶员之一\nBob：作为另一驾驶员\n车辆实例时间片定义：为车辆实例Vehicle_1定义时间片，以记录在不同驾驶员控制下的车辆状态。\n\n时间片“aliceDriving”：在此时间片中，车辆的驾驶员为Alice。\n\n开始快照（start）：记录车辆的初始质量为2000.0 kg。\n结束快照（done）：记录车辆的质量更新为1500.0 kg。\n时间片“bobDriving”：在此后续时间片中，车辆的驾驶员为Bob。\n\n时间顺序管理：系统应确保时间片按顺序执行，首先是Alice驾驶的时间片“aliceDriving”，随后是Bob驾驶的时间片“bobDriving”。\n\n通过这种时间片和快照管理方法，系统能够在车辆的生命周期内记录不同驾驶员对车辆的使用情况以及相关属性的变化，为后续分析、车辆管理和维护提供详尽的历史数据。这种设计确保驾驶员变化、车辆状态以及时间片信息的清晰可追溯性。",
      "label": "package 'Individuals and Time Slices' {\n\tprivate import 'Individuals and Snapshots Example'::*;\n\t\n\tindividual item def Alice :> Person;\n\tindividual item def Bob :> Person;\n\t\n\tindividual : Vehicle_1 {\n\t\t\n\t\ttimeslice aliceDriving {\n\t\t\tref individual item :>> driver : Alice;\n\n\t\t\tsnapshot :>> start {\n\t\t\t\t:>> mass = 2000.0;\n\t\t\t}\n\t\t\t\n\t\t\tsnapshot :>> done {\n\t\t\t\t:>> mass = 1500.0;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tthen timeslice bobDriving {\n\t\t\tref individual item :>> driver : Bob;\n\t\t}\n\t\t\n\t}\n}"
    },
    {
      "name": "Individuals and Roles-1",
      "text": "系统应定义一个车辆实例的个体化管理流程，以追踪车辆部件在不同时间点的状态和角色变化。该流程包含以下需求：\n\n车辆实例定义：定义一个车辆实例Vehicle_1，并配置其部件，包括前左轮（leftFrontWheel）和前右轮（rightFrontWheel），每个轮子部件均定义为Wheel类型。\n\n轮子个体定义：定义一个轮子实例Wheel_1，用于作为车辆部件快照中的具体实例。\n\n车辆状态快照：为车辆实例vehicle_1定义时间点快照，以追踪不同时间点的部件状态。\n\n快照vehicle_1_t0：在初始状态下捕获车辆vehicle_1的结构，包括前左轮部件的快照，绑定Wheel_1至leftFrontWheel。\n快照vehicle_1_t1：在后续状态下更新车辆状态，包括前右轮部件的快照，将Wheel_1绑定至rightFrontWheel。",
      "label": "package 'Individuals and Roles' {\n\tprivate import 'Part Definition Example'::*;\n\t\n\tpart def Wheel;\n\t\n\tindividual part def Vehicle_1 :> Vehicle {\n\t\tpart leftFrontWheel : Wheel;\n\t\tpart rightFrontWheel : Wheel;\n\t}\n\t\n\tindividual part def Wheel_1 :> Wheel;\n\t\n\tindividual part vehicle_1 : Vehicle_1 {\n\t\tsnapshot part vehicle_1_t0 {\n\t\t\tsnapshot leftFrontWheel_t0 : Wheel_1 :>> leftFrontWheel;\n\t\t}\n\t\t\n\t\tthen snapshot part vehicle_1_t1 {\n\t\t\tsnapshot rightFrontWheel_t1 : Wheel_1 :>> rightFrontWheel;\n\t\t}\n\t}\n}"
    },
    {
      "name": "Metadata Example-1",
      "text": "系统应在车辆的设计中集成关键的安全和防护功能，以确保乘员的安全以及车辆的安保。安全功能包括内饰部件和车身组件，旨在在事故中保护驾驶员和乘客。具体而言，车辆应配备座椅安全带（seatBelt）和驾驶员气囊（driverAirBag），作为内饰中的安全部件，另外，车身组件还应包括保险杠（bumper），以在碰撞时吸收冲击力并降低伤害风险。\n\n此外，系统应集成安保功能，以防止车辆被盗或受到未经授权的访问。在车辆的内饰部分，警报系统（alarm）作为安保措施之一，以警示异常行为或非法入侵；车身组件中还应具备无钥匙进入系统（keylessEntry），以增强车辆的安防便捷性和安全性。\n\n通过这些安全和安保功能的设计，系统能够提供多层次的保护，确保在驾驶过程中为乘员和车辆提供安全防护。该需求旨在确保系统能够覆盖可能的安全和安保场景，为车辆的使用提供可靠的防护支持。",
      "label": "package 'Metadata Example-1' {\n\t\n\tmetadata def SafetyFeature;\n\tmetadata def SecurityFeature {\n\t\t:> annotatedElement : SysML::PartDefinition;\n\t\t:> annotatedElement : SysML::PartUsage;\n\t}\n\t\n\tmetadata SafetyFeature about \n\t\tvehicle::interior::seatBelt,\n\t\tvehicle::interior::driverAirBag,\n\t\tvehicle::bodyAssy::bumper;\n\t\n\tmetadata SecurityFeature about\n\t\tvehicle::interior::alarm,\n\t\tvehicle::bodyAssy::keylessEntry;\n\t\t\n\tpart vehicle {\n\t\tpart interior {\n\t\t\tpart alarm;\n\t\t\tpart seatBelt[2];\n\t\t\tpart frontSeat[2];\n\t\t\tpart driverAirBag;\n\t\t}\n\t\tpart bodyAssy {\n\t\t\tpart body;\n\t\t\tpart bumper;\n\t\t\tpart keylessEntry;\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Metadata Example-2",
      "text": "系统应支持动力学计算的执行，并能够通过特定的分析工具实现变量的映射和执行管理。computeDynamics操作的执行使用了“ModelCenter”工具，该工具通过指定的URI（aserv://localhost/Vehicle/Equation1）链接到具体的计算资源。\n\n在该操作中，系统接收一组输入变量，包括时间增量（deltaT）、加速度（mass）、初始速度（v0）和初始位置（x0），并将其作为动力学计算的输入。在输出端，系统计算出结果速度（v）和位置（x），并将这些结果返回以供后续分析使用。\n\n各个输入和输出变量均通过@ToolVariable注释进行映射，使系统能够在工具执行过程中使用标准化的变量名称。通过此工具执行元数据的配置，系统能够确保动力学计算与外部分析工具的无缝集成，从而实现对车辆动力学的精确模拟和管理。该需求确保了系统的计算过程具有高度的灵活性和集成性，为复杂的动力学分析提供了可靠的支持。",
      "label": "package 'Metadata Example-2' {\n\t\n\taction computeDynamics {\n\t\tprivate import AnalysisTooling::*;\n\t\t\n\t\tmetadata ToolExecution {\n\t\t\ttoolName = \"ModelCenter\";\n\t\t\turi = \"aserv://localhost/Vehicle/Equation1\";\n\t\t}\n\t\t\t\n\t\tin dt : ISQ::TimeValue             { @ToolVariable { name = \"deltaT\"; } }\n\t\tin a : ISQ::AccelerationValue      { @ToolVariable { name = \"mass\"; } }\n\t\tin v_in : ISQ::SpeedValue          { @ToolVariable { name = \"v0\"; } }\n\t\tin x_in : ISQ::LengthValue         { @ToolVariable { name = \"x0\"; } }\n\t\t\n\t\tout v_out : ISQ::SpeedValue        { @ToolVariable { name = \"v\"; } }\n\t\tout x_out : ISQ::LengthValue       { @ToolVariable { name = \"x\"; } }\t\t\t\n\t}\n\t\n}"
    },
    {
      "name": "Connections Example",
      "text": "系统应定义一个轮毂组件结构，包含轮胎和轮毂等部件，以实现完整的装配。轮毂组件中的轮胎部分应包括两个胎圈，与轮毂的两个轮辋部分通过压力密封连接。轮毂组件中的轮子部件应包含轮辋和用于安装螺栓的孔（共五个），并支持与螺栓连接。系统应使用压力密封连接轮胎的胎圈与轮辋，确保气密性。此外，螺栓连接应实现轮辋的安装孔与轮毂上的螺纹孔的对接，以确保轮胎的稳固安装和安全运行。",
      "label": "package 'Connections Example' {\n\t\n\tpart def WheelHubAssembly;\n\tpart def WheelAssembly;\n\tpart def Tire;\n\tpart def TireBead;\n\tpart def Wheel;\n\tpart def TireMountingRim;\n\tpart def LugBoltMountingHole;\n\tpart def Hub;\n\tpart def LugBoltThreadableHole;\n\tpart def LugBoltJoint;\n\t\n\tconnection def PressureSeat {\n\t\tend bead : TireBead[1];\n\t\tend mountingRim : TireMountingRim[1];\n\t}\n\t\n\tpart wheelHubAssembly : WheelHubAssembly {\n\t\t\n\t\tpart wheel : WheelAssembly[1] {\n\t\t\tpart t : Tire[1] {\n\t\t\t\tpart bead : TireBead[2];\t\t\t\n\t\t\t}\n\t\t\tpart w: Wheel[1] {\n\t\t\t\tpart rim : TireMountingRim[2];\n\t\t\t\tpart mountingHoles : LugBoltMountingHole[5];\n\t\t\t}\t\t\t\t\t\t\n\t\t\tconnection : PressureSeat \n\t\t\t\tconnect bead references t.bead \n\t\t\t\tto mountingRim references w.rim;\t\t\n\t\t}\n\t\t\n\t\tpart lugBoltJoints : LugBoltJoint[0..5];\n\t\tpart hub : Hub[1] {\n\t\t\tpart h : LugBoltThreadableHole[5];\n\t\t}\n\t\tconnect lugBoltJoints[0..1] to wheel.w.mountingHoles[1];\n\t\tconnect lugBoltJoints[0..1] to hub.h[1];\n\t}\n\t\n}"
    },
    {
      "name": "Conditional Succession Example-2",
      "text": "系统应定义一个拍照操作流程，以场景作为输入并生成图片作为输出。该流程包含聚焦和拍摄两个步骤，并设置条件判断，以确保图像符合清晰度要求。首先执行聚焦操作，将场景作为输入并生成图像输出；当且仅当图像属性“isWellFocused”为真时，才继续执行拍摄操作以生成最终的图片。聚焦操作的场景输入与拍照流程的场景输入一致，拍摄操作的图片输出绑定至拍照流程的图片输出，从而在图像满足清晰度要求的前提下，确保整个拍摄过程的连贯和高质量输出。",
      "label": "package 'Conditional Succession Example-2' {\n\tpart def Scene;\n\tpart def Image {\n\t\tisWellFocused: ScalarValues::Boolean;\n\t}\n\tpart def Picture;\n\t\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\taction def TakePicture { in scene : Scene; out picture : Picture; }\n\t\n\taction takePicture : TakePicture {\n\t\tin item scene;\n\t\tout item picture;\n\t\t\n\t\taction focus : Focus {\n\t\t\tin item scene = takePicture::scene; \n\t\t\tout item image;\n\t\t}\n\t\t\n\t\tif focus.image.isWellFocused then shoot;\n\t\t\n\t\tflow from focus.image to shoot.image;\n\n\t\taction shoot : Shoot {\n\t\t\tin item image; \n\t\t\tout item picture = takePicture::picture;\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Conditional Succession Example-1",
      "text": "系统应定义一个拍照操作流程，以场景作为输入并生成图片作为输出。该流程包含聚焦和拍摄两个步骤，并设置条件判断以确保图像的质量。首先执行聚焦操作，将场景作为输入生成图像输出；如果图像满足清晰度要求（即图像的“isWellFocused”属性为真），则继续执行拍摄操作生成最终的图片输出。聚焦操作的场景输入与拍照流程的场景输入一致，拍摄操作的图片输出则绑定至拍照流程的图片输出，从而确保图像质量的前提下完成拍摄流程的连贯执行。",
      "label": "package 'Conditional Succession Example-1' {\n\tpart def Scene;\n\tpart def Image {\n\t\tisWellFocused: ScalarValues::Boolean;\n\t}\n\tpart def Picture;\n\t\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\taction def TakePicture { in scene : Scene; out picture : Picture; }\n\t\n\taction takePicture : TakePicture {\n\t\tin item scene;\n\t\tout item picture;\n\t\t\n\t\taction focus : Focus {\n\t\t\tin item scene = takePicture::scene; \n\t\t\tout item image;\n\t\t}\n\t\t\t\t\n\t\tfirst focus \n\t\t\tif focus.image.isWellFocused then shoot;\n\t\t\n\t\tflow from focus.image to shoot.image;\n\n\t\taction shoot : Shoot {\n\t\t\tin item; \n\t\t\tout item picture = takePicture::picture;\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Fork Join Example",
      "text": "系统应定义一个刹车流程，以协调多个监测和控制操作，在车辆启动刹车时提供精确的制动控制。刹车流程开始时触发“启动”操作，然后分叉进入两个并行的监测阶段：一个用于监测刹车踏板的压力，另一个用于监测牵引力的调节频率。每个监测阶段输出其相应的数据，刹车踏板监测输出刹车压力，牵引监测输出调节频率。这些输出数据随后汇集在制动操作中，输入到刹车操作以执行制动控制。流程通过一个汇合节点合并各监测和控制操作，确保所有条件都满足后完成整个刹车操作，保证刹车过程的连贯性和安全性。",
      "label": "package 'Fork Join Example' {\n\tprivate import ScalarValues::*;\n\t\n\tattribute def TurnKeyToOn;\n\tattribute def BrakePressure;\n\t\n\taction def MonitorBrakePedal { out pressure : BrakePressure; }\n\taction def MonitorTraction { out modFreq : Real; }\n\taction def Braking { in brakePressure : BrakePressure; in modulationFrequency : Real; }\n\t\n\taction def Brake {\n\t\taction TurnOn;\n\t\t\n\t\tthen fork;\n\t\t\tthen monitorBrakePedal;\n\t\t\tthen monitorTraction;\n\t\t\tthen braking;\n\t\t\n\t\taction monitorBrakePedal : MonitorBrakePedal {\n\t\t\tout brakePressure;\n\t\t}\n\t\tthen joinNode;\n\t\t\n\t\taction monitorTraction : MonitorTraction {\n\t\t\tout modulationFrequency;\n\t\t}\n\t\tthen joinNode;\n\t\t\n\t\tflow from monitorBrakePedal.brakePressure to braking.brakePressure;\n\t\tflow from monitorTraction.modulationFrequency to braking.modulationFrequency; \n\t\t\n\t\taction braking : Braking {\n\t\t\tin brakePressure; \n\t\t\tin modulationFrequency;\n\t\t}\n\t\tthen joinNode;\n\t\t\n\t\tjoin joinNode;\n\t\tthen done;\n\t}\n}"
    },
    {
      "name": "Merge Example",
      "text": "系统应定义一个拍照流程，从启动到图片展示的各个操作步骤，以实现从场景捕捉到图片显示的完整过程。该流程首先启动进入合并节点“继续”状态，触发场景捕捉操作。捕捉的场景输入进入聚焦操作，将场景转换为图像输出，图像输出随后流向拍摄操作生成图片。在拍摄完成后，图片进一步流入显示操作，以展示最终的拍摄结果。通过合并节点的设置，流程在各步骤间保持连贯性，确保图像在捕捉、拍摄和显示过程中顺利衔接，实现拍照到展示的完整操作。",
      "label": "package 'Merge Example' {\n\tpart def Scene;\n\tpart def Image;\n\tpart def Picture;\n\t\n\taction def Focus { in item scene : Scene; out item image : Image; }\n\taction def Shoot { in item image : Image; out item picture : Picture; }\n\taction def Display { in item picture : Picture; }\n\taction def TakePicture;\n\t\n\taction takePicture : TakePicture {\n\t\tfirst start;\n\t\t\n\t\tthen merge continue;\n\t\t\t\n\t\tthen action trigger {\n\t\t\tout item scene : Scene;\n\t\t}\n\t\t\n\t\tflow from trigger.scene to focus.scene;\n\t\t\n\t\tthen action focus : Focus {\n\t\t\tin item scene;\n\t\t\tout item image;\n\t\t}\n\t\t\n\t\tflow from focus.image to shoot.image;\n\t\t\n\t\tthen action shoot : Shoot {\n\t\t\tin item image ;\n\t\t\tout item picture;\n\t\t}\n\t\t\n\t\tflow from shoot.picture to display.picture;\n\t\t\n\t\tthen action display : Display {\n\t\t\tin item picture;\n\t\t}\n\t\t\n\t\tthen continue;\t\n\t}\n}"
    },
    {
      "name": "Camera",
      "text": "系统应定义一个相机组件，以实现从场景捕捉到照片生成的自动拍照流程。相机组件应包含一个场景引用项作为输入源，以及一个存储生成照片的集合。相机的自动聚焦部分应接收场景作为输入，生成聚焦后的图像输出，并将该图像流入成像模块。成像模块接收聚焦后的图像，生成最终的照片，并将其存储在相机的照片集合中。通过自动聚焦与成像模块的协作，相机系统可以实现从场景到照片的自动化捕捉和存储功能。",
      "label": "package Camera {\n\tprivate import 'Action Decomposition'::*;\n\t\n\tpart def Camera;\n\tpart def FocusingSubsystem;\n\tpart def ImagingSubsystem;\n\t\n\tpart camera : Camera {\n\t\tref item scene : Scene;\n\t\tpart photos : Picture[*];\n\t\t\t\t\n\t\tpart autoFocus {\n\t\t\tin ref item scene : Scene = camera::scene;\t\t\n\t\t\tout ref item realImage : Image;\n\t\t}\n\t\t\n\t\tflow autoFocus.realImage to imager.focusedImage;\n\t\t\n\t\tpart imager {\n\t\t\tin item focusedImage : Image;\t\t\n\t\t\tout item photo : Picture :> photos;\n\t\t}\n\t\t\n\t}\n}"
    },
    {
      "name": "Decision Example",
      "text": "系统应定义一个电池充电流程，通过监测电池电量并根据不同的电量水平决定是否继续充电或结束充电。该流程从启动开始，进入一个监控阶段，测量电池的当前电量。根据监测的电量，流程将进入决策阶段：如果电量低于100%，则执行充电操作，将当前电量输入到充电操作中并返回至继续充电的节点；如果电量已达到或超过100%，则执行结束充电操作以终止充电流程。该决策结构确保系统在电池未充满时继续充电，并在电池充满后安全地结束充电。",
      "label": "package 'Decision Example' {\n\tprivate import ScalarValues::*;\n\t\n\tattribute def BatteryCharged;\n\t\n\tpart battery;\n\tpart powerSystem;\n\t\n\taction def MonitorBattery { out charge : Real; }\n\taction def AddCharge { in charge : Real; }\n\taction def EndCharging;\n\t\n\taction def ChargeBattery {\n\t\tfirst start;\n\n\t\tthen merge continueCharging;\n\t\t\n\t\tthen action monitor : MonitorBattery {\n\t\t\tout batteryCharge : Real;\n\t\t}\n\t\t\n\t\tthen decide;\n\t\t\tif monitor.batteryCharge < 100 then addCharge;\n\t\t\tif monitor.batteryCharge >= 100 then endCharging;\n\t\t\t\n\t\taction addCharge : AddCharge {\n\t\t\tin charge = monitor.batteryCharge;\n\t\t}\n\t\tthen continueCharging;\n\t\t\n\t\taction endCharging : EndCharging;\n\t\tthen done;\n\t}\n}"
    },
    {
      "name": "Control Structures Example",
      "text": "系统应定义一个电池充电操作流程，以实现电池电量的持续监控和充电。该流程包含循环操作，在电池充电不足的情况下执行充电，直到电量达到100%。首先，系统通过监控操作持续测量电池的当前电量；如果电量低于100%，则触发充电操作，将当前电量输入到充电操作中。该循环持续进行，直至监控显示电量达到或超过100%。当充电完成后，系统执行结束充电操作，以终止充电流程并确保电池已充满。通过该控制结构，系统能够实现自动化的电池充电和终止控制。",
      "label": "package 'Control Structures Example' {\n\tprivate import ScalarValues::*;\n\t\n\tattribute def BatteryCharged;\n\t\n\tpart battery;\n\tpart powerSystem;\n\t\n\taction def MonitorBattery { out charge : Real; }\n\taction def AddCharge { in charge : Real; }\n\taction def EndCharging;\n\t\n\taction def ChargeBattery {\n\t\tloop action charging {\n\t\t\taction monitor : MonitorBattery {\n\t\t\t\tout charge;\n\t\t\t}\n\t\t\t\n\t\t\tthen if monitor.charge < 100 {\n\t\t\t\taction addCharge : AddCharge {\n\t\t\t\t\tin charge = monitor.charge;\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\t\t} until charging.monitor.charge >= 100;\n\t\t\n\t\tthen action endCharging : EndCharging;\n\t\tthen done;\n\t}\n}"
    },
    {
      "name": "Transition Actions",
      "text": "系统应定义一个车辆状态管理流程，以控制车辆在“关闭”、“启动中”和“开启”状态之间的转换，并包含特定的转换操作。在初始状态“关闭”下，当接收到启动信号时，车辆状态从“关闭”切换到“启动中”。在“启动中”状态，当接收到开启信号并且车辆的刹车踏板被按下时，系统会向控制器发送启动信号，然后车辆切换到“开启”状态。\n\n在“开启”状态，系统执行一系列操作：进入时车辆会进行自检，以确保正常运行；在“开启”状态持续期间，系统会提供动力；退出时执行停车制动操作，以确保安全停放。此外，若在“开启”状态下接收到关闭信号，车辆状态会切换回“关闭”。该状态管理流程中的转换动作确保了车辆在特定条件下的安全性和有序的操作控制。",
      "label": "package 'Transition Actions' {\n\t\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\t\n\tattribute def ControllerStartSignal;\n\t\n\tpart def Vehicle {\n\t\tbrakePedalDepressed : ScalarValues::Boolean;\n\t}\n\tpart def VehicleController;\n\t\n\taction performSelfTest { in vehicle : Vehicle; }\n\t\n\tstate def VehicleStates;\n\t\t\n\tstate vehicleStates : VehicleStates {\n\t\tin operatingVehicle : Vehicle;\n\t\tin controller : VehicleController;\n\n\t\tentry; then off;\n\t\t\n\t\tstate off;\n\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\t\t\n\t\tstate starting;\n\t\taccept VehicleOnSignal\n\t\t\tif operatingVehicle.brakePedalDepressed\n\t\t\tdo send ControllerStartSignal() to controller\n\t\t\tthen on;\n\t\t\t\n\t\tstate on {\n\t\t\tentry performSelfTest{ in vehicle = operatingVehicle; }\n\t\t\tdo action providePower { /* ... */ }\n\t\t\texit action applyParkingBrake { /* ... */ }\n\t\t}\n\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\n\t}\n\t\n}"
    },
    {
      "name": "Local Clock Example",
      "text": "系统应定义一个服务器行为流程，利用本地时钟和时间触发条件来控制服务器的状态转换。初始状态为“关闭”，当通过请求端口接收到“启动”信号时，服务器切换至“等待”状态。在“等待”状态中，服务器可通过请求端口接收请求，并在接收到请求后切换到“响应”状态。若本地时钟达到当天的11:59:00，服务器将自动返回到“关闭”状态。在“响应”状态下，服务器在响应完成后等待5分钟，然后切换回“等待”状态以接受新的请求。通过本地时钟和时间触发控制，系统能够在特定时间和请求条件下高效地管理服务器的运行状态。",
      "label": "package 'Local Clock Example' {\n\tprivate import ScalarValues::String;\n\t\n\titem def Start;\n\titem def Request;\n\t\n\tpart def Server {\n\t\tpart :>> localClock = Time::Clock();\n\n\t\tattribute today : String;\n\t\t\t\t\n\t\tport requestPort;\n\t\t\n\t\tstate ServerBehavior {\n\t\t\tentry; then off;\n\t\t\t\n\t\t\tstate off;\n\t\t\taccept Start via requestPort\n\t\t\t\tthen waiting;\n\t\t\t\n\t\t\tstate waiting;\n\t\t\taccept request : Request via requestPort\n\t\t\t\tthen responding;\n\t\t\taccept at Time::Iso8601DateTime(today + \"11:59:00\")\n\t\t\t\tthen off;\n\t\t\t\n\t\t\tstate responding;\n\t\t\taccept after 5 [SI::min]\n\t\t\t\tthen waiting;\n\t\t}\n\t}\n}"
    },
    {
      "name": "Change and Time Triggers",
      "text": "系统应定义一个车辆健康状态管理流程，通过时间和温度触发条件，实时监控和维护车辆的状态。流程的初始状态为“正常”，并持续监测车辆温度。当达到车辆设定的维护时间时，状态从“正常”切换至“维护”状态，同时更新下一次维护时间为当前维护时间加上维护间隔。在“维护”状态持续48小时后，系统自动返回到“正常”状态。\n\n此外，若温度监测结果超过车辆的最大温度限制，则系统会发送“过温”警告至控制器并切换到“降级”状态。在“降级”状态下，当温度恢复至安全范围内时，系统会返回到“正常”状态。通过这种状态管理，系统能够基于时间和温度的触发条件，确保车辆的运行安全和按时维护。",
      "label": "package 'Change and Time Triggers' {\n\tprivate import ISQ::TemperatureValue;\n\tprivate import ISQ::DurationValue;\n\tprivate import Time::TimeInstantValue;\n\tprivate import SI::h;\n\t\n\tattribute def OverTemp;\n\t\n\tpart def Vehicle {\n\t\tattribute maintenanceTime : TimeInstantValue;\n\t\tattribute maintenanceInterval : DurationValue;\n\t\tattribute maxTemperature : TemperatureValue;\n\t}\n\t\n\tpart def VehicleController;\n\t\n\taction senseTemperature { out temp : TemperatureValue; }\n\t\n\tstate healthStates {\n\t\tin vehicle : Vehicle;\n\t\tin controller : VehicleController;\n\t\t\n\t\tentry; then normal;\n\t\tdo senseTemperature;\n\t\t\n\t\tstate normal;\n\t\taccept at vehicle.maintenanceTime\n\t\t\tthen maintenance;\n\t\taccept when senseTemperature.temp > vehicle.maxTemperature\n\t\t\tdo send OverTemp() to controller \n\t\t\tthen degraded;\n\t\t\n\t\tstate maintenance {\n\t\t\tentry assign vehicle.maintenanceTime := vehicle.maintenanceTime + vehicle.maintenanceInterval;\n\t\t}\n\t\taccept after 48 [h]\n\t\t\tthen normal;\n\t\t\n\t\tstate degraded;\n\t\taccept when senseTemperature.temp <= vehicle.maxTemperature\n\t\t\tthen normal;\n\t}\n}"
    },
    {
      "name": "Opaque Action Example",
      "text": "系统应定义一个传感器更新操作，用于遍历多个传感器并对已准备就绪的传感器进行更新。传感器更新操作接受一组传感器作为输入，并执行“Alf”语言编写的操作逻辑。该逻辑遍历每个传感器，检查其“ready”属性状态；如果传感器处于就绪状态，则执行更新操作。此操作流程确保仅对已准备好的传感器进行更新，优化系统资源使用并保证高效的传感器管理。",
      "label": "package 'Opaque Action Example' {\n\t\n\tpart def Sensor {\n\t\tattribute ready : ScalarValues::Boolean;\n\t}\n\t\n\taction def UpdateSensors {\n\t\tin sensors : Sensor[*];\n\t\tlanguage \"Alf\" \n\t\t\t/* \n\t\t\t * for (sensor in sensors) {\n\t\t\t *     if (sensor.ready) {\n\t\t\t *         Update(sensor);\n\t\t\t *     }\n\t\t\t * }\n\t\t\t */\n\t}\n\t\n}"
    },
    {
      "name": "Generalization Example",
      "text": "系统应包含一个车辆的抽象概念，支持多种类型的车辆定义。\n车辆类型中包含人力驱动车辆，该车辆类型应具有一个驾驶员引用，以指定驾驶员角色；\n动力驱动车辆应包含一个引擎部件，以提供动力源。\n此外，系统应定义一种既有人力驱动又具备动力系统的车辆类型，结合了驾驶员和引擎的特性，用于支持\n多种操作模式。",
      "label": "package 'Generalization Example' {\n\n\tabstract part def Vehicle;\n\t\n\tpart def HumanDrivenVehicle specializes Vehicle {\n\t\tref part driver : Person;\n\t}\n\t\n\tpart def PoweredVehicle :> Vehicle {\n\t\tpart eng : Engine;\n\t}\n\t\n\tpart def HumanDrivenPoweredVehicle :> \n\t\tHumanDrivenVehicle, PoweredVehicle;\n\t\n\tpart def Engine;\t\n\tpart def Person;\n\t\n}"
    },
    {
      "name": "Variation Definitions",
      "text": "系统应支持车辆引擎和组件的多样化配置，通过定义不同的变体选项以满足不同的设计需求和性能规格。引擎组件包括气缸（Cylinder）和气缸直径属性（Diameter），其中气缸数量和直径可根据特定引擎的需求进行变化。\n\n在气缸的配置中，系统为4缸引擎（4cylEngine）和6缸引擎（6cylEngine）提供两种选项。4缸引擎包含四个气缸，而6缸引擎包含六个气缸，以满足不同功率和燃油效率的需求。每个气缸的直径可以选择小直径（70 mm）或大直径（100 mm），具体选择根据车辆的性能要求而定。\n\n通过这些变体定义，系统能够灵活地配置不同气缸数和直径的引擎组合。变体模型包括了多样化的引擎选择（EngineChoices）和气缸直径选择（DiameterChoices），确保系统在同一平台内支持不同配置，为车辆性能优化和市场需求提供灵活的解决方案。",
      "label": "package 'Variation Definitions' {\n\tprivate import ScalarValues::Real;\n\tprivate import SI::mm;\n\t\n\tattribute def Diameter :> ISQ::LengthValue;\n\t\n    part def Cylinder {\n        attribute diameter : Diameter[1];\n    }\n\n    part def Engine {\n    \tpart cylinder : Cylinder[2..*];\n    }\n    \n    part '4cylEngine' : Engine {\n    \tpart redefines cylinder[4];\n    }\n    \n    part '6cylEngine' : Engine {\n    \tpart redefines cylinder[6];\n    }\n    \n    // Variability model\n\t\n\tvariation attribute def DiameterChoices :> Diameter {\n\t\tvariant attribute diameterSmall = 70[mm];\n\t\tvariant attribute diameterLarge = 100[mm];\n\t}\n\n\tvariation part def EngineChoices :> Engine {\n\t\tvariant '4cylEngine';\n\t\tvariant '6cylEngine';\t\t\n\t}\t\n\n}"
    },
    {
      "name": "Variation Configuration",
      "text": "系统应支持车辆配置的多样性，通过不同的引擎和变速箱组合生成不同的车辆型号。该配置管理允许为车辆提供4缸和6缸两种引擎选择，每种引擎均配备手动变速箱，以满足不同性能需求。\n\n在vehicle4Cyl配置中，系统将车辆配置为4缸引擎（4cylEngine）和手动变速箱（manualTransmission），适合追求较高燃油经济性和轻便性的用户。在vehicle6Cyl配置中，系统将车辆配置为6缸引擎（6cylEngine）和手动变速箱，提供更强的动力输出以满足较高的性能需求。\n\n通过这些配置的定义，系统能够根据用户需求提供不同的车辆变体，确保在同一车辆家族内灵活配置不同的性能和燃油经济性，为车辆生产和市场推广提供多样化的选择。",
      "label": "package 'Variation Configuration' {\n\tprivate import 'Variation Usages'::*;\n\t\n\tpart vehicle4Cyl :> vehicleFamily {\n\t\tpart redefines engine = engine::'4cylEngine';\n\t\tpart redefines transmission = transmission::manualTransmission;\n\t}\n\t\n\tpart vehicle6Cyl :> vehicleFamily {\n\t\tpart redefines engine = engine::'6cylEngine';\n\t\tpart redefines transmission = transmission::manualTransmission;\n\t}\n\t\n}"
    },
    {
      "name": "Variation Usages",
      "text": "系统应支持车辆配置的多样化选择，通过引擎和变速箱的组合，为不同需求提供灵活的变体。vehicleFamily作为抽象的车辆配置类别，包含引擎和变速箱的多种变体选项，其中引擎变体包括4缸引擎和6缸引擎，变速箱则包含手动变速箱和自动变速箱。\n\n在配置中，系统定义了以下约束条件，以确保配置的正确性和一致性：当选择4缸引擎时，车辆应配备手动变速箱；当选择6缸引擎时，车辆应配备自动变速箱。这一逻辑保证了车辆的不同配置在性能、驱动方式和用户需求上的适配性。\n\n该变体模型通过引擎和变速箱的组合，为车辆提供了多样化的配置选项，并确保每种配置符合预设的性能逻辑。这种配置方法能够满足不同市场需求，为车辆生产提供灵活的选择，同时确保车辆设计的合理性和一致性。",
      "label": "package 'Variation Usages' {\n\tprivate import 'Variation Definitions'::*;\n\t\n\tpart def Vehicle;\n\tpart def Transmission;\n\tpart manualTransmission;\n\tpart automaticTransmission;\n\t\n\tabstract part vehicleFamily : Vehicle {\n\t\tpart engine : EngineChoices[1];\n\t\t\n\t\tvariation part transmission : Transmission[1] {\n\t\t\tvariant manualTransmission;\n\t\t\tvariant automaticTransmission;\n\t\t}\n\t\t\n\t\tassert constraint {\n\t\t\t(engine == engine::'4cylEngine' and\n\t\t\t transmission == transmission::manualTransmission) xor\n\t\t\t(engine == engine::'6cylEngine' and \n\t\t\t transmission == transmission::automaticTransmission)\n\t\t}\t\n\t}\n\t\n}"
    },
    {
      "name": "MassRollup2",
      "text": "系统应具备对物体及其组件的质量进行灵活的汇总计算，以支持多层次的质量管理。每个物体应记录其简单质量和总质量，默认情况下总质量等于简单质量。对于复合物体，总质量的计算方式是将简单质量与所有子组件的总质量相加。系统还应支持通过筛选条件来限定参与汇总的子组件，使得复合物体可以根据设定的最小质量值进行汇总。对于特定的复合物体（如带有筛选条件的filteredMassThing），系统仅在子组件质量等于或超过最小质量值时，将其纳入总质量计算。这种设计确保系统在处理复杂物体的质量时能够灵活地应用筛选标准，提供精确和可控的质量数据，以满足不同的质量管理需求。",
      "label": "package MassRollup2 {\n\tprivate import NumericalFunctions::*;\n\t\n\tpart def MassedThing {\n\t\tattribute simpleMass :> ISQ::mass; \n\t\tattribute totalMass :> ISQ::mass default simpleMass;\n\t}\n\t\n\tpart compositeThing : MassedThing {\n\t\tpart subcomponents: MassedThing[*];\t\t\n\t\tattribute :>> totalMass default\n\t\t\tsimpleMass + sum(subcomponents.totalMass); \n\t}\n\t\n\tpart filteredMassThing :> compositeThing {\n\t\tattribute minMass :> ISQ::mass;\t\t\n\t\tattribute :>> totalMass =\n\t\t\tsimpleMass + sum(subcomponents.totalMass.?{in p:>ISQ::mass; p >= minMass});\n\t}\n\n}"
    },
    {
      "name": "MassRollup1",
      "text": "系统应具备对物体及其组件的质量进行汇总计算的能力，以支持单一物体和复合物体的质量管理。每个物体记录其简单质量和总质量，系统应根据物体的结构类型进行不同的质量汇总方式。对于简单物体，总质量等于其简单质量。对于复合物体，系统应将该物体的简单质量与其所有子组件的总质量相加，以计算复合物体的总质量。这一功能允许系统自动汇总复合物体的所有组成部分，提供准确的质量数据，从而确保在复杂结构中物体质量计算的透明性和精确性，为物体的整体质量管理和评估提供可靠支持。",
      "label": "package MassRollup1 {\n\tprivate import NumericalFunctions::*;\n\t\n\tpart def MassedThing {\n\t\tattribute simpleMass :> ISQ::mass; \n\t\tattribute totalMass :> ISQ::mass;\n\t}\n\t\n\tpart simpleThing : MassedThing {\n\t\tattribute :>> totalMass = simpleMass;\n\t}\n\t\n\tpart compositeThing : MassedThing {\n\t\tpart subcomponents: MassedThing[*];\t\t\n\t\tattribute :>> totalMass =\n\t\t\tsimpleMass + sum(subcomponents.totalMass); \n\t}\n\t\n}"
    },
    {
      "name": "Car Mass Rollup Example 1",
      "text": "系统应支持对车辆及其部件的质量进行自动汇总，以实现车辆整体质量的精确管理。车辆包含多个部件，每个部件具有唯一的序列号，并记录在车辆的总成中。车辆的主要部件包括引擎和传动系统，分别具有独立的质量属性。系统应能够计算车辆的总质量，通过累加各部件的质量得出总值。车辆的整体质量包含车辆本身的质量，以及引擎和传动系统等子部件的质量之和。例如，若车辆的质量为1000千克，引擎质量为100千克，传动系统质量为50千克，则系统应计算出车辆的总质量为1150千克。通过该自动汇总功能，系统确保所有部件的质量数据能够被准确记录和计算，为车辆的整体质量管理提供可靠支持。",
      "label": "package 'Car Mass Rollup Example 1' {\n\tprivate import ScalarValues::*;\n\tprivate import MassRollup1::*;\n\t\n\tpart def CarPart :> MassedThing {\t\t\t\n\t\tattribute serialNumber: String;\n\t}\n\t\n\tpart car: CarPart :> compositeThing {\t\n\t\tattribute vin :>> serialNumber;\n\t\t\n\t\tpart carParts: CarPart[*] :>> subcomponents;\n\t\t\n\t\tpart engine :> simpleThing, carParts {\n\t\t\t//...\n\t\t}\n\t\t\n\t\tpart transmission :> simpleThing, carParts {\n\t\t\t//...\n\t\t}\n\t}\n\n\t// Example usage\n\t\n\tprivate import SI::kg;\n\tpart c :> car {\n\t\tattribute :>> simpleMass = 1000[kg];\n\t\tpart :>> engine {\n\t\t\tattribute :>> simpleMass = 100[kg];\n\t\t}\n\t\t\n\t\tpart redefines transmission {\n\t\t\tattribute :>> simpleMass = 50[kg];\n\t\t}\t\n\t}\n\t\n\t// c::totalMass --> 1150.0[kg]\n}"
    },
    {
      "name": "Car Mass Rollup Example 2",
      "text": "系统应具备对车辆及其所有组成部件的质量进行自动汇总，以实现车辆整体质量的精确管理。车辆包含多个关键部件，并将这些部件作为子组件集合的一部分统一管理。车辆的主要部件包括引擎和传动系统，且每个部件均记录了其质量和唯一的序列号信息。系统应能够自动累加各个部件的质量值，从而计算出车辆的总质量。例如，车辆实例的质量为1000千克，引擎质量为100千克，传动系统质量为50千克，系统在汇总后应显示车辆的总质量为1150千克。该质量汇总功能确保车辆各部件的质量信息能够被精确记录并动态计算，为车辆的整体质量评估提供可靠的数据支撑，确保在构造和操作过程中车辆的质量状态清晰可见。",
      "label": "package 'Car Mass Rollup 1' {\n\tprivate import ScalarValues::*;\n\tprivate import MassRollup2::*;\n\t\n\tpart def CarPart :> MassedThing {\t\t\t\n\t\tattribute serialNumber: String;\n\t}\n\t\n\tpart car: CarPart :> compositeThing {\t\n\t\tattribute vin :>> serialNumber;\n\t\t\n\t\tpart carParts: CarPart[*] :>> subcomponents;\n\t\t\n\t\tpart engine :> carParts {\n\t\t\t//...\n\t\t}\n\t\t\n\t\tpart transmission :> carParts {\n\t\t\t//...\n\t\t}\n\t}\n\n\t// Example usage\n\t\n\tprivate import SI::kg;\n\tpart c :> car {\n\t\tattribute :>> simpleMass = 1000[kg];\n\t\tpart :>> engine {\n\t\t\tattribute :>> simpleMass = 100[kg];\n\t\t}\n\t\t\n\t\tpart redefines transmission {\n\t\t\tattribute :>> simpleMass = 50[kg];\n\t\t}\t\n\t}\n\t\n\t// c::totalMass --> 1150.0[kg]\n}"
    },
    {
      "name": "Subsetting Example",
      "text": "系统应定义一个车辆实体，包含多个部件，其中每个部件属于车辆部件的整体集合。\n车辆应包括一个引擎、一个传动系统和四个轮子，这些部件都从车辆部件集合中派生。\n引擎和传动系统作为车辆部件集合的子集，而四个轮子也作为集合的组成部分，以实现车辆的完整结构\n和功能配置。",
      "label": "package 'Subsetting Example' {\n\t\n\tpart def Vehicle {\n\t\tpart parts : VehiclePart[*];\n\t\t\n\t\tpart eng : Engine subsets parts;\n\t\tpart trans : Transmission subsets parts;\n\t\tpart wheels : Wheel[4] :> parts;\n\t}\n\t\n\tabstract part def VehiclePart;\n\tpart def Engine :> VehiclePart;\n\tpart def Transmission :> VehiclePart;\n\tpart def Wheel :> VehiclePart;\n}"
    },
    {
      "name": "Action Succession Example-2",
      "text": "系统应定义一个拍照操作流程，将场景作为输入并生成图片作为输出。该流程包括聚焦和拍摄两个步骤。首先，拍照流程中的聚焦操作应接收场景作为输入，并输出一个图像。随后，图像通过顺序流传递至拍摄操作，以生成最终的图片输出。在绑定关系中，聚焦操作的场景输入应与拍照流程的场景输入一致，拍摄操作的图片输出应绑定为拍照流程的图片输出，从而确保整个拍照过程的连贯性和数据的顺畅传递。",
      "label": "package 'Action Definition Example' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\t\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\t\t\t\t\n\taction def TakePicture {\n\t\tin item scene : Scene;\n\t\tout item picture : Picture;\n\t\t\n\t\tbind focus.scene = scene;\n\t\t\n\t\taction focus: Focus { in scene; out image; }\n\t\t\n\t\tsuccession flow from focus.image to shoot.image;\n\t\t\n\t\taction shoot: Shoot { in image; out picture; }\n\t\t\n\t\tbind shoot.picture = picture;\n\t}\n\t\n}"
    },
    {
      "name": "Action Definition Example",
      "text": "系统应定义一个拍照操作流程，以实现从场景捕捉到图片生成的完整拍摄过程。拍照流程的输入为场景，输出为最终的图片。该流程应包括两个主要子操作：聚焦和拍摄。首先，系统应执行聚焦操作，接收场景作为输入，并生成一个图像；然后，图像应传递至拍摄操作，进一步处理生成最终的图片。拍照流程中，聚焦操作的场景输入应与拍照流程的场景输入绑定，拍摄操作的图片输出应与拍照流程的图片输出绑定，以确保数据流的顺畅衔接，实现完整的图像捕捉和输出。",
      "label": "package 'Action Definition Example' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\t\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\t\t\n\taction def TakePicture { in scene : Scene; out picture : Picture;\n\t\tbind focus.scene = scene;\n\t\t\n\t\taction focus: Focus { in scene; out image; }\n\t\t\n\t\tflow from focus.image to shoot.image;\n\t\t\n\t\taction shoot: Shoot { in image; out picture; }\n\t\t\n\t\tbind shoot.picture = picture;\n\t}\n\t\n}"
    },
    {
      "name": "Action Shorthand Example",
      "text": "系统应定义一个简化的拍照操作流程，从场景输入到最终图片输出，包含聚焦和拍摄两个主要步骤。在拍照流程中，场景作为输入项，图片作为输出项。首先，系统应执行聚焦操作，使用拍照流程的场景输入来生成一个图像输出；图像输出应流向拍摄步骤。接着执行拍摄操作，以生成最终的图片输出，并将其绑定到拍照流程的图片输出项，从而完成图像捕捉到图片生成的完整过程。",
      "label": "package 'Action Shorthand Example' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\t\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\t\t\t\t\n\taction def TakePicture {\n\t\tin item scene : Scene;\n\t\tout item picture : Picture;\n\t\t\n\t\taction focus: Focus {\n\t\t\tin item scene = TakePicture::scene;\n\t\t\tout item image;\n\t\t}\n\t\t\n\t\tflow from focus.image to shoot.image;\n\t\t\n\t\tthen action shoot: Shoot {\n\t\t\tin item;\n\t\t\tout item picture = TakePicture::picture;\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Action Succession Example-1",
      "text": "系统应定义一个拍照操作流程，通过聚焦和拍摄的连续步骤，将场景转换为最终的图片。拍照流程的输入为场景，输出为图片。首先，执行聚焦操作，接收场景作为输入并生成图像输出。该图像随后流入拍摄操作，并用于生成最终的图片输出。在操作顺序上，拍照流程应先执行聚焦操作，然后执行拍摄操作，以确保操作流程的顺序性和完整性。聚焦的场景输入和拍摄的图片输出应分别与拍照流程的场景输入和图片输出绑定，从而实现整个拍摄过程的流畅衔接和数据传递。",
      "label": "package 'Action Succession Example-1' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\t\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\t\t\t\t\n\taction def TakePicture {\n\t\tin item scene : Scene;\n\t\tout item picture : Picture;\n\t\t\n\t\tbind focus.scene = scene;\n\t\t\n\t\taction focus: Focus { in scene; out image; }\n\t\t\n\t\tflow from focus.image to shoot.image;\n\t\t\n\t\tfirst focus then shoot;\n\t\t\n\t\taction shoot: Shoot { in image; out picture; }\n\t\t\n\t\tbind shoot.picture = picture;\n\t}\n\t\n}"
    },
    {
      "name": "State Decomposition-2",
      "text": "系统应定义一个车辆状态管理流程，其中包括并行的“操作状态”和“健康状态”两个状态组，以实现对车辆的多重状态管理。在“操作状态”中，初始状态为“关闭”。当接收到启动信号时，状态从“关闭”转换为“启动中”；当接收到开启信号后，状态从“启动中”进一步转换为“开启”。在“开启”状态中，若系统接收到关闭信号，状态将返回到“关闭”。此外，“健康状态”将并行运行，负责监控和管理车辆的健康参数（具体行为留待定义）。通过这种并行状态分解，系统能够同时管理车辆的操作状态和健康状态，以确保车辆的正常运行和安全监控。",
      "label": "package 'State Decomposition-1' {\n\t\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\t\n\tstate def VehicleStates;\n\t\t\n\tstate vehicleStates : VehicleStates parallel {\n\t\t\n\t\tstate operationalStates {\n\t\t\tentry; then off;\n\t\t\t\n\t\t\tstate off;\n\t\t\taccept VehicleStartSignal \n\t\t\t\tthen starting;\n\t\t\t\t\n\t\t\tstate starting;\n\t\t\taccept VehicleOnSignal\n\t\t\t\tthen on;\n\t\t\t\t\n\t\t\tstate on;\n\t\t\taccept VehicleOffSignal\n\t\t\t\tthen off;\n\t\t}\n\t\t\n\t\tstate healthStates { \n\t\t\t/* ... */\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "State Actions",
      "text": "系统应定义一个车辆状态管理流程，控制车辆在“关闭”、“启动中”和“开启”状态之间的转换，并在“开启”状态中执行特定操作。初始状态为“关闭”，当接收到启动信号时，车辆状态从“关闭”切换到“启动中”；接收到开启信号后，状态进一步转换为“开启”。在“开启”状态时，系统应执行一系列操作：进入该状态时，车辆应进行自检，确保其正常运行；在状态持续期间，系统应提供动力；当退出该状态时，应执行停车制动操作，确保车辆安全停放。在车辆处于“开启”状态时，若接收到关闭信号，则状态从“开启”切换回“关闭”。此流程确保车辆在不同操作信号下进行安全和可靠的状态转换与操作执行。",
      "label": "package 'State Actions' {\n\t\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\t\n\tpart def Vehicle;\n\t\n\taction performSelfTest { in vehicle : Vehicle; }\n\t\n\tstate def VehicleStates { in operatingVehicle : Vehicle; }\n\t\t\n\tstate vehicleStates : VehicleStates {\n\t\tin operatingVehicle : Vehicle;\n\t\t\t\n\t\tentry; then off;\n\t\t\n\t\tstate off;\n\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\t\t\n\t\tstate starting;\n\t\taccept VehicleOnSignal\n\t\t\tthen on;\n\t\t\t\n\t\tstate on {\n\t\t\tentry performSelfTest{ in vehicle = operatingVehicle; }\n\t\t\tdo action providePower { /* ... */ }\n\t\t\texit action applyParkingBrake { /* ... */ }\n\t\t}\n\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\t}\n\t\n}"
    },
    {
      "name": "State Decomposition-1",
      "text": "系统应定义一个车辆状态管理流程，通过“关闭”、“启动中”和“开启”状态的转换实现对车辆的控制。系统的初始状态为“关闭”。当接收到启动信号时，车辆状态从“关闭”转换为“启动中”；当接收到开启信号后，状态从“启动中”进一步转换为“开启”。在“开启”状态时，若系统接收到关闭信号，则状态将从“开启”切换回“关闭”。此状态分解流程确保车辆在接收到不同操作信号时能够顺序、安全地完成状态转换。",
      "label": "package 'State Decomposition-1' {\n\t\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\t\n\tstate def VehicleStates;\n\t\t\n\tstate vehicleStates : VehicleStates {\n\t\tentry; then off;\n\t\t\n\t\tstate off;\n\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\t\t\n\t\tstate starting;\n\t\taccept VehicleOnSignal\n\t\t\tthen on;\n\t\t\t\n\t\tstate on;\n\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\t}\n\t\n}"
    },
    {
      "name": "State Exhibition Example",
      "text": "系统应定义一个车辆状态展示流程，以使车辆及其控制器的状态行为在系统中可见。该流程在车辆组件中包含一个车辆控制器，并将“车辆状态”行为实例化，以便展示车辆的状态变化。状态展示流程接收车辆作为“操作中的车辆”，并接收车辆控制器作为控制器，从而使得车辆状态管理流程的每个状态和转换在车辆运行过程中得以呈现。这一展示结构确保系统在车辆及其控制器的运行中能够实时监控和显示状态信息，为操作和调试提供可视化支持。",
      "label": "package 'State Exhibition Example' {\n\tprivate import 'Transition Actions'::*;\n\t\n\tpart vehicle : Vehicle {\n\t\t\n\t\tpart vehicleController : VehicleController;\n\t\t\n\t\texhibit vehicleStates {\n\t\t\tin operatingVehicle = vehicle;\n\t\t\tin controller = vehicleController;\n\t\t}\n\n\t}\n\t\n}"
    },
    {
      "name": "Flow Connection Interface Example",
      "text": "系统应定义一个燃料接口，用于管理燃料在供应端和消耗端之间的双向流动。燃料接口应包括一个供应端口和一个消耗端口，以便支持燃料的传输。燃料的流动应包含从供应端口的燃料供应项到消耗端口的燃料供应项的正向流动，以及从消耗端口的燃料回流项到供应端口的燃料回流项的反向流动。车辆部件应包含一个燃料箱组件和一个发动机组件，通过燃料接口连接燃料箱的输出端口与发动机的输入端口，以确保燃料的传递和未使用燃料的回流，从而支持发动机的持续运作。",
      "label": "package 'Flow Connection Interface Example' {\n\tprivate import 'Port Example'::*;\n\t\n\tpart def Vehicle;\n\t\n\tinterface def FuelInterface {\n\t\tend supplierPort : FuelOutPort;\n\t\tend consumerPort : FuelInPort;\n\t\t\n\t\tflow supplierPort.fuelSupply to consumerPort.fuelSupply;\t\t\t\n\t\tflow consumerPort.fuelReturn to supplierPort.fuelReturn;\n\t}\n\t\n\tpart vehicle : Vehicle {\t\n\t\tpart tankAssy : FuelTankAssembly;\t\t\n\t\tpart eng : Engine;\n\t\t\n\t\tinterface : FuelInterface connect \n\t\t\tsupplierPort ::> tankAssy.fuelTankPort to \n\t\t\tconsumerPort ::> eng.engineFuelPort;\n\t} \n}"
    },
    {
      "name": "Flow Connection Usage Example",
      "text": "系统应定义一个燃料流动机制，以确保燃料在车辆的燃料箱组件和发动机之间进行双向传输。燃料的流动应包含从燃料箱组件的燃料供应端口到发动机的燃料供应端口的正向流动，以支持燃料供给。同时，系统还应定义从发动机的燃料回流端口到燃料箱组件的燃料回流端口的逆向流动，以便回收未使用的燃料，实现燃料的循环利用，从而确保发动机的持续供能和高效运行。",
      "label": "package 'Flow Connection Interface Example' {\n\tprivate import 'Port Example'::*;\n\t\n\tpart def Vehicle;\n\t\n\tpart vehicle : Vehicle {\n\t\tpart tankAssy : FuelTankAssembly;\n\t\tpart eng : Engine;\n\t\t\n\t\tflow of Fuel\n\t\t  from tankAssy.fuelTankPort.fuelSupply\n\t\t\tto eng.engineFuelPort.fuelSupply;\n\t\t\t\n\t\tflow of Fuel\n\t\t  from eng.engineFuelPort.fuelReturn\n\t\t\tto tankAssy.fuelTankPort.fuelReturn;\n\t} \n}"
    },
    {
      "name": "Flow Connection Definition Example",
      "text": "系统应定义一个燃料流，以管理燃料在供应端和消耗端之间的传输。燃料流应包括一个燃料的引用作为传输载荷，同时包含一个供应端口和一个消耗端口。车辆部件应配置一个燃料箱组件和一个发动机组件，燃料流应从燃料箱端口的燃料供应项传输至发动机端口的燃料供应项，以确保燃料的连续传递，支持发动机的正常运行。",
      "label": "package 'Flow Connection Definition Example' {\n\tprivate import 'Port Example'::*;\n\t\n\tpart def Vehicle;\n\t\n\tflow def FuelFlow {\n\t\tref :>> payload : Fuel;\n\t\tend port supplierPort : FuelOutPort;\n\t\tend port consumerPort : FuelInPort;\n\t}\n\t\n\tpart vehicle : Vehicle {\n\t\tpart tankAssy : FuelTankAssembly;\n\t\tpart eng : Engine;\n\t\t\n\t\tflow : FuelFlow\n\t\t  from tankAssy.fuelTankPort.fuelSupply\n\t\t\tto eng.engineFuelPort.fuelSupply;\n\t\t\t\n\t} \n}"
    },
    {
      "name": "Assignment Example",
      "text": "系统应定义一个运动计算流程，用于计算物体在一系列功率配置下的直线运动轨迹。该流程接收功率配置、物体质量、初始位置、初始速度和时间增量作为输入，并输出每个时间增量下的位置序列。系统应在循环中依次遍历功率配置的各项，使用“直线动力学”操作来计算当前功率下的物体位置和速度变化。在每次迭代中，当前的功率、物体质量、时间增量、当前位置和当前速度输入至“直线动力学”操作，生成更新后的位置和速度。随后，更新的位置将存储在位置序列中，以记录整个运动过程。通过该循环操作，系统能够逐步计算并记录物体的动态位置，实现连续的运动轨迹跟踪。",
      "label": "package 'For Loop Example' {\n\tprivate import SequenceFunctions::*;\n\t\n    action def StraightLineDynamics {\n        in power : ISQ::PowerValue;\n        in mass : ISQ::MassValue;\n        in delta_t : ISQ::TimeValue;\n        in x_in : ISQ::LengthValue;\n        in v_in : ISQ::SpeedValue;\n        out x_out : ISQ::LengthValue;\n        out v_out : ISQ::SpeedValue;\n    }\n\t    \n\taction def ComputeMotion {\n\t\tin attribute powerProfile :> ISQ::power[*];\n\t\tin attribute vehicleMass :> ISQ::mass;\n\t\tin attribute initialPosition :> ISQ::length;\n\t\tin attribute initialSpeed :> ISQ::speed;\n\t\tin attribute deltaT :> ISQ::time;\n\t\tout attribute positions :> ISQ::length[*] := ( );\n\t\t\n\t\tprivate attribute position := initialPosition;\n\t\tprivate attribute speed := initialSpeed;\n\t\t\n\t\tfor i in 1..powerProfile->size() {\n\t\t\tperform action dynamics : StraightLineDynamics {\n\t\t\t\tin power = powerProfile#(i);\n\t\t\t\tin mass = vehicleMass;\n\t\t\t\tin delta_t = deltaT;\n\t\t\t\tin x_in = position;\n\t\t\t\tin v_in = speed;\n\t\t\t\tout x_out;\n\t\t\t\tout v_out;\n\t\t\t}\n\t\t\tthen assign position := dynamics.x_out;\n\t\t\tthen assign speed := dynamics.v_out;\n\t\t\tthen assign positions := positions->including(position);\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Enumeration Definitions-2",
      "text": "系统应定义一个分类级别属性，该属性包含代码和颜色两个子属性，用于表示不同的分类等级。\n分类级别的种类应包括“未分类”、“机密”和“秘密”，其中每个种类均对应特定的代码和颜色值：\n“未分类”代码为“uncl”，颜色为绿色；“机密”代码为“conf”，颜色为黄色；“秘密”代码为“secr”，\n颜色为红色。此外，系统应定义一个与绩点相关的枚举，以表示不同等级的分数，包含A至F五个等级，\n分别对应绩点4.0至0.0。",
      "label": "package 'Enumeration Definitions-2' {\n\tprivate import ScalarValues::*;\n\tprivate import 'Enumeration Definitions-1'::*;\n\t\n\tattribute def ClassificationLevel {\n\t\tattribute code : String;\n\t\tattribute color : TrafficLightColor;\n\t}\n\t\n\tenum def ClassificationKind specializes ClassificationLevel {\n\t\tunclassified {\n\t\t\t:>> code = \"uncl\";\n\t\t\t:>> color = TrafficLightColor::green;\n\t\t}\n\t\tconfidential {\n\t\t\t:>> code = \"conf\";\n\t\t\t:>> color = TrafficLightColor::yellow;\n\t\t}\n\t\tsecret {\n\t\t\t:>> code = \"secr\";\n\t\t\t:>> color = TrafficLightColor::red;\n\t\t}\n\t}\n\t\n\tenum def GradePoints :> Real {\n\t\tA = 4.0;\n\t\tB = 3.0;\n\t\tC = 2.0;\n\t\tD = 1.0;\n\t\tF = 0.0;\n\t}\n}"
    },
    {
      "name": "Enumeration Definitions-1",
      "text": "系统应定义一个交通信号灯实体，该信号灯具有一个颜色属性，用于表示当前的灯光状态。\n颜色属性的值应基于交通信号灯颜色的枚举定义，包括绿色、黄色和红色三种状态。\n对于交通信号灯的“通行”模式，应将当前颜色重新定义为绿色，以指示车辆可以通过的状态。",
      "label": "package 'Enumeration Definitions-1' {\n\tprivate import ScalarValues::Real;\n\t\n\tenum def TrafficLightColor {\n\t\tenum green;\n\t\tenum yellow;\n\t\tenum red;\n\t}\n\t\n\tpart def TrafficLight {\n\t\tattribute currentColor : TrafficLightColor;\n\t}\n\t\n\tpart def TrafficLightGo specializes TrafficLight {\n\t\tattribute redefines currentColor = TrafficLightColor::green;\n\t}\n}"
    },
    {
      "name": "Filtering Example-2",
      "text": "系统应支持对车辆部件的安全性进行分类和筛选，以便识别并管理与安全相关的关键部件。vehicle结构中定义的部件包括安全带、保险杠、驾驶员气囊和防抱死刹车系统等，每个安全相关部件都通过@Safety元数据进行标记，并指明其是否为强制性安全项（isMandatory）。强制性安全项如座椅安全带和保险杠，在车辆中起到关键的保护作用，而非强制性安全项如驾驶员气囊和防抱死刹车系统则提供额外的安全保护，但在特定配置中可能并非标配。\n\n系统组织了两个包来管理这些部件：Safety Features和Mandatory Safety Features。Safety Features包包含所有标记为安全部件的组件，用于汇总所有安全相关的配置项；Mandatory Safety Features包则只包含那些既具安全属性又被标记为强制性的部件，以满足合规性检查和强制性配置的要求。\n\n此筛选功能使系统能够精确区分和管理安全性相关的车辆部件，从而在不同设计和应用场景中高效地识别必要的安全配置。这种安全管理机制为车辆的设计、制造和质量验证提供了可靠的支持，确保所有安全配置符合规范并满足必要的保护要求。",
      "label": "package 'Filtering Example-2' {\n\tprivate import ScalarValues::Boolean;\n\t\n\tmetadata def Safety {\n\t\tattribute isMandatory : Boolean;\n\t}\n\t\n\tpart vehicle {\n\t\tpart interior {\n\t\t\tpart alarm;\n\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\tpart frontSeat[2];\n\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t}\n\t\tpart bodyAssy {\n\t\t\tpart body;\n\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\tpart keylessEntry;\n\t\t}\n\t\tpart wheelAssy {\n\t\t\tpart wheel[2];\n\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t}\n\t}\n\t\n\tpackage 'Safety Features' {\n\t\t/* Parts that contribute to safety. */\t\t\n\t\tprivate import vehicle::**[@Safety];\n\t}\n\t\n\tpackage 'Mandatory Safety Features' {\n\t\t/* Parts that contribute to safety AND are mandatory. */\n\t\tprivate import vehicle::**[@Safety and Safety::isMandatory];\n\t}\n}"
    },
    {
      "name": "Filtering Example-1",
      "text": "系统应支持车辆部件的安全性分类和筛选功能，以便明确各部件的安全属性和重要性。在车辆部件的定义中，通过@Safety元数据标记每个与安全相关的组件，并指明该组件是否为强制性安全项。强制性安全项包括对乘客和驾驶员保护至关重要的部件，而非强制性项则提供额外的安全保障。\n\n在vehicle结构中，座椅安全带（seatBelt）和保险杠（bumper）被标记为强制性安全项（isMandatory = true），确保它们在所有车辆中均为必备部件。非强制性安全项包括驾驶员气囊（driverAirBag）和防抱死刹车系统（antilockBrakes），这些部件增强了安全性，但在特定车型中可能并非标配。\n\n系统根据不同的安全筛选需求组织了两个包：Safety Features和Mandatory Safety Features。Safety Features包包含所有带有安全元数据标记的部件，用于列出与安全相关的全部配置项；Mandatory Safety Features包则仅包含那些既具安全属性又是强制性的部件，以支持合规性验证和强制安全配置的检查。\n\n此筛选功能确保系统能够精确追踪和分类与安全相关的部件，并支持在不同应用场景中快速识别强制性安全配置，为车辆设计和验证提供了可靠的安全管理支持。",
      "label": "package 'Filtering Example-1' {\n\tprivate import ScalarValues::Boolean;\n\t\n\tmetadata def Safety {\n\t\tattribute isMandatory : Boolean;\n\t}\n\t\n\tpart vehicle {\n\t\tpart interior {\n\t\t\tpart alarm;\n\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\tpart frontSeat[2];\n\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t}\n\t\tpart bodyAssy {\n\t\t\tpart body;\n\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\tpart keylessEntry;\n\t\t}\n\t\tpart wheelAssy {\n\t\t\tpart wheel[2];\n\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t}\n\t}\n\t\n\tpackage 'Safety Features' {\n\t\t/* Parts that contribute to safety. */\t\t\n\t\tprivate import vehicle::**;\n\t\tfilter @Safety;\n\t}\n\t\n\tpackage 'Mandatory Safety Features' {\n\t\t/* Parts that contribute to safety AND are mandatory. */\n\t\tprivate import vehicle::**;\n\t\tfilter @Safety and Safety::isMandatory;\n\t}\n}"
    },
    {
      "name": "Time Constraints",
      "text": "系统应确保车辆的维护周期和状态转换符合预定的时间要求，以支持按时、合理的车辆运维管理。当达到设定的维护时间点时，车辆应自动从“正常”状态切换到“维护”状态，并验证维护开始时间晚于设定时间，同时保证从“正常”状态完成到进入“维护”状态的转换间隔不超过2秒，以确保转换的及时性。在进入“维护”状态时，系统应自动更新下次维护时间，通过将当前维护时间与设定的维护间隔相加，为下一次维护安排时间。每次维护的持续时间不得超过48小时，以确保高效维护并尽快恢复车辆的正常运行状态。这些时间约束功能为车辆的健康管理提供了自动化、准确的时间监控，确保车辆维护的及时性和操作的高效性。",
      "label": "package 'Time Constraints' {\n\tprivate import ISQ::TemperatureValue;\n\tprivate import ISQ::DurationValue;\n\tprivate import Time::TimeInstantValue;\n\tprivate import Time::TimeOf;\n\tprivate import Time::DurationOf;\n\tprivate import SI::h;\n\tprivate import SI::s;\n\n\tattribute def MaintenanceDone;\n\t\n\tpart def Vehicle {\n\t\tattribute maintenanceTime : TimeInstantValue;\n\t\tattribute maintenanceInterval : DurationValue;\n\t\tattribute maxTemperature : TemperatureValue;\n\t}\n\t\n\tstate healthStates {\n\t\tin vehicle : Vehicle;\n\t\t\n\t\tentry; then normal;\n\t\t\n\t\tstate normal;\n\t\taccept at vehicle.maintenanceTime\n\t\t\tthen maintenance;\n\t\t\n\t\tstate maintenance {\n\t\t\tassert constraint { TimeOf(maintenance) > vehicle.maintenanceTime }\n\t\t\tassert constraint { TimeOf(maintenance) - TimeOf(normal.done) < 2 [s] }\n\t\t\tentry assign vehicle.maintenanceTime := vehicle.maintenanceTime + vehicle.maintenanceInterval;\n\t\t}\n\t\taccept MaintenanceDone\n\t\t\tthen normal;\n\t\t\n\t\tconstraint { DurationOf(maintenance) <= 48 [h] }\n\t}\n}"
    },
    {
      "name": "Constraint Assertions-1",
      "text": "系统应具备对车辆及其组件的质量约束管理功能，以确保车辆的总质量符合指定的限制。系统应设置一个质量约束条件，用于验证车辆的各部件质量总和是否在规定的质量上限之内。具体来说，车辆的质量上限应设定为2500千克，涵盖车身、引擎和传动系统的总质量。\n\n在车辆实例中，系统应对各个部件的质量进行定义，并将这些质量值传递到质量约束中进行汇总计算。约束条件通过将车身质量、引擎质量和传动系统质量相加，与质量上限进行比较。如果各部件的质量总和未超过2500千克，则车辆满足质量约束要求；若超过此上限，则系统标记该配置为不符合质量标准。\n\n此质量管理功能为车辆配置提供了自动化的验证支持，确保车辆设计符合重量限制要求，有助于实现车辆的安全和性能标准。通过质量约束的设定，系统能够在设计和生产过程中实时监控并验证车辆的质量合规性。",
      "label": "package 'Constraint Assertions-1' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\t\n\tpart def Engine;\n\tpart def Transmission;\n\t\n\tconstraint def MassConstraint {\n\t\tin partMasses : MassValue[0..*];\n\t\tin massLimit : MassValue;\n\t\t\t\n\t\tsum(partMasses) <= massLimit\n\t}\n\t\n\tpart def Vehicle {\n\t\tassert constraint massConstraint : MassConstraint {\n\t\t\tin partMasses = (chassisMass, engine.mass, transmission.mass);\n\t\t\tin massLimit = 2500[kg];\n\t\t}\n\t\t\n\t\tattribute chassisMass : MassValue;\n\t\t\n\t\tpart engine : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\t\n\t\tpart transmission : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t}\t\n}"
    },
    {
      "name": "Constraints Example-1",
      "text": "系统应具备质量约束条件，用于验证车辆的总质量是否在规定的上限之内，以确保设计合规性。该质量约束条件要求，车辆的关键部件（包括车身、引擎和传动系统）的质量之和不应超过2500千克。\n\n在车辆配置中，系统应记录车身质量（chassisMass）、引擎质量和传动系统质量，并将这些质量值输入到质量约束中进行计算。质量约束条件将各部件的质量累加，并将总和与2500千克的质量上限进行比较，以确定是否符合标准。若总质量在2500千克以内，则车辆满足质量标准；若超出该限制，则系统标记此配置为不符合质量要求。\n\n该质量管理功能通过自动化验证，确保车辆的设计在安全和性能上符合重量要求，使车辆配置过程更加可靠且符合规范。系统的实时质量监控和约束检查支持车辆在各个开发阶段的合规性管理，有助于提升设计和制造的精确性与安全性。",
      "label": "package 'Constraints Example-1' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\t\n\tpart def Engine;\n\tpart def Transmission;\n\t\n\tconstraint def MassConstraint {\n\t\tin partMasses : MassValue[0..*];\n\t\tin massLimit : MassValue;\n\t\t\t\n\t\tsum(partMasses) <= massLimit\n\t}\n\t\n\tpart def Vehicle {\n\t\tconstraint massConstraint : MassConstraint {\n\t\t\tin partMasses = (chassisMass, engine.mass, transmission.mass);\n\t\t\tin massLimit = 2500[kg];\n\t\t}\n\t\t\n\t\tattribute chassisMass : MassValue;\n\t\t\n\t\tpart engine : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\t\n\t\tpart transmission : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t}\n}"
    },
    {
      "name": "Constraint Assertions-2",
      "text": "系统应确保车辆及其关键部件的总质量在设定的质量上限内，通过质量约束条件对车辆的质量配置进行验证。该质量约束要求车辆的总质量，包括车身、引擎和传动系统的质量之和，不得超过2500千克。\n\n在车辆配置中，系统将车身质量、引擎质量和传动系统质量作为输入，传递至质量约束进行验证。质量约束的计算逻辑将各部件的质量累加，与预设的质量上限进行比较，确保车辆的总质量不超出限制。若各部件的质量之和不超过2500千克，则车辆符合质量标准；若超出限制，则系统会标记此配置为不合规。\n\n该质量约束为车辆设计提供了自动化的合规验证，确保车辆符合重量要求，以达到安全和性能的设计标准。通过实时的质量监控和约束验证，系统能够支持车辆的质量合规性管理，助力车辆设计和制造过程的精确控制。",
      "label": "package 'Constraint Assertions-2' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\t\n\tpart def Engine;\n\tpart def Transmission;\n\t\n\tconstraint def MassConstraint {\n\t\tin partMasses : MassValue[0..*];\n\t\tin massLimit : MassValue;\n\t}\n\t\n\tconstraint massConstraint : MassConstraint {\n\t\tin partMasses : MassValue[0..*];\n\t\tin massLimit : MassValue;\n\t\t\t\n\t\tsum(partMasses) <= massLimit\n\t}\n\t\n\tpart def Vehicle {\n\t\tassert massConstraint {\n\t\t\tin partMasses = (chassisMass, engine.mass, transmission.mass);\n\t\t\tin massLimit = 2500[kg];\n\t\t}\n\t\t\n\t\tattribute chassisMass : MassValue;\n\t\t\n\t\tpart engine : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\t\n\t\tpart transmission : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t}\t\n}"
    },
    {
      "name": "Derivation Constraints",
      "text": "系统应支持派生质量和动力学的约束验证，以确保车辆的质量合规性和动力学行为符合物理模型。该约束包括以下需求：\n\n车辆质量的派生验证：系统应确保车辆实例的总质量与其各部件质量之和相符。在vehicle1中，系统通过约束声明来验证总质量是否等于车身、引擎和传动系统的质量累加值。在vehicle2中，系统直接将总质量定义为车身、引擎和传动系统质量的和，以确保质量属性的正确派生和一致性。\n\n动力学约束：系统应具备动力学约束，以验证车辆在特定条件下的运动方程是否成立。动力学约束要求系统在给定的质量、初速度、末速度、时间增量和力的条件下，满足动量定理关系，即力与时间的积等于质量和速度变化的乘积。此外，该约束还规定质量必须大于零，以确保计算的物理合理性。\n\n通过这些派生约束，系统能够在车辆配置过程中验证总质量的计算准确性，并在动力学模拟中确保遵循物理定律。此功能为车辆设计、性能验证和安全评估提供了坚实的数据基础和验证支持，确保车辆配置的可靠性和精确性。",
      "label": "package 'Derivation Constraints' {\n\tprivate import SI::*;\n\tprivate import 'Constraints Example-1'::*;\n\t\n\tpart vehicle1 : Vehicle {\n\t\tattribute totalMass : MassValue;\t\t\t\n\t\tassert constraint {totalMass == chassisMass + engine.mass + transmission.mass}\t\n\t}\n\t\n\tpart vehicle2 : Vehicle {\n\t\tattribute totalMass : MassValue = chassisMass + engine.mass + transmission.mass;\n\t}\n\t\n\tconstraint def Dynamics {\n\t\tin mass: MassValue;\n\t\tin initialSpeed : SpeedValue;\n\t\tin finalSpeed : SpeedValue;\n\t\tin deltaT : TimeValue;\n\t\tin force : ForceValue;\n\n\t\tforce * deltaT == mass * (finalSpeed - initialSpeed) and\n\t\tmass > 0[kg]\n\t}\n\t\n}"
    },
    {
      "name": "Constraints Example-2",
      "text": "系统应具备质量约束功能，用于验证车辆的总质量符合预设的上限要求，以确保车辆的安全性和性能达标。该质量约束要求，车辆的总质量，包括车身、引擎和传动系统的质量总和，不得超过2500千克。\n\n在车辆配置中，系统应记录车身质量（chassisMass）、引擎质量和传动系统质量，并将这些值作为质量约束的输入属性。通过重新定义约束中的部件质量和质量上限，系统将车辆的所有部件质量进行累加，并与设定的2500千克上限进行比较。如果总质量在上限之内，则车辆符合质量标准；若超出上限，则系统会标记该配置为不合规。\n\n此质量约束功能为车辆设计提供了实时的自动化验证，确保各部件质量配置满足规定的安全和性能标准。通过这一约束机制，系统能够在车辆设计和制造过程中有效管理质量合规性，为车辆的精确配置提供可靠的质量数据支持。",
      "label": "package 'Constraints Example-2' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\t\n\tpart def Engine;\n\tpart def Transmission;\n\t\n\tconstraint def MassConstraint {\n\t\tattribute partMasses : MassValue[0..*];\n\t\tattribute massLimit : MassValue;\n\t\t\t\n\t\tsum(partMasses) <= massLimit\n\t}\n\t\n\tpart def Vehicle {\n\t\tconstraint massConstraint : MassConstraint {\n\t\t\tredefines partMasses = (chassisMass, engine.mass, transmission.mass);\n\t\t\tredefines massLimit = 2500[kg];\n\t\t}\n\t\t\n\t\tattribute chassisMass : MassValue;\n\t\t\n\t\tpart engine : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\t\n\t\tpart transmission : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t}\n}"
    },
    {
      "name": "Analytical Constraints",
      "text": "系统应支持直线动力学的解析约束，以验证车辆在特定功率、质量、时间增量、初始位置和速度条件下的动力学一致性。直线动力学方程的约束应确保加速度、速度和位置之间满足物理关系，以保证系统的准确性。约束条件包括以下关系：\n\n平均速度：系统应计算初始速度和最终速度的平均值，用于加速度和位置的进一步计算。\n\n加速度约束：计算的加速度值应符合Acceleration函数，基于输入的功率、质量和平均速度，确保与物理模型一致。\n\n速度和位置约束：最终速度应通过Velocity函数计算，基于时间增量、初始速度和加速度得到；最终位置应通过Position函数计算，基于时间增量、初始位置和平均速度。\n\n在直线动力学操作中，系统接收输入的功率、质量、时间增量、初始位置和速度，并输出计算后的加速度、最终速度和位置。操作中附加的约束条件确保了计算结果的准确性和一致性，验证了加速度、速度和位置的相互关系。通过这些解析约束，系统能够对车辆的动力学行为进行精确的模拟和验证，为车辆操作和动力分析提供可靠的数据基础和约束验证。",
      "label": "package 'Analytical Constraints' {\n\tprivate import ISQ::*;\n\tprivate import 'Calculation Definitions'::*;\n\t\n\tconstraint def StraightLineDynamicsEquations {\n\t\tin p : PowerValue;\n\t\tin m : MassValue;\n\t\tin dt : TimeValue;\n\t\tin x_i : LengthValue;\n\t\tin v_i : SpeedValue;\n\t\tin x_f : LengthValue;\n\t\tin v_f : SpeedValue;\n\t\tin a : AccelerationValue;\n\t\n\t\tattribute v_avg : SpeedValue = (v_i + v_f)/2;\n\t\t\n\t\ta == Acceleration(p, m, v_avg) and\n\t\tv_f == Velocity(dt, v_i, a) and\n\t\tx_f == Position(dt, x_i, v_avg)\n\t}\n\t\n\taction def StraightLineDynamics {\n\t\tin power : PowerValue;\n\t\tin mass : MassValue;\n\t\tin delta_t : TimeValue;\n\t\tin x_in : LengthValue;\n\t\tin v_in : SpeedValue;\n\t\tout x_out : LengthValue;\n\t\tout v_out : SpeedValue;\n\t\tout a_out : AccelerationValue;\n\t\n\t    assert constraint dynamics : StraightLineDynamicsEquations {\n\t\t\tin p = power;\n\t\t\tin m = mass;\n\t\t\tin dt = delta_t;\n\t\t\tin x_i = x_in;\n\t\t\tin v_i = v_in;\n\t\t\tin x_f = x_out;\n\t\t\tin v_f = v_out;\n\t\t\tin a = a_out;\n\t    }\n\t}\n}"
    },
    {
      "name": "Interface Decomposition Example",
      "text": "系统应定义一个水流输送接口，用于管理水的供给和分配。水流供给端应通过一个龙头接口（SpigotBank）提供水源，并包含热水龙头和冷水龙头两个端口；水流接收端应通过一个水龙头接口（Faucet）进行水的分配，支持一个或多个水龙头，并包含热水入口和冷水入口两个端口。系统应确保热水和冷水从供给端的热、冷水龙头分别连接至接收端的热、冷水入口，以实现供水的分离和控制，满足多样化的用水需求。",
      "label": "package 'Interface Decomposition Example' {\n\t\n\tport def SpigotBank;\n\tport def Spigot;\n\t\n\tport def Faucet;\n\tport def FaucetInlet;\n\t\n\tinterface def WaterDelivery {\n\t\tend suppliedBy : SpigotBank[1] {\n\t\t\tport hot : Spigot;\n\t\t\tport cold : Spigot;\n\t\t}\n\t\tend deliveredTo : Faucet[1..*] {\n\t\t\tport hot : FaucetInlet;\n\t\t\tport cold : FaucetInlet;\n\t\t}\n\t\t\n\t\tconnect suppliedBy.hot to deliveredTo.hot;\n\t\tconnect suppliedBy.cold to deliveredTo.cold;\n\t}\n\t\n}"
    },
    {
      "name": "Interface Example",
      "text": "系统应定义一个燃料接口，用于在燃料供应部件和消耗部件之间建立连接。燃料接口应包含一个供应端口和一个消耗端口，其中供应端口负责输出燃料，消耗端口负责输入燃料。系统中的车辆部件应包含一个燃料箱组件和一个发动机组件，通过燃料接口连接燃料箱的输出端口与发动机的输入端口，实现燃料从燃料箱到发动机的传输，以支持发动机的正常运行。",
      "label": "package 'Interface Example' {\n\tprivate import 'Port Example'::*;\n\t\n\tpart def Vehicle;\n\t\n\tinterface def FuelInterface {\n\t\tend supplierPort : FuelOutPort;\n\t\tend consumerPort : FuelInPort;\n\t}\n\t\n\tpart vehicle : Vehicle {\t\n\t\tpart tankAssy : FuelTankAssembly;\t\t\n\t\tpart eng : Engine;\n\t\t\n\t\tinterface : FuelInterface connect \n\t\t\tsupplierPort ::> tankAssy.fuelTankPort to \n\t\t\tconsumerPort ::> eng.engineFuelPort;\n\t} \n}"
    },
    {
      "name": "Items Example",
      "text": "系统应定义一个车辆实体，具有质量属性，并支持引用一个作为驾驶员的人员。车辆应包含一个油箱部件，油箱内应储存燃料，以满足车辆运行的需求。",
      "label": "package 'Items Example' {\n\tprivate import ScalarValues::*;\n\t\n\titem def Fuel;\n\titem def Person;\n\t\n\tpart def Vehicle {\n\t\tattribute mass : Real;\n\t\t\n\t\tref item driver : Person;\n\n\t\tpart fuelTank {\n\t\t\titem fuel: Fuel;\n\t\t}\t\t\n\t}\n\t\n}"
    },
    {
      "name": "Action Performance Example",
      "text": "系统应定义一个相机组件，用于执行从拍摄到图像处理的完整拍照流程。拍照操作应按顺序执行，以确保捕捉、聚焦和拍摄的过程有序进行。相机组件包含自动对焦和成像模块，自动对焦模块负责执行拍照流程中的聚焦操作，而成像模块负责执行拍摄操作，将聚焦后的图像转换为最终的照片。通过这样的结构设计，相机能够自动协调各个步骤，实现连续、可靠的拍照和图像处理流程。",
      "label": "package 'Action Performance Example' {\n\tprivate import 'Action Decomposition'::*;\n\t\n\tpart def Camera;\n\tpart def AutoFocus;\n\tpart def Imager;\n\t\n\tpart camera : Camera {\n\t\t\n\t\tperform action takePhoto[*] ordered \n\t\t\treferences takePicture;\n\t\t\n\t\tpart f : AutoFocus {\n\t\t\tperform takePhoto.focus;\t\t\t\n\t\t}\n\t\t\n\t\tpart i : Imager {\n\t\t\tperform takePhoto.shoot;\n\t\t}\t\t\n\t}\n}"
    },
    {
      "name": "Action Decomposition",
      "text": "系统应定义一个拍照操作流程，通过聚焦和拍摄的分步骤操作，将输入的场景转换为最终的图片输出。拍照流程的输入为场景，输出为图片。该流程首先执行聚焦操作，以场景为输入生成图像输出；图像输出随后流入拍摄操作，用于生成最终的图片。在此流程中，聚焦操作的场景输入与拍照流程的场景输入保持一致，而拍摄操作的图片输出则绑定至拍照流程的图片输出，以确保整个拍照过程的顺畅执行与数据传递。",
      "label": "package 'Action Decomposition' {\n\tpart def Scene;\n\tpart def Image;\n\tpart def Picture;\n\t\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\taction def TakePicture { in scene : Scene; out picture : Picture; }\n\t\t\n\taction takePicture : TakePicture {\n\t\tin item scene;\n\t\tout item picture;\n\t\t\n\t\taction focus : Focus {\n\t\t\tin item scene = takePicture::scene; \n\t\t\tout item image;\n\t\t}\n\t\t\n\t\tflow from focus.image to shoot.image;\n\n\t\taction shoot : Shoot {\n\t\t\tin item; \n\t\t\tout item picture = takePicture::picture;\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Allocation Definition Example",
      "text": "系统应支持逻辑模型与物理模型之间的分配，以确保逻辑功能在物理系统中的有效实现。在LogicalModel中，系统定义了提供动力（ProvidePower）和生成扭矩（GenerateTorque）的操作。TorqueGenerator作为逻辑部件，负责执行生成扭矩的操作，以实现提供动力的功能。\n\n在PhysicalModel中，系统将逻辑功能映射到物理部件。物理部件PowerTrain（传动系统）作为物理实现的核心部件，其中包含一个引擎部件负责执行提供动力中的生成扭矩操作，以确保物理结构能够实现逻辑功能。",
      "label": "package 'Allocation Definition Example' {\n\tpackage LogicalModel {\n\t\taction def ProvidePower;\n\t\taction def GenerateTorque;\n\t\t\n\t\tpart def LogicalElement;\n\t\tpart def TorqueGenerator :> LogicalElement;\n\t\t\n\t\taction providePower : ProvidePower {\n\t\t\taction generateTorque : GenerateTorque;\n\t\t}\n\t\t\n\t\tpart torqueGenerator : TorqueGenerator {\n\t\t\tperform providePower.generateTorque;\n\t\t}\n\t\t\n\t}\n\t\n\tpackage PhysicalModel {\n\t\tprivate import LogicalModel::*;\n\t\t\n\t\tpart def PhysicalElement;\n\t\tpart def PowerTrain :> PhysicalElement;\n\t\t\n\t\tpart powerTrain : PowerTrain {\n\t\t\tpart engine {\n\t\t\t\tperform providePower.generateTorque;\n\t\t\t}\n\t\t}\n\t\n\t\tallocation def LogicalToPhysical {\n\t\t\tend logical : LogicalElement;\n\t\t\tend physical : PhysicalElement;\n\t\t}\n\t\t\n\t\tallocation torqueGenAlloc : LogicalToPhysical allocate torqueGenerator to powerTrain;\n\t}\t\n}"
    },
    {
      "name": "Allocation Usage Example",
      "text": "系统应支持逻辑模型中的功能分配到物理模型中的具体实现，以确保逻辑功能与物理结构的一致性。在LogicalModel中，系统定义了提供动力（ProvidePower）和生成扭矩（GenerateTorque）的操作。逻辑部件TorqueGenerator负责执行生成扭矩的操作，以实现提供动力的功能需求。\n\n在PhysicalModel中，系统通过物理部件PowerTrain（传动系统）和Engine（引擎）实现逻辑功能。传动系统包含一个引擎部件，负责执行逻辑上的生成扭矩操作，确保该功能在物理结构中得到体现和支持。\n\n通过allocate操作，系统将逻辑部件与物理部件进行映射：逻辑的TorqueGenerator分配给物理的powerTrain，而TorqueGenerator中的生成扭矩功能则映射至物理引擎的生成扭矩操作。这一分配确保逻辑功能能够在物理结构中得到具体实现，使系统设计过程中的功能需求与物理实现相一致，有助于集成和验证各部件的实际功能。",
      "label": "package 'Allocation Usage Example' {\n\tpackage LogicalModel {\n\t\taction def ProvidePower;\n\t\taction def GenerateTorque;\n\t\t\n\t\tpart def TorqueGenerator;\n\t\t\n\t\taction providePower : ProvidePower {\n\t\t\taction generateTorque : GenerateTorque;\n\t\t}\n\t\t\n\t\tpart torqueGenerator : TorqueGenerator {\n\t\t\tperform providePower.generateTorque;\n\t\t}\n\t}\n\t\n\tpackage PhysicalModel {\n\t\tprivate import LogicalModel::*;\n\t\n\t\tpart def PowerTrain;\n\t\tpart def Engine;\n\t\t\n\t\tpart powerTrain : PowerTrain {\n\t\t\tpart engine : Engine {\n\t\t\t\tperform providePower.generateTorque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tallocate torqueGenerator to powerTrain {\n\t\t\tallocate torqueGenerator.generateTorque to powerTrain.engine.generateTorque;\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Redefinition Example",
      "text": "系统应定义一个车辆实体，其中包含一个引擎部件。\n对于小型车辆，应定义一个小型引擎来重新定义车辆的标准引擎，并限制其为四个气缸。\n对于大型车辆，应定义一个大型引擎作为标准引擎的变体，并将气缸数量扩展为六个。\n引擎本身具有可配置的气缸数，以支持不同类型的引擎配置，从而满足车辆的多样化需求。",
      "label": "package 'Redefinition Example' {\n\n\tpart def Vehicle {\n\t\tpart eng : Engine;\n\t}\n\tpart def SmallVehicle :> Vehicle {\n\t\tpart smallEng : SmallEngine redefines eng;\n\t}\n\tpart def BigVehicle :> Vehicle {\n\t\tpart bigEng : BigEngine :>> eng;\n\t}\n\n\tpart def Engine {\n\t\tpart cyl : Cylinder[4..6];\n\t}\n\tpart def SmallEngine :> Engine {\n\t\tpart redefines cyl[4];\n\t}\n\tpart def BigEngine :> Engine {\n\t\tpart redefines cyl[6];\n\t}\n\n\tpart def Cylinder;\n}"
    },
    {
      "name": "Time Slice and Snapshot Example",
      "text": "系统应定义一个车辆的生命周期管理流程，通过时间片和快照的结构跟踪车辆从装配到报废的各个阶段和关键事件。该流程包括以下阶段：\n\n装配阶段（assembly）：作为车辆的第一个时间片，表示车辆的制造和组装过程。\n\n交付快照（delivery）：在装配阶段完成后，生成交付快照，并记录交付日期属性，以标记车辆交付给最终客户的时间点。\n\n所有权时间片（ownership）：交付后，车辆进入所有权管理阶段。所有权时间片可以包含多个顺序排列的时间片，用于表示不同所有者的更替。在每个所有权时间片的起点，记录一次销售快照，以标记车辆所有权的转移。每个所有权时间片内，系统需追踪当前所有者（owner）并确保有一名现任所有者。\n\n驾驶时间片（driven）：在每个所有权时间片内，车辆还可包含一个或多个驾驶时间片，以追踪不同驾驶人员的记录。每个驾驶时间片内记录当前驾驶员（driver）为一名具体人员。\n\n报废快照（junked）：当车辆不再使用时，生成报废快照，标记生命周期的结束。",
      "label": "package 'Time Slice and Snapshot Example' {\n\t\t\n\tattribute def Date;\n\titem def Person;\n\t\n\tpart def Vehicle {\n\t\ttimeslice assembly;\n\t\t\n\t\tfirst assembly then delivery;\n\t\t\n\t\tsnapshot delivery {\n\t\t\tattribute deliveryDate : Date;\n\t\t}\n\t\t\n\t\tthen timeslice ownership[0..*] ordered {\n\t\t\tsnapshot sale = start;\n\t\t\t\n\t\t\tref item owner : Person[1];\n\t\t\t\n\t\t\ttimeslice driven[0..*] {\n\t\t\t\tref item driver : Person[1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tsnapshot junked = done;\n\t}\n}"
    },
    {
      "name": "Interaction Realization-2",
      "text": "系统应定义一个巡航控制交互实现流程，以实现驾驶员和车辆部件之间的端口连接和消息流动。驾驶员组件`driver_b`配置了`setSpeedPort`端口，用于输出“设定速度”消息（SetSpeed），并通过`driverToVehicleInterface`接口连接至车辆组件`vehicle_b`的`setSpeedPort`端口，以将“设定速度”消息传输至车辆。\n\n在车辆组件`vehicle_b`中，`setSpeedPort`绑定到巡航控制器`cruiseController_b`的`setSpeedPort`端口，从而使“设定速度”消息进入巡航控制器。巡航控制器同时拥有两个其他端口：`sensedSpeedPort`接收“检测到的速度”消息（SensedSpeed），`fuelCommandPort`用于输出“燃料指令”消息（FuelCommand）。车辆中的速度计组件`speedometer_b`通过其`out`端口` sensedSpeedPort`向巡航控制器的`sensedSpeedPort`端口发送“检测到的速度”消息；同样，巡航控制器通过其`fuelCommandPort`端口将“燃料指令”消息发送至发动机组件`engine_b`的`fuelCommandPort`端口。\n\n在交互实例`cruiseControlInteraction_b`中，事件映射如下：驾驶员的“设定速度”发送事件关联到巡航控制器的“设定速度”接收事件，速度计的“检测到的速度”发送事件关联到巡航控制器的“检测到的速度”接收事件，巡航控制器的“燃料指令”发送事件关联到发动机的“燃料指令”接收事件。该交互流程通过端口和消息流确保了巡航控制的消息传递和执行顺序，使得系统在不同部件之间实现协调和一致的巡航控制功能。",
      "label": "package 'Interaction Realization-2' {\n\tprivate import 'Interaction Example-1'::*;\n\t\n\tpart driver_b : Driver {\n\t\tport setSpeedPort {\n\t\t\tout setSpeed : SetSpeed;\n\t\t}\n\t}\n\t\n\tinterface driverToVehicleInterface connect driver_b.setSpeedPort to vehicle_b.setSpeedPort {\n\t\tflow setSpeedFlow of SetSpeed \n\t\t\tfrom driver_b.setSpeedPort.setSpeed to vehicle_b.setSpeedPort.setSpeed;\n\t}\n\t\n\tpart vehicle_b : Vehicle {\n\t\tport setSpeedPort {\n\t\t\tin setSpeed : SetSpeed;\n\t\t}\n\t\t\n\t\tbind setSpeedPort = cruiseController_b.setSpeedPort;\n\t\t\n\t\tpart cruiseController_b : CruiseController {\n\t\t\tport setSpeedPort {\n\t\t\t\tin setSpeed : SetSpeed;\n\t\t\t}\n\t\t\tport sensedSpeedPort {\n\t\t\t\tin sensedSpeed : SensedSpeed;\n\t\t\t}\n\t\t\tport fuelCommandPort {\n\t\t\t\tout fuelCommand : FuelCommand;\n\t\t\t}\n\t\t}\n\t\t\n\t\tflow sensedSpeedFlow of SensedSpeed \n\t\t\tfrom speedometer_b.sensedSpeedPort.sensedSpeed to cruiseController_b.sensedSpeedPort.sensedSpeed;\n\t\t\n\t\tpart speedometer_b : Speedometer {\n\t\t\tport sensedSpeedPort {\n\t\t\t\tout sensedSpeed : SensedSpeed;\n\t\t\t}\n\t\t}\n\t\t\n\t\tflow fuelCommandFlow of FuelCommand \n\t\t\tfrom cruiseController_b.fuelCommandPort.fuelCommand to engine_b.fuelCommandPort.fuelCommand;\n\n\t\tpart engine_b : Engine {\n\t\t\tport fuelCommandPort {\n\t\t\t\tin fuelCommand : FuelCommand;\n\t\t\t}\n\t\t}\n\t}\n\t\n\toccurrence cruiseControlInteraction_b : CruiseControlInteraction {\n\t\tpart :>> driver :>> driver_b {\n\t\t\tport :>> setSpeedPort {\n\t\t\t\tevent driver::setSpeedSent; \n\t\t\t}\n\t\t}\n\t\t\n\t\tpart :>> vehicle :>> vehicle_b {\n\t\t\tpart :>> cruiseController :>> cruiseController_b {\n\t\t\t\tport :>> setSpeedPort {\n\t\t\t\t\tevent cruiseController::setSpeedReceived;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart :>> speedometer :>> speedometer_b {\n\t\t\t\tport :>> sensedSpeedPort {\n\t\t\t\t\tevent speedometer::sensedSpeedSent;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart :>> engine :>> engine_b {\n\t\t\t\tport :>> fuelCommandPort {\n\t\t\t\t\tevent engine::fuelCommandReceived;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmessage :>> setSpeedMessage = driverToVehicleInterface.setSpeedFlow;\n\t\tmessage :>> sensedSpeedMessage = vehicle_b.sensedSpeedFlow;\n\t\tmessage :>> fuelCommandMessage = vehicle_b.fuelCommandFlow;\n\t}\n}"
    },
    {
      "name": "Event Occurrence Example",
      "text": "系统应定义一个事件发生管理流程，以协调驾驶员、巡航控制器、速度计和发动机之间的事件通信。驾驶员部件能够发送设定速度的事件；车辆内的巡航控制器会接收该速度设定事件，并随后依次触发速度传感事件和燃料指令事件。速度计部件负责发送当前速度的传感事件，巡航控制器则会接收该事件以更新速度信息。最终，巡航控制器发送燃料指令事件，并由发动机接收以调整燃料供给。通过这一事件发生流程，系统能够确保各部件之间的顺序交互和协作，以实现车辆的巡航控制和实时速度调节。",
      "label": "package 'Event Occurrence Example' {\t\n\tpart def Driver;\n\tpart def CruiseController;\n\tpart def Speedometer;\n\tpart def Engine;\n\tpart def Vehicle;\n\t\n\tpart driver : Driver {\n\t\tevent occurrence setSpeedSent;\n\t}\n\t\n\tpart vehicle : Vehicle {\n\t\n\t\tpart cruiseController : CruiseController {\n\t\t\tevent occurrence setSpeedReceived;\t\t\n\t\t\tthen event occurrence sensedSpeedReceived;\t\t\n\t\t\tthen event occurrence fuelCommandSent;\n\t\t}\n\t\t\n\t\tpart speedometer : Speedometer {\n\t\t\tevent occurrence sensedSpeedSent;\n\t\t}\n\t\t\n\t\tpart engine : Engine {\n\t\t\tevent occurrence fuelCommandReceived;\n\t\t}\n\t\n\t}\n}"
    },
    {
      "name": "Message Payload Example",
      "text": "系统应定义一个巡航控制交互流程，通过消息传递协调驾驶员、车辆控制系统和发动机部件，以实现巡航控制功能。该交互流程中包含以下消息及其传递路径：\n\n设定速度消息（SetSpeed）：驾驶员触发设定速度事件，生成“设定速度”消息，消息从驾驶员组件的“设定速度发送”事件传递至车辆的巡航控制器的“设定速度接收”事件。\n\n检测到的速度消息（SensedSpeed）：车辆的速度计生成“检测到的速度”消息，消息从速度计的“速度发送”事件传递至巡航控制器的“速度接收”事件，用于更新车辆的实时速度信息。\n\n燃料指令消息（FuelCommand）：巡航控制器根据速度信息生成“燃料指令”消息，包含燃料流量（fuelFlow）属性。该消息从巡航控制器的“燃料指令发送”事件传递至发动机控制器的“燃料指令接收”事件。\n\n燃料指令转发消息：发动机控制器接收到燃料指令后，生成一条“燃料指令转发”消息，将燃料流量信息传递至发动机，以确保执行巡航控制器的燃料指令。该转发消息从发动机控制器的“燃料指令转发”事件传递至发动机的“燃料指令接收”事件。",
      "label": "package 'Message Payload Example' {\n\tprivate import 'Event Occurrence Example'::*;\n\t\n\titem def SetSpeed;\n\titem def SensedSpeed;\n\titem def FuelCommand {\n\t\tattribute fuelFlow : ScalarValues::Real;\n\t}\n\t\n\tpart def EngineController;\n\t\n\tpart vehicle1 :> vehicle {\n\t\tpart engineController : EngineController {\n\t\t\tevent occurrence fuelCommandReceived;\n\t\t\tthen event occurrence fuelCommandForwarded;\n\t\t}\n\t}\n\t\n\toccurrence def CruiseControlInteraction {\t\t\n\t\tref part :>> driver;\t\t\n\t\tref part vehicle :>> vehicle1;\n\t\t\n\t\tmessage setSpeedMessage of SetSpeed \n\t\t\tfrom driver.setSpeedSent to vehicle.cruiseController.setSpeedReceived;\n\t\t\t\n\t\tthen message sensedSpeedMessage of SensedSpeed \n\t\t\tfrom vehicle.speedometer.sensedSpeedSent to vehicle.cruiseController.sensedSpeedReceived;\n\t\t\t\n\t\tthen message fuelCommandMessage of fuelCommand : FuelCommand \n\t\t\tfrom vehicle.cruiseController.fuelCommandSent to vehicle.engineController.fuelCommandReceived;\n\t\t\n\t\tthen message fuelCommandForwardingMessage of fuelCommand : FuelCommand = fuelCommandMessage.fuelCommand\n\t\t\tfrom vehicle.engineController.fuelCommandForwarded to vehicle.engine.fuelCommandReceived;\n\t\t\n\t}\n}"
    },
    {
      "name": "Interaction Example-1",
      "text": "系统应定义一个巡航控制交互流程，以协调驾驶员和车辆部件之间的消息传递，确保顺序和一致性。在该流程中，驾驶员发送“设定速度”消息（SetSpeed），消息从驾驶员的“设定速度发送”事件传递到车辆的巡航控制器的“设定速度接收”事件。随后，速度计发送“检测到的速度”消息（SensedSpeed），该消息从速度计的“速度发送”事件传递至巡航控制器的“速度接收”事件。接下来，巡航控制器发送“燃料指令”消息（FuelCommand），该消息从巡航控制器的“燃料指令发送”事件传递至发动机的“燃料指令接收”事件。\n\n整个交互流程确保消息传递的顺序性：首先是“设定速度”消息，然后是“检测到的速度”消息，以实现车辆的巡航控制系统在设定速度、实时速度监测和燃料供给之间的顺畅协调。",
      "label": "package 'Interaction Example-1' {\n\tpublic import 'Event Occurrence Example'::*;\n\t\n\titem def SetSpeed;\n\titem def SensedSpeed;\n\titem def FuelCommand;\n\t\n\toccurrence def CruiseControlInteraction {\t\t\n\t\tref part :>> driver;\t\t\n\t\tref part :>> vehicle;\n\t\t\n\t\tmessage setSpeedMessage of SetSpeed \n\t\t\tfrom driver.setSpeedSent to vehicle.cruiseController.setSpeedReceived;\n\t\t\t\n\t\tmessage sensedSpeedMessage of SensedSpeed \n\t\t\tfrom vehicle.speedometer.sensedSpeedSent to vehicle.cruiseController.sensedSpeedReceived;\n\t\t\t\n\t\tmessage fuelCommandMessage of FuelCommand \n\t\t\tfrom vehicle.cruiseController.fuelCommandSent to vehicle.engine.fuelCommandReceived;\n\t\t\n\t\tfirst setSpeedMessage then sensedSpeedMessage;\n\t}\n}"
    },
    {
      "name": "Interaction Realization-1",
      "text": "系统应定义一个巡航控制交互的实现流程，以具体化各部件的行为与消息传递，确保驾驶员与车辆部件之间的顺序交互。驾驶员组件driver_a包含一个行为，用于发送“设定速度”消息（SetSpeed）至车辆组件vehicle_a。在车辆组件中，巡航控制器cruiseController_a包含控制器行为，首先接收“设定速度”消息，然后依次接收“检测到的速度”消息（SensedSpeed），并发送“燃料指令”消息（FuelCommand）至发动机engine_a。\n\n速度计组件speedometer_a通过其行为将“检测到的速度”消息发送至巡航控制器。发动机engine_a通过其行为接收“燃料指令”消息，完成整个交互流程。每个消息传递都在事件关联中明确映射：setSpeedSent到setSpeedReceived，sensedSpeedSent到sensedSpeedReceived，以及fuelCommandSent到fuelCommandReceived。该实现流程确保驾驶员和车辆组件之间的交互顺序和逻辑一致，为巡航控制功能的实际运行提供基础。",
      "label": "package 'Interaction Realization-1' {\n\tprivate import 'Interaction Example-1'::*;\n\t\n\tpart driver_a : Driver {\n\t\taction driverBehavior {\n\t\t\taction sendSetSpeed send SetSpeed() to vehicle_a;\n\t\t}\n\t}\n\t\n\tpart vehicle_a : Vehicle {\n\t\tpart cruiseController_a : CruiseController {\n\t\t\taction controllerBehavior {\n\t\t\t\taction receiveSetSpeed accept SetSpeed via vehicle_a;\n\t\t\t\tthen action receiveSensedSpeed accept SensedSpeed via cruiseController_a;\n\t\t\t\tthen action sendFuelCommand send FuelCommand() to engine_a;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart speedometer_a : Speedometer {\n\t\t\taction speedometerBehavior {\n\t\t\t\taction sendSensedSpeed send SensedSpeed() to cruiseController_a;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart engine_a : Engine {\n\t\t\taction engineBehavior {\n\t\t\t\taction receiveFuelCommand accept FuelCommand via engine_a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\toccurrence cruiseControlInteraction_a : CruiseControlInteraction {\n\t\tpart :>> driver :>> driver_a {\n\t\t\tevent driverBehavior.sendSetSpeed[1] :>> setSpeedSent;\n\t\t}\n\t\t\n\t\tpart :>> vehicle :>> vehicle_a {\n\t\t\tpart :>> cruiseController :>> cruiseController_a {\n\t\t\t\tevent controllerBehavior.receiveSetSpeed[1] :>> setSpeedReceived;\n\t\t\t\tevent controllerBehavior.receiveSensedSpeed[1] :>> sensedSpeedReceived;\n\t\t\t\tevent controllerBehavior.sendFuelCommand[1] :>> fuelCommandSent;\n\t\t\t}\n\t\t\tpart :>> speedometer :>> speedometer_a {\n\t\t\t\tevent speedometerBehavior.sendSensedSpeed[1] :>> sensedSpeedSent;\n\t\t\t}\n\t\t\tpart :>> engine :>> engine_a {\n\t\t\t\tevent engineBehavior.receiveFuelCommand[1] :>> fuelCommandReceived;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmessage :>> setSpeedMessage = driver_a.driverBehavior.sendSetSpeed.sentMessage;\n\t\tmessage :>> sensedSpeedMessage = vehicle_a.speedometer_a.speedometerBehavior.sendSensedSpeed.sentMessage;\n\t\tmessage :>> fuelCommandMessage = vehicle_a.cruiseController_a.controllerBehavior.sendFuelCommand.sentMessage;\n\t}\n}"
    },
    {
      "name": "Interaction Example-2",
      "text": "",
      "label": "package 'Interaction Example-2' {\n\tprivate import 'Event Occurrence Example'::*;\n\t\n\titem def SetSpeed;\n\titem def SensedSpeed;\n\titem def FuelCommand;\n\t\n\toccurrence def CruiseControlInteraction {\n\t\t\n\t\tref part driver : Driver {\n\t\t\tevent setSpeedMessage.sourceEvent;\n\t\t}\n\t\t\n\t\tref part vehicle : Vehicle {\n\t\t\tpart cruiseController : CruiseController {\n\t\t\t\tevent setSpeedMessage.targetEvent;\t\t\n\t\t\t\tthen event sensedSpeedMessage.targetEvent;\t\t\n\t\t\t\tthen event fuelCommandMessage.sourceEvent;\n\t\t\t}\n\t\t\t\n\t\t\tpart speedometer : Speedometer {\n\t\t\t\tevent sensedSpeedMessage.sourceEvent;\n\t\t\t}\n\t\t\t\n\t\t\tpart engine : Engine {\n\t\t\t\tevent fuelCommandMessage.targetEvent;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmessage setSpeedMessage of SetSpeed;\t\n\t\tthen message sensedSpeedMessage of SensedSpeed;\n\t\tmessage fuelCommandMessage of FuelCommand;\n\t}\n}"
    },
    {
      "name": "Trade Study Analysis Example",
      "text": "系统应支持发动机的多方案权衡分析，以在不同设计方案中选择最优发动机配置。此权衡分析涵盖四缸发动机（engine4cyl）和六缸发动机（engine6cyl），并根据功率、质量、效率和成本等指标进行评估，以确定最适合的发动机选项。\n\n在分析过程中，系统首先通过功率汇总、质量汇总、效率汇总和成本汇总计算每个发动机的关键属性。随后，系统根据这些属性使用“发动机评估”函数（EngineEvaluation）生成每个方案的综合评分。评分计算考虑发动机的功率、质量、效率和成本等因素，从而量化每个发动机在各方面的表现。\n\n分析的目标是最大化评价函数的结果值，以确保选择的发动机在功率、效率和成本之间取得最佳平衡。最终，系统输出评分最高的发动机作为“选定方案”，提供给设计团队参考。通过这种权衡分析，系统能够在多个设计方案中自动评估并选择最优配置，确保车辆性能和成本效益达到预期的设计标准，为产品开发决策提供数据支持。",
      "label": "package 'Trade Study Analysis Example' {\n\tprivate import ScalarValues::Real;\n\tprivate import TradeStudies::*;\n\t\n\tpart def Engine;\n\tpart engine4cyl : Engine;\n\tpart engine6cyl : Engine;\n\t\n\tcalc def PowerRollup { in engine : Engine; return : ISQ::PowerValue; }\n\tcalc def MassRollup { in engine : Engine; return : ISQ::MassValue; }\n\tcalc def EfficiencyRollup { in engine : Engine; return : Real; }\n\tcalc def CostRollup { in engine : Engine; return : Real; }\n\t\n\tcalc def EngineEvaluation { \n\t\tin power : ISQ::PowerValue;\n\t\tin mass : ISQ::MassValue;\n\t\tin efficiency : Real;\n\t\tin cost : Real;\n\t\treturn evaluation : Real;\n\t\t// Compute evaluation...\n\t}\n\t\t\n\tanalysis engineTradeStudy : TradeStudy {\n\t\tsubject : Engine = (engine4cyl, engine6cyl);\n\t\tobjective : MaximizeObjective;\n\n\t\tcalc :>> evaluationFunction {\n\t\t\tin part anEngine :>> alternative : Engine;\n\t\t\t\n\t\t\tcalc powerRollup: PowerRollup { in engine = anEngine; return power; }\n\t\t\tcalc massRollup: MassRollup { in engine = anEngine; return mass; }\n\t\t\tcalc efficiencyRollup: EfficiencyRollup { in engine = anEngine; return efficiency; }\n\t\t\tcalc costRollup: CostRollup { in engine = anEngine; return cost; }\n\t\t\t\n\t\t\treturn :>> result : Real = EngineEvaluation(\n\t\t\t\tpowerRollup.power, massRollup.mass, efficiencyRollup.efficiency, costRollup.cost\n\t\t\t);\n\t\t}\n\t\t\n\t\treturn part :>> selectedAlternative : Engine;\n\t}\n\t\n}"
    },
    {
      "name": "Analysis Case Usage Example",
      "text": "系统应支持基于不同驾驶情境的燃油经济性分析，以验证车辆在城市和高速行驶中的燃油效率是否符合要求。在此分析上下文中，车辆燃油经济性要求作为整体需求，对车辆的燃油消耗和效率进行评估。\n\n系统提供了两个情境：城市行驶情境（cityScenario）和高速公路行驶情境（highwayScenario），分别用于评估车辆在不同驾驶条件下的燃油经济性。针对每个情境，系统执行燃油经济性分析。城市行驶分析（cityAnalysis）基于cityScenario情境，对特定车辆vehicle_c1的燃油消耗进行评估，结果记录为车辆的城市燃油经济性（fuelEconomy_city）。同样，高速公路行驶分析（highwayAnalysis）基于highwayScenario情境，对同一车辆的高速燃油消耗进行评估，结果记录为高速燃油经济性（fuelEconomy_highway）。\n\n系统将分析结果与燃油经济性要求进行比对，以验证车辆在城市和高速行驶中的燃油经济性是否达标。通过这些情境和分析的设定，系统可以针对不同行驶条件提供精确的燃油消耗估算，确保车辆在实际使用中的经济性符合预期标准，为车辆设计和运营提供可靠的数据支持和性能验证。",
      "label": "package 'Analysis Case Usage Example' {\n\tprivate import 'Analysis Case Definition Example'::*;\n\t\n\tpart vehicleFuelEconomyAnalysisContext {\n\t\trequirement vehicleFuelEconomyRequirements {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\t// ...\n\t\t}\n\t\t\n\t\tattribute cityScenario : WayPoint[*] = ( //* ... */ );\n\t\tattribute highwayScenario : WayPoint[*] = ( //* ... */ );\n\t\t\n\t\tanalysis cityAnalysis : FuelEconomyAnalysis {\n\t\t\tsubject vehicle = vehicle_c1;\n\t\t\tin scenario = cityScenario;\n\t\t}\n\t\t\n\t\tanalysis highwayAnalysis : FuelEconomyAnalysis {\n\t\t\tsubject vehicle = vehicle_c1;\n\t\t\tin scenario = highwayScenario;\n\t\t}\n\t\t\n\t\tpart vehicle_c1 : Vehicle {\n\t\t\t// ...\n\t\t\t\n\t\t\tattribute :>> fuelEconomy_city = cityAnalysis.fuelEconomyResult;\n\t\t\tattribute :>> fuelEconomy_highway = highwayAnalysis.fuelEconomyResult;\n\t\t}\n\t\t\n\t\tsatisfy vehicleFuelEconomyRequirements by vehicle_c1;\n\t}\n\n}"
    },
    {
      "name": "Analysis Case Definition Example",
      "text": "系统应具备燃油经济性分析能力，以评估车辆是否满足设定的燃油经济性要求。在本分析中，目标是验证车辆在不同驾驶情境下的燃油效率，并确保其满足30英里/加仑的燃油经济性要求。\n\n在燃油经济性分析中，系统首先假设车辆的车轮直径为33英寸，驱动系统效率为0.4。分析过程基于一系列情境点（WayPoint），每个情境点包含时间、位置和速度的数据，模拟车辆在不同时间点的行驶情况。\n\n分析的第一个步骤为功率计算。系统需计算出车辆在各时间点所需的引擎功率和加速度，以满足给定情境中的动态需求。功率计算基于StraightLineDynamicsEquations约束条件，确保在相邻的时间点间，功率和加速度符合物理动力学方程的关系。\n\n接下来，系统将根据计算得到的功率值，分析车辆的燃油消耗情况，并最终得出车辆的燃油经济性结果（fuelEconomyResult）。如果燃油经济性结果高于30英里/加仑，则车辆满足燃油经济性要求。\n\n该分析为车辆的燃油经济性验证提供了自动化的支持，确保系统能够在不同驾驶情境下准确评估车辆的燃油效率，并验证其符合经济性目标。此功能为车辆设计和性能分析提供了可靠的数值支持和验证手段。",
      "label": "package 'Analysis Case Definition Example' {\n\tprivate import ScalarValues::Real;\n\tprivate import 'Calculation Definitions'::*;\n\tprivate import 'Analytical Constraints'::*;\n\tprivate import USCustomaryUnits::*;\n\tprivate import SequenceFunctions::size;\n\tprivate import Quantities::ScalarQuantityValue;\n\tprivate import ControlFunctions::*;\n\tprivate import ScalarValues::Positive;\n\t\n\tattribute def DistancePerVolumeValue :> ScalarQuantityValue;\n\n\tpart def Vehicle {\n        attribute mass : MassValue;\n        attribute cargoMass : MassValue;\n        \n        attribute wheelDiameter : LengthValue;\n        attribute driveTrainEfficiency : Real;\n        \n        attribute fuelEconomy_city : DistancePerVolumeValue;\n        attribute fuelEconomy_highway : DistancePerVolumeValue;\n    }\n    \n    attribute def WayPoint {\n\t\ttime : TimeValue;\n\t\tposition : LengthValue;\n\t\tspeed : SpeedValue;    \t\n\t}\n    \n\tanalysis def FuelEconomyAnalysis {\n\t\tsubject vehicle : Vehicle;\n\t\tobjective fuelEconomyAnalysisObjective {\n\t\t\t/*\n\t\t\t * The objective of this analysis is to determine whether the\n\t\t\t * subject vehicle can satisfy the fuel economy requirement.\n\t\t\t */\n\t\t\t\n\t\t\tassume constraint {\n\t\t\t\tvehicle.wheelDiameter == 33 ['in'] &\n\t\t\t\tvehicle.driveTrainEfficiency == 0.4\n\t\t\t}\n\t\t\t\n\t\t\trequire constraint {\n\t\t\t\tfuelEconomyResult > 30 [mi / gal]\n\t\t\t}\n\t\t}\n\t    \n\t\tin attribute scenario : WayPoint[*];\n\t\n\t\taction solveForPower {\n\t\t\tout power : PowerValue[*];\n\t\t\tout acceleration : AccelerationValue[*];\n\t\t\n\t\t\t/*\n\t\t\t * Solve for the required engine power as a function of time\n\t\t\t * to support the scenario.\n\t\t\t */\n\t\t\tassert constraint {\n\t\t\t\t(1..size(scenario)-1)->forAll {in i: Positive;\n\t\t\t\t\tStraightLineDynamicsEquations (\n\t\t\t\t\t\tpower#(i),\n\t\t\t\t\t\tvehicle.mass,\n\t\t\t\t\t\tscenario.time#(i+1) - scenario.time#(i),\n\t\t\t\t\t\tscenario.position#(i),\n\t\t\t\t\t\tscenario.speed#(i),\n\t\t\t\t\t\tscenario.position#(i+1),\n\t\t\t\t\t\tscenario.speed#(i+1),\n\t\t\t\t\t\tacceleration#(i+1)                    \n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthen action solveForFuelConsumption {\n\t\t\tin power : PowerValue[*] = solveForPower.power;\n\t\t\tout fuelEconomy : DistancePerVolumeValue;\n\t\t\n\t\t\t/*\n\t\t\t * Solve the engine equations to determine how much fuel is\n\t\t\t * consumed.\n\t\t\t */\n\t\t}\n\t\t\n        return fuelEconomyResult : DistancePerVolumeValue = solveForFuelConsumption.fuelEconomy;\n\t}\n}"
    },
    {
      "name": "Messaging with Ports",
      "text": "系统应定义一个相机拍照流程，通过端口实现从场景捕捉到屏幕显示的完整操作。相机部件配备视图端口和显示端口，以支持图像输入与输出的交互。拍照流程首先通过视图端口接收场景输入触发拍摄，然后执行聚焦操作，将场景转换为图像并传输至拍摄操作，生成最终的图片。拍摄完成后，相机通过显示端口将生成的图片发送至屏幕的显示端口，确保拍摄的图片能即时在屏幕上展示。该消息传递结构使相机与屏幕之间能够实现无缝的图片传输和显示，为拍照过程提供实时反馈和流畅的操作体验。",
      "label": "package 'Messaging Example' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\t\n\tattribute def Show {\n\t\titem picture : Picture;\n\t}\n\t\n\taction def Focus { in item scene : Scene; out item image : Image; }\n\taction def Shoot { in item image : Image; out item picture : Picture; }\n\taction def TakePicture;\n\t\n\tpart screen {\n\t\tport displayPort;\n\t}\n\t\n\tpart camera {\n\t\tport viewPort;\n\t\tport displayPort;\n\t\t\n\t\taction takePicture : TakePicture {\n\t\t\taction trigger accept scene : Scene via viewPort;\n\t\t\t\n\t\t\tthen action focus : Focus {\n\t\t\t\tin item scene = trigger.scene;\n\t\t\t\tout item image;\n\t\t\t}\n\t\t\t\n\t\t\tflow from focus.image to shoot.image;\n\t\t\n\t\t\tthen action shoot : Shoot {\n\t\t\t\tin item image; \n\t\t\t\tout item picture;\n\t\t\t}\n\t\t\t\n\t\t\tthen send Show(shoot.picture) via displayPort;\n\t\t}\n\t}\n}"
    },
    {
      "name": "Messaging Example",
      "text": "系统应定义一个拍照操作流程，从场景捕捉到图片显示，包含触发、聚焦、拍摄和显示步骤。拍照流程首先通过触发操作接收场景作为输入，随后进入聚焦阶段，将场景转换为图像输出。生成的图像会流向拍摄操作，以创建最终的图片。在拍摄完成后，流程将图片通过消息发送至屏幕显示，确保拍摄的图片能够实时展示。通过这一消息传递结构，系统能够实现从图像捕捉到结果显示的完整流程，使拍照过程顺畅且具有即时反馈。",
      "label": "package 'Messaging Example' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\t\n\tattribute def Show {\n\t\titem picture : Picture;\n\t}\n\t\n\taction def Focus { in item scene : Scene; out item image : Image; }\n\taction def Shoot { in item image : Image; out item picture : Picture; }\n\taction def TakePicture;\n\t\n\taction screen;\n\t\t\n\taction takePicture : TakePicture {\n\t\taction trigger accept scene : Scene;\n\t\t\n\t\tthen action focus : Focus {\n\t\t\tin item scene = trigger.scene;\n\t\t\tout item image;\n\t\t}\n\t\t\n\t\tflow from focus.image to shoot.image;\n\t\t\n\t\tthen action shoot : Shoot {\n\t\t\tin item image; \n\t\t\tout item picture;\n\t\t}\n\t\t\n\t\tthen send Show(shoot.picture) to screen;\n\t}\n}"
    },
    {
      "name": "Use Case Definition Example",
      "text": "系统应支持定义与车辆使用相关的用例，以便描述车辆的基本操作情景和交互要求。使用场景包括“提供交通服务”、“进入车辆”和“离开车辆”，每个用例均涉及车辆、驾驶员、乘客及环境等参与方，定义了车辆的主要操作流程和交互角色。\n\n在“提供交通服务”用例中，系统的目标是将驾驶员和最多四名乘客从起点位置运送到终点位置，涉及的主体是车辆，由驾驶员操作，并在环境因素下执行。在此过程中，系统应确保驾驶员和乘客能够安全有效地完成运输任务。\n\n在“进入车辆”用例中，车辆作为主体，驾驶员和最多四名乘客作为参与者。该用例描述了人员进入车辆的过程，包括安全进入车辆的操作及相关互动。\n\n“离开车辆”用例则描述了驾驶员和乘客从车辆中安全离开的过程，同样以车辆为主体，由驾驶员和乘客作为参与方，确保离开过程的规范性和安全性。\n\n通过这些用例定义，系统能够清晰地描述车辆使用中的基本交互和操作流程，为设计与开发提供明确的使用场景支持，确保车辆在不同使用情境下的功能性和安全性。",
      "label": "package 'Use Case Definition Example' {\n\t\n\tpart def Vehicle;\n\tpart def Person;\n\tpart def Environment;\n\tpart def 'Fuel Station';\n\t\n\tuse case def 'Provide Transportation' {\n\t\tsubject vehicle : Vehicle;\n\t\t\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t\tactor environment : Environment;\n\t\t\n\t\tobjective {\n\t\t\tdoc \n\t\t\t/* Transport driver and passengers from starting location \n\t\t\t * to ending location.\n\t\t\t */\n\t\t}\t\t\n\t}\n\t\n\tuse case def 'Enter Vehicle' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t}\n\t\n\tuse case def 'Exit Vehicle' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t}\n}"
    },
    {
      "name": "Use Case Usage Example",
      "text": "系统应支持车辆提供运输服务的完整使用场景，包括进入车辆、驾驶车辆、加油和离开车辆的过程。在“提供交通服务”用例中，系统首先进入“进入车辆”步骤，其中驾驶员和乘客作为参与者，完成安全进入车辆的操作。随后进入“驾驶车辆”阶段，在此阶段，驾驶员操作车辆，并在环境影响下完成运输任务。\n\n在驾驶过程中，系统可选择性地包含“加油”步骤，以确保车辆在长途驾驶中保持充足的燃料供应。此步骤包含加油站和驾驶员作为参与者，加油站作为燃料的供应方，驾驶员作为加油操作的执行者，确保车辆在运输任务中的续航能力。\n\n最后，系统执行“离开车辆”步骤，驾驶员和乘客完成安全下车的操作，标志着运输任务的结束。该用例通过步骤顺序和包含操作的方式确保了车辆运输服务的完整性和连续性，涵盖了进入、驾驶、加油和离开的全过程。系统在这一使用场景中支持关键交互步骤，确保车辆在实际使用中的功能性、安全性和操作的顺畅性。",
      "label": "package 'Use Case Usage Example' {\n\t\n\tprivate import 'Use Case Definition Example'::*;\n\t\n\tpart def 'Fuel Station';\n\t\n\tuse case 'provide transportation' : 'Provide Transportation' {\t\t\n\t\tfirst start;\n\t\t\n\t\tthen include use case 'enter vehicle' : 'Enter Vehicle' {\n\t\t\tactor :>> driver = 'provide transportation'::driver;\n\t\t\tactor :>> passengers = 'provide transportation'::passengers;\n\t\t}\n\t\t\n\t\tthen use case 'drive vehicle' {\n\t\t\tactor driver = 'provide transportation'::driver;\n\t\t\tactor environment = 'provide transportation'::environment;\n\t\t\t\n\t\t\tinclude 'add fuel'[0..*] { \n\t\t\t\tactor :>> fueler = driver;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthen include use case 'exit vehicle' : 'Exit Vehicle' {\n\t\t\tactor :>> driver = 'provide transportation'::driver;\n\t\t\tactor :>> passengers = 'provide transportation'::passengers;\n\t\t}\n\t\t\n\t\tthen done;\t\t\n\t}\n\t\n\tuse case 'add fuel' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor fueler : Person;\n\t\tactor 'fuel station' : 'Fuel Station';\n\t}\n}"
    },
    {
      "name": "Parts Example-1",
      "text": "系统应定义一个车辆实体，其中包含一个引擎部件，且该引擎由4到6个气缸组成。\n系统应支持小型车辆和大型车辆的配置。\n对于小型车辆，引擎应被定义为包含4个气缸；\n对于大型车辆，引擎应被定义为包含6个气缸，以满足不同类型车辆的需求和配置要求。",
      "label": "package 'Parts Example-1' {\n\t\n\t// Definitions\n\t\n\tpart def Vehicle {\n\t\tpart eng : Engine;\n\t}\n\t\n\tpart def Engine {\n\t\tpart cyl : Cylinder[4..6];\n\t}\n\t\n\tpart def Cylinder;\n\t\n\t// Usages\n\t\n\tpart smallVehicle : Vehicle {\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[4];\n\t\t}\n\t}\n\t\n\tpart bigVehicle : Vehicle {\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[6];\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Parts Example-2",
      "text": "系统应定义一个车辆实体，其中包含一个引擎部件，该引擎包含4到6个气缸。\n系统应支持小型车辆和大型车辆的具体配置。\n在小型车辆配置中，引擎应被重新定义为包含4个气缸；\n在大型车辆配置中，引擎应被重新定义为包含6个气缸，以适应不同车辆类型的需求。",
      "label": "package 'Parts Example-2' {\n\t\n\t// Definitions\n\t\n\tpart def Vehicle;\t\n\tpart def Engine;\t\n\tpart def Cylinder;\n\t\n\t// Usages\n\t\n\tpart vehicle : Vehicle {\n\t\tpart eng : Engine {\n\t\t\tpart cyl : Cylinder[4..6];\n\t\t}\n\t}\n\t\n\tpart smallVehicle :> vehicle {\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[4];\n\t\t}\n\t}\n\t\n\tpart bigVehicle :> vehicle {\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[6];\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "State Definition Example-1",
      "text": "系统应定义一个车辆状态管理流程，以控制车辆在“关闭”、“启动中”和“开启”状态之间的转换。初始状态为“关闭”。当车辆接收到启动信号时，状态从“关闭”转换为“启动中”；当接收到开启信号后，状态进一步从“启动中”转换为“开启”。在车辆开启后，若接收到关闭信号，则状态从“开启”切换回“关闭”。通过这一状态管理流程，系统能够根据信号控制车辆的状态转换，确保车辆操作的有序性和安全性。",
      "label": "package 'State Definition Example-1' {\n\t\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\t\t\n\tstate def VehicleStates {\n\t\tentry; then off;\n\t\t\n\t\tstate off;\n\t\t\n\t\ttransition off_to_starting\n\t\t\tfirst off\n\t\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\t\t\n\t\tstate starting;\n\t\t\n\t\ttransition starting_to_on\n\t\t\tfirst starting\n\t\t\taccept VehicleOnSignal\n\t\t\tthen on;\n\t\t\t\n\t\tstate on;\n\t\t\n\t\ttransition on_to_off\n\t\t\tfirst on\n\t\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\t}\n\t\n}"
    },
    {
      "name": "State Definition Example-2",
      "text": "系统应定义一个车辆状态管理流程，以控制车辆在“关闭”、“启动中”和“开启”状态之间的转换。系统的初始状态为“关闭”。当接收到启动信号时，车辆状态从“关闭”切换到“启动中”；当接收到开启信号后，状态从“启动中”转换为“开启”。在车辆处于“开启”状态时，若接收到关闭信号，则状态从“开启”切换回“关闭”。该状态管理流程确保了车辆在不同操作信号下的顺序转换，实现车辆操作的有效控制和安全管理。",
      "label": "package 'State Definition Example-2' {\n\t\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\t\t\n\tstate def VehicleStates {\n\t\tentry; then off;\n\t\t\n\t\tstate off;\n\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\t\t\n\t\tstate starting;\n\t\taccept VehicleOnSignal\n\t\t\tthen on;\n\t\t\t\n\t\tstate on;\n\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\t}\n\t\n}"
    },
    {
      "name": "Dependency Example",
      "text": "系统应支持子系统与软件设计组件之间的依赖关系定义，以明确硬件和软件组件间的相互作用和依赖。System Assembly包含“计算子系统”和“存储子系统”两部分，每个子系统可能依赖于特定的软件设计模块来完成其功能。\n\n在该依赖关系中，“计算子系统”与Software Design包建立了一般性依赖关系，表明计算子系统的运行需要依赖软件设计的内容。而“存储子系统”则具体依赖于Software Design包中的MessageSchema和DataSchema，用于数据交换和管理。这些依赖关系确保硬件和软件模块之间的交互接口清晰明确，使系统在设计和操作中保持功能的一致性。\n\n通过这种依赖关系定义，系统可以清晰表示硬件子系统与软件模块之间的连接需求，为系统集成提供精确的依赖描述，确保在设计和实现过程中系统的模块间相互依赖关系得到满足。",
      "label": "package 'Dependency Example' {\n\t\n\tpart 'System Assembly' {\n\t\tpart 'Computer Subsystem' {\n\t\t\t// ...\n\t\t}\n\t\t\n\t\tpart 'Storage Subsystem' {\n\t\t\t// ...\n\t\t}\n\t}\n\t\n\tpackage 'Software Design' {\n\t\titem def MessageSchema {\n\t\t\t// ...\n\t\t}\n\t\titem def DataSchema {\n\t\t\t// ...\n\t\t}\n\t}\n\t\n\tdependency from 'System Assembly'::'Computer Subsystem' to 'Software Design';\n\t\n\tdependency Schemata \n\t\tfrom 'System Assembly'::'Storage Subsystem' \n\t\tto 'Software Design'::MessageSchema, 'Software Design'::DataSchema;\n}"
    },
    {
      "name": "Verification Case Definition Example",
      "text": "系统应支持车辆质量的验证测试，以确保其符合设定的质量要求。车辆质量验证案例（VehicleMassTest）通过一系列验证步骤来检查车辆是否满足质量上限，确保车辆的实际质量不超过2500千克。\n\n在此验证过程中，测试对象为车辆实例testVehicle，验证目标是验证该车辆是否满足质量要求（vehicleMassRequirement）。首先，系统通过“数据收集”步骤（collectData）从测试车辆中测量实际质量，输出测得的质量值（massMeasured）。接着，系统在“数据处理”步骤（processData）中对测得质量数据进行处理，以得到处理后的质量值（massProcessed）。\n\n最终，在“数据评估”步骤（evaluateData）中，系统使用处理后的质量数据来评估车辆是否满足质量要求。系统将该质量值与质量要求进行比对，若满足不超过2500千克的限制，则生成“通过”判定（Pass）；否则生成“未通过”判定（Fail）。该判定结果将作为验证的最终输出（verdict），表明车辆的质量是否符合要求。\n\n此验证流程为车辆质量合规性提供了精确的测试和验证手段，通过自动化的数据收集、处理和评估，确保车辆设计在重量方面符合规范和安全标准。",
      "label": "package 'Verification Case Definition Example' {\n\t\n\tpart def Vehicle {\n\t\tattribute mass :> ISQ::mass;\n\t}\n\t\n\trequirement vehicleMassRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tin massActual :> ISQ::mass = vehicle.mass;\n\t\tdoc /* The vehicle mass shall be less than or equal to 2500 kg. */\n\t\t\n\t\trequire constraint { massActual <= 2500[SI::kg] }\n\t}\n\t\t\n\tverification def VehicleMassTest {\n\t\tprivate import VerificationCases::*;\n\n\t\tsubject testVehicle : Vehicle;\n\t\tobjective vehicleMassVerificationObjective {\n\t\t\t// The subject of the verify is automatically bound to 'testVehicle' here.\n\t\t\tverify vehicleMassRequirement;\n\t\t}\n\t\t\n\t\taction collectData {\n\t\t\tin part testVehicle : Vehicle = VehicleMassTest::testVehicle;\n\t\t\tout massMeasured :> ISQ::mass;\n\t\t}\n\t\t\n\t\taction processData {\n\t\t\tin massMeasured :> ISQ::mass = collectData.massMeasured;\n\t\t\tout massProcessed :> ISQ::mass;\n\t\t}\n\t\t\n\t\taction evaluateData {\n\t\t\tin massProcessed :> ISQ::mass = processData.massProcessed;\n\t\t\tout verdict : VerdictKind = \n\t\t\t\t// Check that 'testVehicle' statisfies 'vehicleMassRequirement' if its mass equals 'massProcessed'.\n\t\t\t\tPassIf(vehicleMassRequirement(vehicle = testVehicle(mass = massProcessed)));\n\t\t}\n\t\t\n\t\treturn verdict : VerdictKind = evaluateData.verdict;\n\t}\n\t\n}"
    },
    {
      "name": "Verification Case Usage Example",
      "text": "系统应支持车辆质量的验证测试使用场景，通过测试配置和测量系统来检查车辆的实际质量是否符合设计规范。在此验证配置中，质量验证系统（massVerificationSystem）执行车辆质量测试（vehicleMassTest），并使用测量部件（scale）来收集车辆的质量数据。\n\n车辆测试配置（vehicleTestConfig）作为待测对象，通过质量测试的collectData步骤由测量系统获取实际质量值。测量过程模拟了实际测量的操作，将测得的质量值作为输出数据，以支持后续的验证评估。\n\n在具体的测试实例中，质量验证系统testSystem用于针对不同的车辆个体（如TestVehicle1和TestVehicle2）进行测试。在第一个时间片（test1）中，系统执行车辆质量测试，对TestVehicle1进行质量验证，并假设其质量为2500千克。该测试应产生通过的结果，因为质量符合要求。在第二个时间片（test2）中，系统对TestVehicle2进行质量验证，并假设其质量为3000千克，此时测试结果应为不通过，因为质量超出2500千克的限制。\n\n通过这种时间片和实例化的配置，系统能够自动化地对多个测试对象进行质量验证，确保车辆在重量要求方面的合规性。此验证流程为车辆的质量管理提供了可靠的测试手段，使得质量合规性验证能够在不同对象和时间条件下进行系统化的检查。",
      "label": "package 'Verification Case Usage Example' {\n\tprivate import 'Verification Case Definition Example'::*;\n\t\n\tpart def MassVerificationSystem;\n\tpart def Scale;\n\t\n\tpart vehicleTestConfig : Vehicle {\n\t\t// ...\n\t}\n\t\n\tverification vehicleMassTest : VehicleMassTest {\n\t\tsubject testVehicle :> vehicleTestConfig;\n\t}\n\t\n\tpart massVerificationSystem : MassVerificationSystem {\n\t\tperform vehicleMassTest;\n\t\t\n\t\tpart scale : Scale {\n\t\t\tperform vehicleMassTest.collectData {\n\t\t\t\tin part :>> testVehicle;\n\t\t\t\t\n\t\t\t\t// In reality, this would be some more involved process.\n\t\t\t\tmeasurement = testVehicle.mass;\n\t\t\t\t\n\t\t\t\tout :>> massMeasured = measurement;\n\t\t\t}\n\t\t}\n\t}\t\t\n\t\t\n\tindividual def TestSystem :> MassVerificationSystem;\n\t\n\tindividual def TestVehicle1 :> Vehicle;\n\tindividual def TestVehicle2 :> Vehicle;\n\n\tindividual testSystem : TestSystem :> massVerificationSystem {\n\t\ttimeslice test1 {\n\t\t\tperform action :>> vehicleMassTest {\n\t\t\t\tin individual :>> testVehicle : TestVehicle1 {\n\t\t\t\t\t:>> mass = 2500[SI::kg];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthen timeslice test2 {\n\t\t\tperform action :>> vehicleMassTest {\n\t\t\t\tin individual :>> testVehicle : TestVehicle2 {\n\t\t\t\t\t:>> mass = 3000[SI::kg];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "name": "Model Library Example",
      "text": "系统应支持场景与事件的建模和管理，以便在设计过程中追踪和评估潜在的风险和失败场景。此模型库定义了抽象的情况（Situation）、原因（Cause）和故障（Failure）等事件类型，并提供了属性来评估其概率和严重性。\n\n在此库中，Cause表示特定事件的发生原因，具备概率属性，用于量化事件发生的可能性。Failure则表示事件的故障结果，具有严重性属性（severity），用于量化故障的影响级别。\n\n此外，系统还定义了因果关系连接（Causation），用于表示一个事件在另一个事件之前发生的因果顺序，以支持事件链的建模和分析。Causation连接可用于描述“原因”导致“故障”的因果链，使系统能够追踪复杂的因果关系。\n\n在特定情境下，Scenario实例化了这些事件及其因果关系，包含一组具体的事件情况（situations）、原因和故障的集合。每个情景（Scenario）包含一系列事件的非唯一实例化（nonunique），确保系统能够在不同场景中重复使用事件，支持多种情况的并发分析。",
      "label": "library package 'Model Library Example' {\n\tprivate import ScalarValues::Real;\n\tprivate import RiskMetadata::Level;\n\t\n\tabstract occurrence def Situation;\n\t\n\tabstract occurrence situations : Situation[*] nonunique;\n\t\n\tabstract occurrence def Cause {\n\t\tattribute probability : Real;\n\t}\n\t\n\tabstract occurrence causes : Cause[*] nonunique :> situations;\n\t\n\tabstract occurrence def Failure {\n\t\tattribute severity : Level;\n\t}\n\t\n\tabstract occurrence failures : Failure[*] nonunique :> situations;\n\t\n\tabstract connection def Causation :> Occurrences::HappensBefore {\n\t\tend cause : Situation[*];\n\t\tend effect : Situation[*];\n\t}\n\t\n\tabstract connection causations : Causation[*] nonunique;\n\t\n\titem def Scenario {\n\t\toccurrence :>> situations;\n\t\toccurrence :>> causes :> situations;\n\t\toccurrence :>> failures :> situations;\n\t}\n\t\n\titem scenarios : Scenario[*] nonunique;\n}"
    },
    {
      "name": "User Keyword Example",
      "text": "系统应支持通过用户关键字定义事件场景和因果链，以对设备故障进行建模和分析。在此设备故障场景（DeviceFailure）中，系统定义了一个具体的设备故障流程，其中涉及原因、情况、故障及其相互关系，以展示设备在电池电量低的情况下的故障行为。\n\n在场景中，电池的老化（battery old）被定义为一个可能导致故障的原因，并被赋予了发生概率（0.01）。在因果链中，电池老化会导致电池电量低（power low）的情况。系统将“电池电量低”定义为特定情境，并通过约束条件确保在此情境下设备的电池功率低于设定的最小值（minPower），以反映电池状态的衰退对设备的影响。\n\n该因果链进一步延伸，在电量低的情况下最终导致设备关机（device shutoff）这一故障情境。系统为该故障设定了严重性级别（LevelEnum::high），以反映关机故障的严重影响。\n\n通过这种基于用户关键字的语义定义，系统能够灵活地创建设备故障场景及其因果链，使风险和故障分析更加直观易懂。此方法确保在复杂系统中能清晰地表示事件之间的因果关系，提升系统对潜在风险的预见性和响应能力，为可靠性设计和故障管理提供了强有力的支持。",
      "label": "package 'User Keyword Example' {\n\tprivate import ScalarValues::Real;\n\tprivate import 'Semantic Metadata Example'::*;\n\tprivate import RiskMetadata::LevelEnum;\n\t\n\tpart def Device {\n\t\tpart battery {\n\t\t\tattribute power : Real;\n\t\t}\n\t}\n\t\n\t#scenario def DeviceFailure {\n\t\tref device : Device;\n\t\tattribute minPower : Real;\n\t\t\n\t\t#cause 'battery old' {\n\t\t\t:>> probability = 0.01;\t\t\t\n\t\t}\n\t\t\n\t\t#causation first 'battery old' then 'power low';\n\t\t\n\t\t#situation 'power low' {\n\t\t\tconstraint { device.battery.power < minPower }\t\t\t\n\t\t}\n\t\t\n\t\t#causation first 'power low' then 'device shutoff';\n\t\t\n\t\t#failure 'device shutoff' {\n\t\t\t:>> severity = LevelEnum::high;\n\t\t}\n\t}\n}"
    },
    {
      "name": "Semantic Metadata Example",
      "text": "系统应支持语义元数据的定义和应用，以便在模型中明确表示事件、原因、故障和场景的语义类型。此语义元数据库通过将元数据应用到`Model Library Example`中定义的各个事件类型，使得系统能够为每个事件类别提供一致的语义描述，确保模型元素在不同上下文中的含义明确。\n\n元数据定义包含以下内容：\n\n- **situation** 元数据，用于标记所有的事件情况（situations），确保这些情况在模型中被一致地识别为`SysML::Usage`的一种。\n- **cause** 元数据，应用于事件原因（causes），确保模型中的所有原因实例被识别为`SysML::Usage`的一部分。\n- **failure** 元数据，用于标记事件故障（failures），确保故障事件统一为`SysML::Usage`。\n- **causation** 元数据，用于因果关系连接（causations），统一因果链中的连接关系类型，确保模型能够清晰地表示因果关系。\n- **scenario** 元数据，用于标记所有的事件场景（scenarios），确保场景实例作为`SysML::Usage`的一部分存在于模型中。\n\n这些语义元数据定义确保系统在使用这些事件类型时具备统一的语义结构，使模型内容在不同设计和应用场景中具有一致性和清晰的含义。这一语义标记机制为模型的解释和应用提供了标准化的语义支持，提升了系统在风险管理、故障分析和情境建模中的可读性和准确性。",
      "label": "library package 'Semantic Metadata Example' {\n\tprivate import 'Model Library Example'::*;\n\tprivate import Metaobjects::SemanticMetadata;\n\n\tmetadata def situation :> SemanticMetadata {\n\t\t:>> baseType = situations meta SysML::Usage;\n\t}\n\t\n\tmetadata def cause :> SemanticMetadata {\n\t\t:>> baseType = causes meta SysML::Usage;\n\t}\n\t\n\tmetadata def failure :> SemanticMetadata {\n\t\t:>> baseType = failures meta SysML::Usage;\n\t}\n\t\n\tmetadata def causation :> SemanticMetadata {\n\t\t:>> baseType = causations meta SysML::Usage;\n\t}\n\t\n\tmetadata def scenario :> SemanticMetadata {\n\t\t:>> baseType = scenarios meta SysML::Usage;\n\t}\n\t\n}"
    },
    {
      "name": "Port Example",
      "text": "系统应定义一个燃料输出端口（FuelOutPort）和一个燃料输入端口（FuelInPort），用于管理燃料的供给和回流，并包含温度属性以监控燃料温度。燃料输出端口应具备燃料供应（输出）和燃料回流（输入）的功能，而燃料输入端口应具备燃料供应（输入）和燃料回流（输出）的功能。燃料箱组件应配备一个燃料输出端口，以便向其他部件提供燃料，发动机部件则应配备一个燃料输入端口，以便接收来自燃料箱的燃料并返回未使用的燃料，从而实现燃料循环与发动机供能的需求。",
      "label": "package 'Port Example' {\n\t\n\tattribute def Temp;\n\t\n\tpart def Fuel;\n\t\n\tport def FuelOutPort {\n\t\tattribute temperature : Temp;\n\t\tout item fuelSupply : Fuel;\n\t\tin item fuelReturn : Fuel;\n\t}\n\t\n\tport def FuelInPort {\n\t\tattribute temperature : Temp;\n\t\tin item fuelSupply : Fuel;\n\t\tout item fuelReturn : Fuel;\n\t}\n\t\n\tpart def FuelTankAssembly {\n\t\tport fuelTankPort : FuelOutPort;\n\t}\n\t\n\tpart def Engine {\n\t\tport engineFuelPort : FuelInPort;\n\t}\n}"
    },
    {
      "name": "Port Conjugation Example",
      "text": "系统应定义一个燃料端口（FuelPort），用于处理燃料流入和流出的交互，且包含一个温度属性以监控燃料的温度。燃料端口应具备燃料供应（输出）和燃料回流（输入）两项功能。系统的燃料箱部件应配备一个燃料箱端口，支持燃料的输入输出连接，而发动机部件应配备一个相对的燃料端口，以便与燃料箱的端口对接，实现燃料的供给和回流，从而确保发动机的正常运作。",
      "label": "package 'Port Conjugation Example' {\n\t\n\tattribute def Temp;\n\t\n\tpart def Fuel;\n\t\n\tport def FuelPort {\n\t\tattribute temperature : Temp;\n\t\tout item fuelSupply : Fuel;\n\t\tin item fuelReturn : Fuel;\n\t}\n\t\n\tpart def FuelTank {\n\t\tport fuelTankPort : FuelPort;\n\t}\n\t\n\tpart def Engine {\n\t\tport engineFuelPort : ~FuelPort;\n\t}\n}"
    },
    {
      "name": "Binding Connectors Example-2",
      "text": "系统应定义一个车辆实体，其中包含一个燃料箱组件，该组件通过燃料端口处理燃料的供应和回流。燃料箱组件的端口应重新定义燃料供应和回流的项，以便清晰指定燃料的流向。燃料泵部件应将其输出项绑定至燃料箱端口的燃料供应项，实现燃料的传输；燃料箱部件的回流项应绑定至燃料箱端口的燃料回流项，以便支持未消耗燃料的循环回流，从而保证燃料在燃料泵和燃料箱之间的连续流动。",
      "label": "package 'Binding Connectors Example-2' {\n\tprivate import 'Port Example'::*;\n\t\n\tpart def Vehicle;\n\tpart def FuelPump;\n\tpart def FuelTank;\n\t\n\tpart vehicle : Vehicle {\t\n\t\tpart tank : FuelTankAssembly {\n\t\t\tport redefines fuelTankPort {\n\t\t\t\tout item redefines fuelSupply;\n\t\t\t\tin item redefines fuelReturn;\n\t\t\t}\n\t\t\t\n\t\t\tpart pump : FuelPump {\n\t\t\t\tout item pumpOut : Fuel = fuelTankPort.fuelSupply;\n\t\t\t\tin item pumpIn : Fuel;\n\t\t\t}\n\t\t\t\n\t\t\tpart tank : FuelTank {\n\t\t\t\tout item fuelOut : Fuel;\n\t\t\t\tin item fuelIn : Fuel = fuelTankPort.fuelReturn;\n\t\t\t}\n\t\t}\n\t} \n}"
    },
    {
      "name": "Binding Connectors Example-1",
      "text": "系统应定义一个车辆实体，其中包含一个燃料箱组件，负责燃料的供应和回流。燃料箱组件应配备一个重新定义的燃料端口，以明确燃料的输出和回流项。该系统应通过绑定连接，将燃料箱端口的燃料供应项与燃料泵的输出项绑定，将燃料回流项与燃料箱的输入项绑定，从而确保燃料在泵、燃料箱和发动机之间的稳定流动。燃料泵部件应具备输出和输入项，用于将燃料从燃料箱传送至发动机，并将未消耗的燃料回流至燃料箱，以维持有效的燃料循环。",
      "label": "package 'Binding Connectors Example-1' {\n\tprivate import 'Port Example'::*;\n\t\n\tpart def Vehicle;\n\tpart def FuelPump;\n\tpart def FuelTank;\n\t\n\tpart vehicle : Vehicle {\t\n\t\tpart tank : FuelTankAssembly {\n\t\t\tport redefines fuelTankPort {\n\t\t\t\tout item redefines fuelSupply;\n\t\t\t\tin item redefines fuelReturn;\n\t\t\t}\n\t\t\t\n\t\t\tbind fuelTankPort.fuelSupply = pump.pumpOut;\n\t\t\tbind fuelTankPort.fuelReturn = tank.fuelIn;\n\t\t\t\n\t\t\tpart pump : FuelPump {\n\t\t\t\tout item pumpOut : Fuel;\n\t\t\t\tin item pumpIn : Fuel;\n\t\t\t}\n\t\t\t\n\t\t\tpart tank : FuelTank {\n\t\t\t\tout item fuelOut : Fuel;\n\t\t\t\tin item fuelIn : Fuel;\n\t\t\t}\n\t\t}\n\t} \n}"
    },
    {
      "name": "Comment Example",
      "text": "系统应支持在模型中添加多种类型的注释，用于描述和解释模型元素的含义和作用。注释可以是命名的，也可以是匿名的，命名注释用于标识特定的注释，而匿名注释则直接关联到模型中的某个元素，以提供更多的上下文信息。\n此外，系统允许创建别名，并为其添加注释以说明该别名的目的或作用。注释和别名的组合为模型的构建提供了更高的可读性和易用性，而这些注释不直接影响模型的结构或行为。",
      "label": "package 'Comment Example' {\n\t/* This is a comment, which is a part of the model, \n\t * annotating (by default) it's owning namespace. */\n\t\n\tcomment Comment1 /* This is a named comment. */\n\t\n\tcomment about Automobile\n\t/* This is an unnamed comment, annotating an \n\t * explicitly specified element. \n\t */\n\t \n\tpart def Automobile;\n\t\n\talias Car for Automobile {\n\t\t/*\n\t\t * This is a comment annotating its owning\n\t\t * element.\n\t\t */\n\t}\t                         \n\t\n\t// This is a note. It is in the text, but not part \n\t// of the model.\n\talias Torque for ISQ::TorqueValue;\n}"
    },
    {
      "name": "Documentation Example",
      "text": "系统应支持在模型中添加注释，以便提供对模型元素的说明和注解。 注释可以是命名的或匿名的，命名注释为特定元素提供标识，而匿名注释则可应用于特定的元素以提供进一步的描述。 此外，系统支持为已有的模型元素创建别名，并为别名添加注释来描述其功能或用途。这些注释和别名为模型提供了更高的可读性和灵活性。",
      "label": "package 'Documentation Example' {\n\tdoc /* This is documentation of the owning \n\t     * package.\n\t     */\n\t\n\tpart def Automobile {\n\t\tdoc Document1 /* This documentation of Automobile. */\n\t}\n\t\n\talias Car for Automobile {\n\t\tdoc /* This is documentation of the alias. */\n\t}\n\talias Torque for ISQ::TorqueValue;\n}"
    },
    {
      "name": "Package Example",
      "text": "系统应支持定义和管理模型包，并能够控制包内元素的可见性。 在该系统中，包内可以包含公开和私有的元素。公开的元素可以在外部访问，而私有的元素仅限于包内使用。 系统允许为已有模型元素创建别名，别名可以为其他命名空间中的元素提供更易理解的名称。 同时，通过引入外部命名空间中的元素，可以扩展系统的功能，增加模型的灵活性。",
      "label": "package 'Package Example' {\n\tpublic import ISQ::TorqueValue;\n\tprivate import ScalarValues::*;\n\t \n\tprivate part def Automobile;\n\t\n\tpublic alias Car for Automobile;\t                         \n\talias Torque for ISQ::TorqueValue;\n}"
    },
    {
      "name": "Views Example",
      "text": "系统应支持多种视图，以从不同角度展示和分析车辆的结构和特性，从而满足设计和验证需求。视图提供了对车辆结构和部件的多层次展示，包括树状结构图和表格形式的文本符号表示，使得系统能够直观展示车辆设计的复杂性和组成。\n\n“部件结构视图”（Part Structure View） 满足“系统结构视角”要求，通过过滤SysML::PartUsage来展示系统部件的分层结构，为用户提供一个关于系统分解的清晰视图。在“车辆结构视图”（vehicle structure view）中，系统展示车辆的所有部件，渲染为树状结构图，以便从总体上理解系统架构。\n\n表格化的视图展示 通过“文本符号表”（Textual Notation Table）渲染车辆的特定部件，包含两个主要视图：“安全特性视图” 和 “非安全特性视图”。在安全特性视图中，系统展示所有具有@Safety标记的部件，以表格形式呈现，便于快速识别所有安全相关的部件。而在非安全特性视图中，系统展示未被标记为安全特性的部件，帮助用户识别车辆中的辅助或非必要安全特性。\n\n这些视图为设计和验证团队提供了多角度的系统结构表示，使得系统的安全特性、模块化和分解结构在设计和验证过程中都能清晰呈现，确保车辆设计的全面性和合规性。",
      "label": "package 'Views Example' {\n\tprivate import Views::*;\n\tprivate import 'Viewpoint Example'::*;\n\tprivate import 'Filtering Example-2'::*;\n\t\n\tview def 'Part Structure View' {\n\t\tsatisfy 'system structure perspective';\t\t\n\t\tfilter @SysML::PartUsage;\n\t}\n\t\n\tview 'vehicle structure view' : 'Part Structure View' {\n\t\texpose vehicle::**;\n\t\trender asTreeDiagram;\n\t}\n\t\n\trendering asTextualNotationTable :> asElementTable {\n\t\tview :>> columnView[1] {\n\t\t\trender asTextualNotation;\n\t\t}\n\t}\n\n\tview 'vehicle tabular views' {\n\t\t\n\t\tview 'safety features view' : 'Part Structure View' {\n\t\t\texpose vehicle::**[@Safety];\n\t\t\trender asTextualNotationTable;\n\t\t}\n\t\t\n\t\tview 'non-safety features view' : 'Part Structure View' {\n\t\t\texpose vehicle::**[not (@Safety)];\n\t\t\trender asTextualNotationTable;\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Viewpoint Example",
      "text": "系统应支持通过不同视角（Viewpoint）和关注点（Concern）来分析和理解系统设计，确保系统的完整性和模块化特性。这些关注点帮助系统工程师和独立验证与验证团队（IV&V）从不同角度评估系统的架构和功能。\n\n在“系统分解”关注点中，系统工程师和IV&V团队关注系统如何被分解成子系统和组件，以确保系统具备所需的功能。理解这种分解结构是系统覆盖所有要求能力的基础，从而保障系统设计的全面性。\n\n在“模块化”关注点中，系统工程师关注系统各部分之间的清晰接口，以便系统的每个部分既能独立理解，又能作为整体的一部分协同工作。这种模块化设计通过定义良好的接口促进系统的理解和管理，提升设计的灵活性和可维护性。\n\n视角“系统结构视角”提供了系统结构的整体视图，结合了“系统分解”和“模块化”两个关注点，要求系统结构视图展示系统的分层分解，从指定的根部件开始。这一视角确保系统设计的分解和模块化特性清晰可见，为设计和验证团队提供有效的结构化视图，以支持系统的全面分析和验证。",
      "label": "package 'Viewpoint Example' {\t\n\tpart def 'Systems Engineer';\n\tpart def 'IV&V';\n\t\n\tconcern 'system breakdown' {\n\t\tdoc /* \n\t\t * To ensure that a system covers all its required capabilities,\n\t\t * it is necessary to understand how it is broken down into\n\t\t * subsystems and components that provide those capabilities.\n\t\t */\n\t\t \n\t\tstakeholder se : 'Systems Engineer';\n\t\tstakeholder ivv : 'IV&V';\n\t}\n\t\n\tconcern 'modularity' {\n\t\tdoc /*\n\t\t * There should be well defined interfaces between the parts of\n\t\t * a system that allow each part to be understood individually,\n\t\t * as well as being part of the whole system.\n\t\t */\n\t\t \n\t\t stakeholder se : 'Systems Engineer';\n\t}\n\t\n\tviewpoint 'system structure perspective' {\t\t\n\t\tframe 'system breakdown';\n\t\tframe 'modularity';\n\t\t\n\t\trequire constraint {\n\t\t\tdoc /*\n\t\t\t * A system structure view shall show the hierarchical \n\t\t\t * part decomposition of a system, starting with a \n\t\t\t * specified root part.\n\t\t\t */\n\t\t}\n\t}\n}"
    },
    {
      "name": "Calculation Usages-2",
      "text": "系统应支持车辆动力学的动态状态更新，通过计算功率、加速度、速度和位置来模拟车辆在直线运动中的状态变化。车辆的动力学模型应包含空气阻力系数（C_d）、摩擦系数（C_f）、轮功率（wheelPower）和质量（mass）等参数，用于准确地反映车辆的动力状况。\n\n在每个时间增量内，系统应接收当前的动态状态（DynamicState），其中包括当前速度和位置。基于这些输入，系统首先计算车辆的总功率，考虑轮功率、空气阻力、摩擦系数和车辆质量等因素。接着，系统使用该功率值和车辆质量来计算加速度，并根据加速度、时间增量和当前速度计算更新后的速度。同时，系统还应根据当前速度、时间增量和初始位置计算更新后的位置。\n\n系统将计算后的速度和位置组合为新的动态状态（newState），为下一个时间增量的动态模拟提供基础。该更新流程使系统能够在每个时间增量内精确跟踪和更新车辆的动态状态，为车辆的操控和动力分析提供实时数据支持，确保车辆动力学模拟的精度和连贯性。",
      "label": "package 'Calculation Usages-2' {\n\tprivate import ScalarValues::Real;\n\tprivate import ISQ::*;\n\tprivate import 'Calculation Definitions'::*;\n\t\n\tattribute def DynamicState {\n\t\tattribute v: SpeedValue;\n\t\tattribute x: LengthValue;\n\t}\n\t\n\tpart def VehicleDynamics {\n\t\tattribute C_d : Real;\n\t\tattribute C_f : Real;\n\t\tattribute wheelPower : PowerValue;\n\t\tattribute mass : MassValue;\n\t\t\n\t\tcalc updateState { \n\t\t\tin delta_t : TimeValue; \n\t\t\tin currState : DynamicState;\n\t\t\tattribute totalPower : PowerValue = Power(wheelPower, C_d, C_f, mass, currState.v);\n\t\t\t\n\t\t\treturn attribute newState : DynamicState {\n\t\t\t\t:>> v = Velocity(delta_t, currState.v, Acceleration(totalPower, mass, currState.v));\n\t\t\t\t:>> x = Position(delta_t, currState.x, currState.v);\n\t\t\t}\n\t\t}\n\t} \n\t\n}"
    },
    {
      "name": "Calculation Definitions",
      "text": "系统应支持一系列物理计算功能，以精确模拟车辆动力学中的功率、加速度、速度和位置的变化。每个计算模块应接受相关的输入参数，进行物理计算并返回相应的结果：\n\n功率计算（Power）：系统应根据输入的轮功率、空气阻力系数、摩擦系数、质量和速度来计算车辆的实际功率。计算过程中应先求得空气阻力和摩擦力，并从轮功率中扣除这些阻力，得到净功率。\n\n加速度计算（Acceleration）：系统应根据输入的净功率、质量和速度来计算加速度值。通过将净功率除以质量和速度的乘积，系统将获得当前加速度。\n\n速度计算（Velocity）：系统应根据时间增量、初始速度和加速度来计算车辆的当前速度。新速度应为初始速度加上加速度乘以时间增量的结果。\n\n位置计算（Position）：系统应基于时间增量、初始位置和速度计算车辆的当前位置。新位置应为初始位置加上速度乘以时间增量的结果。\n\n该计算模块提供的功能使系统能够实时追踪和模拟车辆的动态变化，为车辆动力学的分析和控制提供精确的数据支持。这些计算定义确保系统能够处理复杂的动力学变量，并满足对高精度物理模拟的需求。",
      "label": "package 'Calculation Definitions' {\n\tprivate import ScalarValues::Real;\n\tprivate import ISQ::*;\n\t\n\tcalc def Power { in whlpwr : PowerValue; in Cd : Real; in Cf : Real; in tm : MassValue; in v : SpeedValue;\n\t\tattribute drag = Cd * v;\n\t\tattribute friction = Cf * tm * v;\n\t\t\n\t\treturn : PowerValue = whlpwr - drag - friction;\n\t}\n\t\n\tcalc def Acceleration { in tp: PowerValue; in tm : MassValue; in v : SpeedValue;\n\t\treturn : AccelerationValue = tp / (tm * v);\n\t}\n\t\n\tcalc def Velocity { in dt : TimeValue; in v0 : SpeedValue; in a : AccelerationValue;\n\t\treturn : SpeedValue = v0 + a * dt;\n \t}\n \t\n\tcalc def Position { in dt : TimeValue; in x0 : LengthValue; in v : SpeedValue;\n\t\treturn : LengthValue = x0 + v * dt;\n\t}\n}"
    },
    {
      "name": "Calculation Usages-1",
      "text": "系统应支持车辆动力学的直线运动计算，通过一系列关联的物理计算模块实现车辆速度和位置的动态更新。车辆的动力学模型包含空气阻力系数（C_d）、摩擦系数（C_f）、轮功率（wheelPower）和质量（mass）等参数，用于进行准确的动力学模拟。\n\n在车辆的直线运动计算中，系统首先基于当前的轮功率、阻力系数、摩擦系数、车辆质量和输入速度计算净功率，以此计算出加速度（Acceleration）。随后，系统使用加速度、时间增量和初始速度计算出车辆的当前速度（Velocity）。最后，系统基于时间增量、初始位置和当前速度计算车辆的当前位置（Position）。\n\n通过这些计算，系统能够在每个时间增量内更新车辆的速度和位置，使得车辆动力学在直线运动中的状态变化得到准确的模拟和输出。这一计算流程确保系统可以在车辆操作中实时提供精确的动态信息，为车辆的控制和动力学分析提供可靠的数据支持。",
      "label": "package 'Calculation Usages-1' {\n\tprivate import ScalarValues::Real;\n\tprivate import ISQ::*;\n\tprivate import 'Calculation Definitions'::*;\n\t\n\tpart def VehicleDynamics {\n\t\tattribute C_d : Real;\n\t\tattribute C_f : Real;\n\t\tattribute wheelPower : PowerValue;\n\t\tattribute mass : MassValue;\n\t\t\n\t\taction straightLineDynamics {\n\t\t\tin delta_t : TimeValue;\n\t\t\tin v_in : SpeedValue;\n\t\t\tin x_in : LengthValue;\n\t\t\tout v_out : SpeedValue = vel.v;\n\t\t\tout x_out : LengthValue = pos.x;\n\t\t\n\t\t\tcalc acc : Acceleration {\n\t\t\t\tin tp = Power(wheelPower, C_d, C_f, mass, v_in);\n\t\t\t\tin tm = mass;\n\t\t\t\tin v = v_in;\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\t\n\t\t\tcalc vel : Velocity {\n\t\t\t\tin dt = delta_t;\n\t\t\t\tin v0 = v_in;\n\t\t\t\tin a = acc.a;\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\t\n\t\t\tcalc pos : Position {\n\t\t\t\tin dt = delta_t;\n\t\t\t\tin x0 = x_in;\n\t\t\t\tin v0 = vel.v;\n\t\t\t\treturn x;\t\n\t\t\t}\n\t\t}\n\t} \n\t\n}"
    },
    {
      "name": "Requirement Groups",
      "text": "系统应定义一系列分组的车辆和发动机需求，以确保车辆整体性能和发动机动力传输功能符合设计规范。车辆需求组（vehicleSpecification）涵盖了车辆的整体要求，包括车辆的总质量和空载质量的限制，确保其在不同负载情况下均符合质量要求。发动机需求组（engineSpecification）则专注于发动机的动力性能，包含动力传输接口和扭矩生成的要求。动力传输接口要求发动机能够通过离合器接口将生成的扭矩有效传递到变速器，以实现平稳可靠的动力传输。扭矩生成要求发动机在不同转速下能够按需生成相应的扭矩，确保其性能符合设计规范。通过这些需求组，系统能够在车辆和发动机的设计和操作中进行全面的合规性检查，确保整车和发动机的功能、安全性和可靠性达到预期标准。",
      "label": "package 'Requirement Groups' {\n\tprivate import 'Requirement Definitions'::*;\n\tprivate import 'Requirement Usages'::*;\n\t\n\tpart def Engine {\n\t\tport clutchPort: ClutchPort;\n\t\tperform action generateTorque: GenerateTorque;\n\t}\n\t\n\trequirement vehicleSpecification {\n\t\tdoc /* Overall vehicle requirements group */\n\t\t\n\t\tsubject vehicle : Vehicle;\n\t\t\n\t\trequire fullVehicleMassLimit;\n\t\trequire emptyVehicleMassLimit;\n\t}\n\t\n\trequirement engineSpecification {\n\t\tdoc /* Engine power requirements group */\n\t\t\n\t\tsubject engine : Engine;\n\t\t\n\t\trequirement drivePowerInterface : DrivePowerInterface {\n\t\t\tsubject = engine.clutchPort;\n\t\t}\n\t\t\n\t\trequirement torqueGeneration : TorqueGeneration {\n\t\t\tsubject = engine.generateTorque;\t\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Requirement Definitions",
      "text": "系统应具备一系列明确的要求，以确保车辆质量和驱动系统的功能符合设计标准。车辆质量限制要求规定，车辆的实际质量不得超过指定的质量上限，确保车辆符合质量要求。在具体应用中，车辆的总质量包括车身的干重和燃料质量，两者之和应满足这一质量约束，并假设燃料质量始终大于零。此外，驱动系统要求规定发动机应通过离合接口将产生的扭矩传递至变速器，确保动力传输的可靠性。发动机还应按照转速生成相应的扭矩，以满足预期的性能标准。通过这些需求，系统能够在车辆设计和操作中自动验证质量和动力传输的合规性，确保车辆的安全性和功能性达到规范。",
      "label": "package 'Requirement Definitions' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\n\trequirement def MassLimitationRequirement {\n\t\tdoc /* The actual mass shall be less than or equal to the required mass. */\n\t\t\n\t\tattribute massActual: MassValue;\n\t\tattribute massReqd: MassValue;\n\t\t\n\t\trequire constraint { massActual <= massReqd }\n\t}\n\t\n\tpart def Vehicle {\n\t\tattribute dryMass: MassValue;\n\t\tattribute fuelMass: MassValue;\n\t\tattribute fuelFullMass: MassValue;\n\t}\n\t\n\trequirement def <'1'> VehicleMassLimitationRequirement :> MassLimitationRequirement {\n\t\tdoc /* The total mass of a vehicle shall be less than or equal to the required mass. */\n\t\t\n\t\tsubject vehicle : Vehicle;\n\t\t\n\t\tattribute redefines massActual = vehicle.dryMass + vehicle.fuelMass;\n\t\t\n\t\tassume constraint { vehicle.fuelMass > 0[kg] }\n\t}\n\t\n\tport def ClutchPort;\n\taction def GenerateTorque;\n\t\n\trequirement def <'2'> DrivePowerInterface {\n\t\tdoc /* The engine shall transfer its generated torque to the transmission via the clutch interface. */\n\t\tsubject clutchPort: ClutchPort;\n\t}\n\t\t\n\trequirement def <'3'> TorqueGeneration {\n\t\tdoc /* The engine shall generate torque as a function of RPM as shown in Table 1. */\n\t\tsubject generateTorque: GenerateTorque;\n\t}\n}"
    },
    {
      "name": "Requirement Usages",
      "text": "系统应支持车辆质量限制的具体需求，以验证车辆在不同燃料状态下的质量是否符合设计规范。在满载状态下，fullVehicleMassLimit需求规定，车辆的总质量不得超过2000千克。此需求包含一条假设约束，即车辆在满载状态下燃料质量等于油箱的满容量（fuelFullMass），确保车辆在装满油箱时满足质量限制。\n\n在空载状态下，emptyVehicleMassLimit需求规定，车辆的总质量不得超过1500千克。此需求的假设约束指出，车辆的燃料质量应为零，即油箱为空，以验证车辆在无燃料情况下的质量合规性。\n\n通过这些质量限制需求，系统能够确保车辆在不同燃料状态下均符合质量规范，从而保证设计和制造过程中的安全性和性能达标。这种需求管理为车辆的全面质量控制提供了可靠的验证框架，使车辆在各种负载条件下的质量要求都得到满足。",
      "label": "package 'Requirement Usages' {\n\tprivate import SI::*;\n\tprivate import 'Requirement Definitions'::*;\n\t\n\trequirement <'1.1'> fullVehicleMassLimit : VehicleMassLimitationRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tattribute :>> massReqd = 2000[kg];\n\t\t\n\t\tassume constraint {\n\t\t\tdoc /* Full tank is full. */\n\t\t\tvehicle.fuelMass == vehicle.fuelFullMass\n\t\t}\n\t}\n\t\n\trequirement <'1.2'> emptyVehicleMassLimit : VehicleMassLimitationRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tattribute :>> massReqd = 1500[kg];\n\t\t\n\t\tassume constraint {\n\t\t\tdoc /* Full tank is empty. */\n\t\t\tvehicle.fuelMass == 0[kg]\n\t\t}\n\t}\n\t\n}"
    },
    {
      "name": "Requirement Satisfaction",
      "text": "系统应具备需求满足能力，以确保特定车辆和发动机的设计符合预定的功能和性能规范。车辆设计上下文（Vehicle c1 Design Context）中引用了特定车辆实例vehicle_c1及其关联的发动机engine_v1，并通过满足需求的方式来验证其设计符合车辆和发动机规范。\n\n在该设计中，车辆vehicle_c1执行“提供动力”操作，且其发动机engine_v1通过离合器接口执行“生成扭矩”操作，以满足动力传输和扭矩生成的要求。通过“满足”操作，系统能够自动验证车辆设计是否满足vehicleSpecification中的整体质量要求，同时验证发动机engine_v1是否符合engineSpecification中动力传输接口和扭矩生成的规范。\n\n此需求满足流程确保了车辆和发动机的设计在功能和性能上达到预期标准，为车辆和发动机的设计验证提供可靠的依据，从而支持符合规范的车辆生产和运维。",
      "label": "package 'Requirement Satisfaction' {\n\tprivate import 'Requirement Definitions'::*;\n\tprivate import 'Requirement Groups'::*;\n\t\n\taction 'provide power' {\n\t\taction 'generate torque' { }\n\t}\n\t\n\tpart vehicle_c1 : Vehicle {\n\t\tperform 'provide power';\n\t\t\t\n\t\tpart engine_v1: Engine {\n\t\t\tport :>> clutchPort;\n\t\t\tperform 'provide power'.'generate torque' :>> generateTorque;\n\t\t}\t\n\t}\n\t\n\tpart 'Vehicle c1 Design Context' {\n\t\t\n\t\tref vehicle_design :> vehicle_c1;\n\t\n\t\tsatisfy vehicleSpecification by vehicle_design;\n\t\tsatisfy engineSpecification by vehicle_design.engine_v1;\n\t\n\t}\n\t\n}"
    },
    {
      "name": "Part Definition Example",
      "text": "## 版本1\n系统应包含一个车辆实体，该实体具有质量和状态属性。\n车辆应包括一个引擎部件，并且能够引用一个驾驶员作为控制者。\n车辆的状态应包括档位设定和加速器位置，以便反映车辆的当前操作情况。\n\n## 版本2\n系统应能够定义并管理车辆对象。\n每辆车辆应具备以下基本信息：车辆的质量、当前状态（包括变速器设置和油门位置），\n以及与之关联的发动机和驾驶员。车辆的状态应反映当前的驾驶情况，\n包括变速器的档位和油门的踏板位置。每辆车辆应能够与一个驾驶员相关联，\n表示该车辆的使用者。系统应能够管理这些信息，确保车辆的各个组成部分和属性能够正确关联\n并反映实际情况。",
      "label": "package 'Part Definition Example' {\n\tprivate import ScalarValues::*;\n\t\n\tpart def Vehicle {\n\t\tattribute mass : Real;\n\t\tattribute status : VehicleStatus;\n\t\t\n\t\tpart eng : Engine;\n\t\t\n\t\tref part driver : Person;\n\t}\n\t\n\tattribute def VehicleStatus {\n\t\tattribute gearSetting : Integer;\n\t\tattribute acceleratorPosition : Real;\n\t}\n\t\n\tpart def Engine;\t\n\tpart def Person;\n}"
    }
  ]
}